[
    [
        "STORE_NAME",
        "from __future__ import annotations"
    ],
    [
        "STORE_NAME",
        "from collections.abc import Iterable"
    ],
    [
        "STORE_NAME",
        "import string"
    ],
    [
        "STORE_NAME",
        "from types import MappingProxyType"
    ],
    [
        "STORE_NAME",
        "from typing import Any, BinaryIO, NamedTuple"
    ],
    [
        "STORE_NAME",
        "from typing import Any, BinaryIO, NamedTuple"
    ],
    [
        "STORE_NAME",
        "from typing import Any, BinaryIO, NamedTuple"
    ],
    [
        "STORE_NAME",
        "from ._re import (\n    RE_DATETIME,\n    RE_LOCALTIME,\n    RE_NUMBER,\n    match_to_datetime,\n    match_to_localtime,\n    match_to_number,\n)"
    ],
    [
        "STORE_NAME",
        "from ._re import (\n    RE_DATETIME,\n    RE_LOCALTIME,\n    RE_NUMBER,\n    match_to_datetime,\n    match_to_localtime,\n    match_to_number,\n)"
    ],
    [
        "STORE_NAME",
        "from ._re import (\n    RE_DATETIME,\n    RE_LOCALTIME,\n    RE_NUMBER,\n    match_to_datetime,\n    match_to_localtime,\n    match_to_number,\n)"
    ],
    [
        "STORE_NAME",
        "from ._re import (\n    RE_DATETIME,\n    RE_LOCALTIME,\n    RE_NUMBER,\n    match_to_datetime,\n    match_to_localtime,\n    match_to_number,\n)"
    ],
    [
        "STORE_NAME",
        "from ._re import (\n    RE_DATETIME,\n    RE_LOCALTIME,\n    RE_NUMBER,\n    match_to_datetime,\n    match_to_localtime,\n    match_to_number,\n)"
    ],
    [
        "STORE_NAME",
        "from ._re import (\n    RE_DATETIME,\n    RE_LOCALTIME,\n    RE_NUMBER,\n    match_to_datetime,\n    match_to_localtime,\n    match_to_number,\n)"
    ],
    [
        "STORE_NAME",
        "from ._types import Key, ParseFloat, Pos"
    ],
    [
        "STORE_NAME",
        "from ._types import Key, ParseFloat, Pos"
    ],
    [
        "STORE_NAME",
        "from ._types import Key, ParseFloat, Pos"
    ],
    [
        "LOAD_NAME",
        "frozenset"
    ],
    [
        "LOAD_NAME",
        "range"
    ],
    [
        "CALL",
        "range(32)"
    ],
    [
        "CALL",
        "(chr(i) for i in range(32))"
    ],
    [
        "CALL",
        "frozenset(chr(i) for i in range(32))"
    ],
    [
        "LOAD_NAME",
        "frozenset"
    ],
    [
        "LOAD_NAME",
        "chr"
    ],
    [
        "CALL",
        "chr(127)"
    ],
    [
        "CALL",
        "frozenset(chr(127))"
    ],
    [
        "BINARY_OP",
        "frozenset(chr(i) for i in range(32)) | frozenset(chr(127))"
    ],
    [
        "STORE_NAME",
        "ASCII_CTRL"
    ],
    [
        "LOAD_NAME",
        "ASCII_CTRL"
    ],
    [
        "LOAD_NAME",
        "frozenset"
    ],
    [
        "CALL",
        "frozenset(\"\\t\")"
    ],
    [
        "BINARY_OP",
        "ASCII_CTRL - frozenset(\"\\t\")"
    ],
    [
        "STORE_NAME",
        "ILLEGAL_BASIC_STR_CHARS"
    ],
    [
        "LOAD_NAME",
        "ASCII_CTRL"
    ],
    [
        "LOAD_NAME",
        "frozenset"
    ],
    [
        "CALL",
        "frozenset(\"\\t\\n\")"
    ],
    [
        "BINARY_OP",
        "ASCII_CTRL - frozenset(\"\\t\\n\")"
    ],
    [
        "STORE_NAME",
        "ILLEGAL_MULTILINE_BASIC_STR_CHARS"
    ],
    [
        "LOAD_NAME",
        "ILLEGAL_BASIC_STR_CHARS"
    ],
    [
        "STORE_NAME",
        "ILLEGAL_LITERAL_STR_CHARS"
    ],
    [
        "LOAD_NAME",
        "ILLEGAL_MULTILINE_BASIC_STR_CHARS"
    ],
    [
        "STORE_NAME",
        "ILLEGAL_MULTILINE_LITERAL_STR_CHARS"
    ],
    [
        "LOAD_NAME",
        "ILLEGAL_BASIC_STR_CHARS"
    ],
    [
        "STORE_NAME",
        "ILLEGAL_COMMENT_CHARS"
    ],
    [
        "LOAD_NAME",
        "frozenset"
    ],
    [
        "CALL",
        "frozenset(\" \\t\")"
    ],
    [
        "STORE_NAME",
        "TOML_WS"
    ],
    [
        "LOAD_NAME",
        "TOML_WS"
    ],
    [
        "LOAD_NAME",
        "frozenset"
    ],
    [
        "CALL",
        "frozenset(\"\\n\")"
    ],
    [
        "BINARY_OP",
        "TOML_WS | frozenset(\"\\n\")"
    ],
    [
        "STORE_NAME",
        "TOML_WS_AND_NEWLINE"
    ],
    [
        "LOAD_NAME",
        "frozenset"
    ],
    [
        "LOAD_NAME",
        "string"
    ],
    [
        "LOAD_ATTR",
        "string.ascii_letters"
    ],
    [
        "LOAD_NAME",
        "string"
    ],
    [
        "LOAD_ATTR",
        "string.digits"
    ],
    [
        "BINARY_OP",
        "string.ascii_letters + string.digits"
    ],
    [
        "BINARY_OP",
        "string.ascii_letters + string.digits + \"-_\""
    ],
    [
        "CALL",
        "frozenset(string.ascii_letters + string.digits + \"-_\")"
    ],
    [
        "STORE_NAME",
        "BARE_KEY_CHARS"
    ],
    [
        "LOAD_NAME",
        "BARE_KEY_CHARS"
    ],
    [
        "LOAD_NAME",
        "frozenset"
    ],
    [
        "CALL",
        "frozenset(\"\\\"'\")"
    ],
    [
        "BINARY_OP",
        "BARE_KEY_CHARS | frozenset(\"\\\"'\")"
    ],
    [
        "STORE_NAME",
        "KEY_INITIAL_CHARS"
    ],
    [
        "LOAD_NAME",
        "frozenset"
    ],
    [
        "LOAD_NAME",
        "string"
    ],
    [
        "LOAD_ATTR",
        "string.hexdigits"
    ],
    [
        "CALL",
        "frozenset(string.hexdigits)"
    ],
    [
        "STORE_NAME",
        "HEXDIGIT_CHARS"
    ],
    [
        "LOAD_NAME",
        "MappingProxyType"
    ],
    [
        "CALL",
        "MappingProxyType(\n    {\n        \"\\\\b\": \"\\u0008\",  # backspace\n        \"\\\\t\": \"\\u0009\",  # tab\n        \"\\\\n\": \"\\u000A\",  # linefeed\n        \"\\\\f\": \"\\u000C\",  # form feed\n        \"\\\\r\": \"\\u000D\",  # carriage return\n        '\\\\\"': \"\\u0022\",  # quote\n        \"\\\\\\\\\": \"\\u005C\",  # backslash\n    }\n)"
    ],
    [
        "STORE_NAME",
        "BASIC_STR_ESCAPE_REPLACEMENTS"
    ],
    [
        "LOAD_NAME",
        "ValueError"
    ],
    [
        "CALL",
        "class TOMLDecodeError(ValueError):\n    \"\"\"An error raised if a document is not valid TOML.\"\"\""
    ],
    [
        "STORE_NAME",
        "class TOMLDecodeError(ValueError):\n    \"\"\"An error raised if a document is not valid TOML.\"\"\""
    ],
    [
        "LOAD_NAME",
        "float"
    ],
    [
        "STORE_NAME",
        "def load(fp: BinaryIO, /, *, parse_float: ParseFloat = float) -> dict[str, Any]:\n    \"\"\"Parse TOML from a binary file object.\"\"\"\n    b = fp.read()\n    try:\n        s = b.decode()\n    except AttributeError:\n        raise TypeError(\n            \"File must be opened in binary mode, e.g. use `open('foo.toml', 'rb')`\"\n        ) from None\n    return loads(s, parse_float=parse_float)"
    ],
    [
        "LOAD_NAME",
        "float"
    ],
    [
        "STORE_NAME",
        "def loads(s: str, /, *, parse_float: ParseFloat = float) -> dict[str, Any]:  # noqa: C901\n    \"\"\"Parse TOML from a string.\"\"\"\n\n    # The spec allows converting \"\\r\\n\" to \"\\n\", even in string\n    # literals. Let's do so to simplify parsing.\n    src = s.replace(\"\\r\\n\", \"\\n\")\n    pos = 0\n    out = Output(NestedDict(), Flags())\n    header: Key = ()\n    parse_float = make_safe_parse_float(parse_float)\n\n    # Parse one statement at a time\n    # (typically means one line in TOML source)\n    while True:\n        # 1. Skip line leading whitespace\n        pos = skip_chars(src, pos, TOML_WS)\n\n        # 2. Parse rules. Expect one of the following:\n        #    - end of file\n        #    - end of line\n        #    - comment\n        #    - key/value pair\n        #    - append dict to list (and move to its namespace)\n        #    - create dict (and move to its namespace)\n        # Skip trailing whitespace when applicable.\n        try:\n            char = src[pos]\n        except IndexError:\n            break\n        if char == \"\\n\":\n            pos += 1\n            continue\n        if char in KEY_INITIAL_CHARS:\n            pos = key_value_rule(src, pos, out, header, parse_float)\n            pos = skip_chars(src, pos, TOML_WS)\n        elif char == \"[\":\n            try:\n                second_char: str | None = src[pos + 1]\n            except IndexError:\n                second_char = None\n            out.flags.finalize_pending()\n            if second_char == \"[\":\n                pos, header = create_list_rule(src, pos, out)\n            else:\n                pos, header = create_dict_rule(src, pos, out)\n            pos = skip_chars(src, pos, TOML_WS)\n        elif char != \"#\":\n            raise suffixed_err(src, pos, \"Invalid statement\")\n\n        # 3. Skip comment\n        pos = skip_comment(src, pos)\n\n        # 4. Expect end of line or end of file\n        try:\n            char = src[pos]\n        except IndexError:\n            break\n        if char != \"\\n\":\n            raise suffixed_err(\n                src, pos, \"Expected newline or end of document after a statement\"\n            )\n        pos += 1\n\n    return out.data.dict"
    ],
    [
        "CALL",
        "class Flags:\n    \"\"\"Flags that map to parsed keys/namespaces.\"\"\"\n\n    # Marks an immutable namespace (inline array or inline table).\n    FROZEN = 0\n    # Marks a nest that has been explicitly created and can no longer\n    # be opened using the \"[table]\" syntax.\n    EXPLICIT_NEST = 1\n\n    def __init__(self) -> None:\n        self._flags: dict[str, dict] = {}\n        self._pending_flags: set[tuple[Key, int]] = set()\n\n    def add_pending(self, key: Key, flag: int) -> None:\n        self._pending_flags.add((key, flag))\n\n    def finalize_pending(self) -> None:\n        for key, flag in self._pending_flags:\n            self.set(key, flag, recursive=False)\n        self._pending_flags.clear()\n\n    def unset_all(self, key: Key) -> None:\n        cont = self._flags\n        for k in key[:-1]:\n            if k not in cont:\n                return\n            cont = cont[k][\"nested\"]\n        cont.pop(key[-1], None)\n\n    def set(self, key: Key, flag: int, *, recursive: bool) -> None:  # noqa: A003\n        cont = self._flags\n        key_parent, key_stem = key[:-1], key[-1]\n        for k in key_parent:\n            if k not in cont:\n                cont[k] = {\"flags\": set(), \"recursive_flags\": set(), \"nested\": {}}\n            cont = cont[k][\"nested\"]\n        if key_stem not in cont:\n            cont[key_stem] = {\"flags\": set(), \"recursive_flags\": set(), \"nested\": {}}\n        cont[key_stem][\"recursive_flags\" if recursive else \"flags\"].add(flag)\n\n    def is_(self, key: Key, flag: int) -> bool:\n        if not key:\n            return False  # document root has no flags\n        cont = self._flags\n        for k in key[:-1]:\n            if k not in cont:\n                return False\n            inner_cont = cont[k]\n            if flag in inner_cont[\"recursive_flags\"]:\n                return True\n            cont = inner_cont[\"nested\"]\n        key_stem = key[-1]\n        if key_stem in cont:\n            cont = cont[key_stem]\n            return flag in cont[\"flags\"] or flag in cont[\"recursive_flags\"]\n        return False"
    ],
    [
        "STORE_NAME",
        "class Flags:\n    \"\"\"Flags that map to parsed keys/namespaces.\"\"\"\n\n    # Marks an immutable namespace (inline array or inline table).\n    FROZEN = 0\n    # Marks a nest that has been explicitly created and can no longer\n    # be opened using the \"[table]\" syntax.\n    EXPLICIT_NEST = 1\n\n    def __init__(self) -> None:\n        self._flags: dict[str, dict] = {}\n        self._pending_flags: set[tuple[Key, int]] = set()\n\n    def add_pending(self, key: Key, flag: int) -> None:\n        self._pending_flags.add((key, flag))\n\n    def finalize_pending(self) -> None:\n        for key, flag in self._pending_flags:\n            self.set(key, flag, recursive=False)\n        self._pending_flags.clear()\n\n    def unset_all(self, key: Key) -> None:\n        cont = self._flags\n        for k in key[:-1]:\n            if k not in cont:\n                return\n            cont = cont[k][\"nested\"]\n        cont.pop(key[-1], None)\n\n    def set(self, key: Key, flag: int, *, recursive: bool) -> None:  # noqa: A003\n        cont = self._flags\n        key_parent, key_stem = key[:-1], key[-1]\n        for k in key_parent:\n            if k not in cont:\n                cont[k] = {\"flags\": set(), \"recursive_flags\": set(), \"nested\": {}}\n            cont = cont[k][\"nested\"]\n        if key_stem not in cont:\n            cont[key_stem] = {\"flags\": set(), \"recursive_flags\": set(), \"nested\": {}}\n        cont[key_stem][\"recursive_flags\" if recursive else \"flags\"].add(flag)\n\n    def is_(self, key: Key, flag: int) -> bool:\n        if not key:\n            return False  # document root has no flags\n        cont = self._flags\n        for k in key[:-1]:\n            if k not in cont:\n                return False\n            inner_cont = cont[k]\n            if flag in inner_cont[\"recursive_flags\"]:\n                return True\n            cont = inner_cont[\"nested\"]\n        key_stem = key[-1]\n        if key_stem in cont:\n            cont = cont[key_stem]\n            return flag in cont[\"flags\"] or flag in cont[\"recursive_flags\"]\n        return False"
    ],
    [
        "CALL",
        "class NestedDict:\n    def __init__(self) -> None:\n        # The parsed content of the TOML document\n        self.dict: dict[str, Any] = {}\n\n    def get_or_create_nest(\n        self,\n        key: Key,\n        *,\n        access_lists: bool = True,\n    ) -> dict:\n        cont: Any = self.dict\n        for k in key:\n            if k not in cont:\n                cont[k] = {}\n            cont = cont[k]\n            if access_lists and isinstance(cont, list):\n                cont = cont[-1]\n            if not isinstance(cont, dict):\n                raise KeyError(\"There is no nest behind this key\")\n        return cont\n\n    def append_nest_to_list(self, key: Key) -> None:\n        cont = self.get_or_create_nest(key[:-1])\n        last_key = key[-1]\n        if last_key in cont:\n            list_ = cont[last_key]\n            if not isinstance(list_, list):\n                raise KeyError(\"An object other than list found behind this key\")\n            list_.append({})\n        else:\n            cont[last_key] = [{}]"
    ],
    [
        "STORE_NAME",
        "class NestedDict:\n    def __init__(self) -> None:\n        # The parsed content of the TOML document\n        self.dict: dict[str, Any] = {}\n\n    def get_or_create_nest(\n        self,\n        key: Key,\n        *,\n        access_lists: bool = True,\n    ) -> dict:\n        cont: Any = self.dict\n        for k in key:\n            if k not in cont:\n                cont[k] = {}\n            cont = cont[k]\n            if access_lists and isinstance(cont, list):\n                cont = cont[-1]\n            if not isinstance(cont, dict):\n                raise KeyError(\"There is no nest behind this key\")\n        return cont\n\n    def append_nest_to_list(self, key: Key) -> None:\n        cont = self.get_or_create_nest(key[:-1])\n        last_key = key[-1]\n        if last_key in cont:\n            list_ = cont[last_key]\n            if not isinstance(list_, list):\n                raise KeyError(\"An object other than list found behind this key\")\n            list_.append({})\n        else:\n            cont[last_key] = [{}]"
    ],
    [
        "LOAD_NAME",
        "NamedTuple"
    ],
    [
        "CALL",
        "class Output(NamedTuple):\n    data: NestedDict\n    flags: Flags"
    ],
    [
        "STORE_NAME",
        "class Output(NamedTuple):\n    data: NestedDict\n    flags: Flags"
    ],
    [
        "STORE_NAME",
        "def skip_chars(src: str, pos: Pos, chars: Iterable[str]) -> Pos:\n    try:\n        while src[pos] in chars:\n            pos += 1\n    except IndexError:\n        pass\n    return pos"
    ],
    [
        "STORE_NAME",
        "def skip_until(\n    src: str,\n    pos: Pos,\n    expect: str,\n    *,\n    error_on: frozenset[str],\n    error_on_eof: bool,\n) -> Pos:\n    try:\n        new_pos = src.index(expect, pos)\n    except ValueError:\n        new_pos = len(src)\n        if error_on_eof:\n            raise suffixed_err(src, new_pos, f\"Expected {expect!r}\") from None\n\n    if not error_on.isdisjoint(src[pos:new_pos]):\n        while src[pos] not in error_on:\n            pos += 1\n        raise suffixed_err(src, pos, f\"Found invalid character {src[pos]!r}\")\n    return new_pos"
    ],
    [
        "STORE_NAME",
        "def skip_comment(src: str, pos: Pos) -> Pos:\n    try:\n        char: str | None = src[pos]\n    except IndexError:\n        char = None\n    if char == \"#\":\n        return skip_until(\n            src, pos + 1, \"\\n\", error_on=ILLEGAL_COMMENT_CHARS, error_on_eof=False\n        )\n    return pos"
    ],
    [
        "STORE_NAME",
        "def skip_comments_and_array_ws(src: str, pos: Pos) -> Pos:\n    while True:\n        pos_before_skip = pos\n        pos = skip_chars(src, pos, TOML_WS_AND_NEWLINE)\n        pos = skip_comment(src, pos)\n        if pos == pos_before_skip:\n            return pos"
    ],
    [
        "STORE_NAME",
        "def create_dict_rule(src: str, pos: Pos, out: Output) -> tuple[Pos, Key]:\n    pos += 1  # Skip \"[\"\n    pos = skip_chars(src, pos, TOML_WS)\n    pos, key = parse_key(src, pos)\n\n    if out.flags.is_(key, Flags.EXPLICIT_NEST) or out.flags.is_(key, Flags.FROZEN):\n        raise suffixed_err(src, pos, f\"Cannot declare {key} twice\")\n    out.flags.set(key, Flags.EXPLICIT_NEST, recursive=False)\n    try:\n        out.data.get_or_create_nest(key)\n    except KeyError:\n        raise suffixed_err(src, pos, \"Cannot overwrite a value\") from None\n\n    if not src.startswith(\"]\", pos):\n        raise suffixed_err(src, pos, \"Expected ']' at the end of a table declaration\")\n    return pos + 1, key"
    ],
    [
        "STORE_NAME",
        "def create_list_rule(src: str, pos: Pos, out: Output) -> tuple[Pos, Key]:\n    pos += 2  # Skip \"[[\"\n    pos = skip_chars(src, pos, TOML_WS)\n    pos, key = parse_key(src, pos)\n\n    if out.flags.is_(key, Flags.FROZEN):\n        raise suffixed_err(src, pos, f\"Cannot mutate immutable namespace {key}\")\n    # Free the namespace now that it points to another empty list item...\n    out.flags.unset_all(key)\n    # ...but this key precisely is still prohibited from table declaration\n    out.flags.set(key, Flags.EXPLICIT_NEST, recursive=False)\n    try:\n        out.data.append_nest_to_list(key)\n    except KeyError:\n        raise suffixed_err(src, pos, \"Cannot overwrite a value\") from None\n\n    if not src.startswith(\"]]\", pos):\n        raise suffixed_err(src, pos, \"Expected ']]' at the end of an array declaration\")\n    return pos + 2, key"
    ],
    [
        "STORE_NAME",
        "def key_value_rule(\n    src: str, pos: Pos, out: Output, header: Key, parse_float: ParseFloat\n) -> Pos:\n    pos, key, value = parse_key_value_pair(src, pos, parse_float)\n    key_parent, key_stem = key[:-1], key[-1]\n    abs_key_parent = header + key_parent\n\n    relative_path_cont_keys = (header + key[:i] for i in range(1, len(key)))\n    for cont_key in relative_path_cont_keys:\n        # Check that dotted key syntax does not redefine an existing table\n        if out.flags.is_(cont_key, Flags.EXPLICIT_NEST):\n            raise suffixed_err(src, pos, f\"Cannot redefine namespace {cont_key}\")\n        # Containers in the relative path can't be opened with the table syntax or\n        # dotted key/value syntax in following table sections.\n        out.flags.add_pending(cont_key, Flags.EXPLICIT_NEST)\n\n    if out.flags.is_(abs_key_parent, Flags.FROZEN):\n        raise suffixed_err(\n            src, pos, f\"Cannot mutate immutable namespace {abs_key_parent}\"\n        )\n\n    try:\n        nest = out.data.get_or_create_nest(abs_key_parent)\n    except KeyError:\n        raise suffixed_err(src, pos, \"Cannot overwrite a value\") from None\n    if key_stem in nest:\n        raise suffixed_err(src, pos, \"Cannot overwrite a value\")\n    # Mark inline table and array namespaces recursively immutable\n    if isinstance(value, (dict, list)):\n        out.flags.set(header + key, Flags.FROZEN, recursive=True)\n    nest[key_stem] = value\n    return pos"
    ],
    [
        "STORE_NAME",
        "def parse_key_value_pair(\n    src: str, pos: Pos, parse_float: ParseFloat\n) -> tuple[Pos, Key, Any]:\n    pos, key = parse_key(src, pos)\n    try:\n        char: str | None = src[pos]\n    except IndexError:\n        char = None\n    if char != \"=\":\n        raise suffixed_err(src, pos, \"Expected '=' after a key in a key/value pair\")\n    pos += 1\n    pos = skip_chars(src, pos, TOML_WS)\n    pos, value = parse_value(src, pos, parse_float)\n    return pos, key, value"
    ],
    [
        "STORE_NAME",
        "def parse_key(src: str, pos: Pos) -> tuple[Pos, Key]:\n    pos, key_part = parse_key_part(src, pos)\n    key: Key = (key_part,)\n    pos = skip_chars(src, pos, TOML_WS)\n    while True:\n        try:\n            char: str | None = src[pos]\n        except IndexError:\n            char = None\n        if char != \".\":\n            return pos, key\n        pos += 1\n        pos = skip_chars(src, pos, TOML_WS)\n        pos, key_part = parse_key_part(src, pos)\n        key += (key_part,)\n        pos = skip_chars(src, pos, TOML_WS)"
    ],
    [
        "STORE_NAME",
        "def parse_key_part(src: str, pos: Pos) -> tuple[Pos, str]:\n    try:\n        char: str | None = src[pos]\n    except IndexError:\n        char = None\n    if char in BARE_KEY_CHARS:\n        start_pos = pos\n        pos = skip_chars(src, pos, BARE_KEY_CHARS)\n        return pos, src[start_pos:pos]\n    if char == \"'\":\n        return parse_literal_str(src, pos)\n    if char == '\"':\n        return parse_one_line_basic_str(src, pos)\n    raise suffixed_err(src, pos, \"Invalid initial character for a key part\")"
    ],
    [
        "STORE_NAME",
        "def parse_one_line_basic_str(src: str, pos: Pos) -> tuple[Pos, str]:\n    pos += 1\n    return parse_basic_str(src, pos, multiline=False)"
    ],
    [
        "STORE_NAME",
        "def parse_array(src: str, pos: Pos, parse_float: ParseFloat) -> tuple[Pos, list]:\n    pos += 1\n    array: list = []\n\n    pos = skip_comments_and_array_ws(src, pos)\n    if src.startswith(\"]\", pos):\n        return pos + 1, array\n    while True:\n        pos, val = parse_value(src, pos, parse_float)\n        array.append(val)\n        pos = skip_comments_and_array_ws(src, pos)\n\n        c = src[pos : pos + 1]\n        if c == \"]\":\n            return pos + 1, array\n        if c != \",\":\n            raise suffixed_err(src, pos, \"Unclosed array\")\n        pos += 1\n\n        pos = skip_comments_and_array_ws(src, pos)\n        if src.startswith(\"]\", pos):\n            return pos + 1, array"
    ],
    [
        "STORE_NAME",
        "def parse_inline_table(src: str, pos: Pos, parse_float: ParseFloat) -> tuple[Pos, dict]:\n    pos += 1\n    nested_dict = NestedDict()\n    flags = Flags()\n\n    pos = skip_chars(src, pos, TOML_WS)\n    if src.startswith(\"}\", pos):\n        return pos + 1, nested_dict.dict\n    while True:\n        pos, key, value = parse_key_value_pair(src, pos, parse_float)\n        key_parent, key_stem = key[:-1], key[-1]\n        if flags.is_(key, Flags.FROZEN):\n            raise suffixed_err(src, pos, f\"Cannot mutate immutable namespace {key}\")\n        try:\n            nest = nested_dict.get_or_create_nest(key_parent, access_lists=False)\n        except KeyError:\n            raise suffixed_err(src, pos, \"Cannot overwrite a value\") from None\n        if key_stem in nest:\n            raise suffixed_err(src, pos, f\"Duplicate inline table key {key_stem!r}\")\n        nest[key_stem] = value\n        pos = skip_chars(src, pos, TOML_WS)\n        c = src[pos : pos + 1]\n        if c == \"}\":\n            return pos + 1, nested_dict.dict\n        if c != \",\":\n            raise suffixed_err(src, pos, \"Unclosed inline table\")\n        if isinstance(value, (dict, list)):\n            flags.set(key, Flags.FROZEN, recursive=True)\n        pos += 1\n        pos = skip_chars(src, pos, TOML_WS)"
    ],
    [
        "STORE_NAME",
        "def parse_basic_str_escape(\n    src: str, pos: Pos, *, multiline: bool = False\n) -> tuple[Pos, str]:\n    escape_id = src[pos : pos + 2]\n    pos += 2\n    if multiline and escape_id in {\"\\\\ \", \"\\\\\\t\", \"\\\\\\n\"}:\n        # Skip whitespace until next non-whitespace character or end of\n        # the doc. Error if non-whitespace is found before newline.\n        if escape_id != \"\\\\\\n\":\n            pos = skip_chars(src, pos, TOML_WS)\n            try:\n                char = src[pos]\n            except IndexError:\n                return pos, \"\"\n            if char != \"\\n\":\n                raise suffixed_err(src, pos, \"Unescaped '\\\\' in a string\")\n            pos += 1\n        pos = skip_chars(src, pos, TOML_WS_AND_NEWLINE)\n        return pos, \"\"\n    if escape_id == \"\\\\u\":\n        return parse_hex_char(src, pos, 4)\n    if escape_id == \"\\\\U\":\n        return parse_hex_char(src, pos, 8)\n    try:\n        return pos, BASIC_STR_ESCAPE_REPLACEMENTS[escape_id]\n    except KeyError:\n        raise suffixed_err(src, pos, \"Unescaped '\\\\' in a string\") from None"
    ],
    [
        "STORE_NAME",
        "def parse_basic_str_escape_multiline(src: str, pos: Pos) -> tuple[Pos, str]:\n    return parse_basic_str_escape(src, pos, multiline=True)"
    ],
    [
        "STORE_NAME",
        "def parse_hex_char(src: str, pos: Pos, hex_len: int) -> tuple[Pos, str]:\n    hex_str = src[pos : pos + hex_len]\n    if len(hex_str) != hex_len or not HEXDIGIT_CHARS.issuperset(hex_str):\n        raise suffixed_err(src, pos, \"Invalid hex value\")\n    pos += hex_len\n    hex_int = int(hex_str, 16)\n    if not is_unicode_scalar_value(hex_int):\n        raise suffixed_err(src, pos, \"Escaped character is not a Unicode scalar value\")\n    return pos, chr(hex_int)"
    ],
    [
        "STORE_NAME",
        "def parse_literal_str(src: str, pos: Pos) -> tuple[Pos, str]:\n    pos += 1  # Skip starting apostrophe\n    start_pos = pos\n    pos = skip_until(\n        src, pos, \"'\", error_on=ILLEGAL_LITERAL_STR_CHARS, error_on_eof=True\n    )\n    return pos + 1, src[start_pos:pos]"
    ],
    [
        "STORE_NAME",
        "def parse_multiline_str(src: str, pos: Pos, *, literal: bool) -> tuple[Pos, str]:\n    pos += 3\n    if src.startswith(\"\\n\", pos):\n        pos += 1\n\n    if literal:\n        delim = \"'\"\n        end_pos = skip_until(\n            src,\n            pos,\n            \"'''\",\n            error_on=ILLEGAL_MULTILINE_LITERAL_STR_CHARS,\n            error_on_eof=True,\n        )\n        result = src[pos:end_pos]\n        pos = end_pos + 3\n    else:\n        delim = '\"'\n        pos, result = parse_basic_str(src, pos, multiline=True)\n\n    # Add at maximum two extra apostrophes/quotes if the end sequence\n    # is 4 or 5 chars long instead of just 3.\n    if not src.startswith(delim, pos):\n        return pos, result\n    pos += 1\n    if not src.startswith(delim, pos):\n        return pos, result + delim\n    pos += 1\n    return pos, result + (delim * 2)"
    ],
    [
        "STORE_NAME",
        "def parse_basic_str(src: str, pos: Pos, *, multiline: bool) -> tuple[Pos, str]:\n    if multiline:\n        error_on = ILLEGAL_MULTILINE_BASIC_STR_CHARS\n        parse_escapes = parse_basic_str_escape_multiline\n    else:\n        error_on = ILLEGAL_BASIC_STR_CHARS\n        parse_escapes = parse_basic_str_escape\n    result = \"\"\n    start_pos = pos\n    while True:\n        try:\n            char = src[pos]\n        except IndexError:\n            raise suffixed_err(src, pos, \"Unterminated string\") from None\n        if char == '\"':\n            if not multiline:\n                return pos + 1, result + src[start_pos:pos]\n            if src.startswith('\"\"\"', pos):\n                return pos + 3, result + src[start_pos:pos]\n            pos += 1\n            continue\n        if char == \"\\\\\":\n            result += src[start_pos:pos]\n            pos, parsed_escape = parse_escapes(src, pos)\n            result += parsed_escape\n            start_pos = pos\n            continue\n        if char in error_on:\n            raise suffixed_err(src, pos, f\"Illegal character {char!r}\")\n        pos += 1"
    ],
    [
        "STORE_NAME",
        "def parse_value(  # noqa: C901\n    src: str, pos: Pos, parse_float: ParseFloat\n) -> tuple[Pos, Any]:\n    try:\n        char: str | None = src[pos]\n    except IndexError:\n        char = None\n\n    # IMPORTANT: order conditions based on speed of checking and likelihood\n\n    # Basic strings\n    if char == '\"':\n        if src.startswith('\"\"\"', pos):\n            return parse_multiline_str(src, pos, literal=False)\n        return parse_one_line_basic_str(src, pos)\n\n    # Literal strings\n    if char == \"'\":\n        if src.startswith(\"'''\", pos):\n            return parse_multiline_str(src, pos, literal=True)\n        return parse_literal_str(src, pos)\n\n    # Booleans\n    if char == \"t\":\n        if src.startswith(\"true\", pos):\n            return pos + 4, True\n    if char == \"f\":\n        if src.startswith(\"false\", pos):\n            return pos + 5, False\n\n    # Arrays\n    if char == \"[\":\n        return parse_array(src, pos, parse_float)\n\n    # Inline tables\n    if char == \"{\":\n        return parse_inline_table(src, pos, parse_float)\n\n    # Dates and times\n    datetime_match = RE_DATETIME.match(src, pos)\n    if datetime_match:\n        try:\n            datetime_obj = match_to_datetime(datetime_match)\n        except ValueError as e:\n            raise suffixed_err(src, pos, \"Invalid date or datetime\") from e\n        return datetime_match.end(), datetime_obj\n    localtime_match = RE_LOCALTIME.match(src, pos)\n    if localtime_match:\n        return localtime_match.end(), match_to_localtime(localtime_match)\n\n    # Integers and \"normal\" floats.\n    # The regex will greedily match any type starting with a decimal\n    # char, so needs to be located after handling of dates and times.\n    number_match = RE_NUMBER.match(src, pos)\n    if number_match:\n        return number_match.end(), match_to_number(number_match, parse_float)\n\n    # Special floats\n    first_three = src[pos : pos + 3]\n    if first_three in {\"inf\", \"nan\"}:\n        return pos + 3, parse_float(first_three)\n    first_four = src[pos : pos + 4]\n    if first_four in {\"-inf\", \"+inf\", \"-nan\", \"+nan\"}:\n        return pos + 4, parse_float(first_four)\n\n    raise suffixed_err(src, pos, \"Invalid value\")"
    ],
    [
        "STORE_NAME",
        "def suffixed_err(src: str, pos: Pos, msg: str) -> TOMLDecodeError:\n    \"\"\"Return a `TOMLDecodeError` where error message is suffixed with\n    coordinates in source.\"\"\"\n\n    def coord_repr(src: str, pos: Pos) -> str:\n        if pos >= len(src):\n            return \"end of document\"\n        line = src.count(\"\\n\", 0, pos) + 1\n        if line == 1:\n            column = pos + 1\n        else:\n            column = pos - src.rindex(\"\\n\", 0, pos)\n        return f\"line {line}, column {column}\"\n\n    return TOMLDecodeError(f\"{msg} (at {coord_repr(src, pos)})\")"
    ],
    [
        "STORE_NAME",
        "def is_unicode_scalar_value(codepoint: int) -> bool:\n    return (0 <= codepoint <= 55295) or (57344 <= codepoint <= 1114111)"
    ],
    [
        "STORE_NAME",
        "def make_safe_parse_float(parse_float: ParseFloat) -> ParseFloat:\n    \"\"\"A decorator to make `parse_float` safe.\n\n    `parse_float` must not return dicts or lists, because these types\n    would be mixed with parsed TOML tables and arrays, thus confusing\n    the parser. The returned decorated callable raises `ValueError`\n    instead of returning illegal types.\n    \"\"\"\n    # The default `float` callable never returns illegal types. Optimize it.\n    if parse_float is float:  # type: ignore[comparison-overlap]\n        return float\n\n    def safe_parse_float(float_str: str) -> Any:\n        float_value = parse_float(float_str)\n        if isinstance(float_value, (dict, list)):\n            raise ValueError(\"parse_float must not return dicts or lists\")\n        return float_value\n\n    return safe_parse_float"
    ],
    [
        "LOAD_FAST",
        "(chr(i) for i in range(32))"
    ],
    [
        "STORE_FAST",
        "i"
    ],
    [
        "LOAD_GLOBAL",
        "chr"
    ],
    [
        "LOAD_FAST",
        "i"
    ],
    [
        "CALL",
        "chr(i)"
    ],
    [
        "STORE_NAME",
        "\"\"\"An error raised if a document is not valid TOML.\"\"\""
    ],
    [
        "LOAD_FAST",
        "fp"
    ],
    [
        "LOAD_ATTR",
        "fp.read"
    ],
    [
        "CALL",
        "fp.read()"
    ],
    [
        "STORE_FAST",
        "b"
    ],
    [
        "LOAD_FAST",
        "b"
    ],
    [
        "LOAD_ATTR",
        "b.decode"
    ],
    [
        "CALL",
        "b.decode()"
    ],
    [
        "STORE_FAST",
        "s"
    ],
    [
        "LOAD_GLOBAL",
        "loads"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "LOAD_FAST",
        "parse_float"
    ],
    [
        "CALL",
        "loads(s, parse_float=parse_float)"
    ],
    [
        "LOAD_GLOBAL",
        "AttributeError"
    ],
    [
        "LOAD_GLOBAL",
        "TypeError"
    ],
    [
        "CALL",
        "TypeError(\n            \"File must be opened in binary mode, e.g. use `open('foo.toml', 'rb')`\"\n        )"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "LOAD_ATTR",
        "s.replace"
    ],
    [
        "CALL",
        "s.replace(\"\\r\\n\", \"\\n\")"
    ],
    [
        "STORE_FAST",
        "src"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "Output"
    ],
    [
        "LOAD_GLOBAL",
        "NestedDict"
    ],
    [
        "CALL",
        "NestedDict()"
    ],
    [
        "LOAD_GLOBAL",
        "Flags"
    ],
    [
        "CALL",
        "Flags()"
    ],
    [
        "CALL",
        "Output(NestedDict(), Flags())"
    ],
    [
        "STORE_FAST",
        "out"
    ],
    [
        "STORE_FAST",
        "header"
    ],
    [
        "LOAD_GLOBAL",
        "make_safe_parse_float"
    ],
    [
        "LOAD_FAST",
        "parse_float"
    ],
    [
        "CALL",
        "make_safe_parse_float(parse_float)"
    ],
    [
        "STORE_FAST",
        "parse_float"
    ],
    [
        "LOAD_GLOBAL",
        "skip_chars"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "TOML_WS"
    ],
    [
        "CALL",
        "skip_chars(src, pos, TOML_WS)"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_SUBSCR",
        "src[pos]"
    ],
    [
        "STORE_FAST",
        "char"
    ],
    [
        "LOAD_FAST",
        "char"
    ],
    [
        "COMPARE_OP",
        "char == \"\\n\""
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos += 1"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "char"
    ],
    [
        "LOAD_GLOBAL",
        "KEY_INITIAL_CHARS"
    ],
    [
        "CONTAINS_OP",
        "char in KEY_INITIAL_CHARS"
    ],
    [
        "LOAD_GLOBAL",
        "key_value_rule"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "out"
    ],
    [
        "LOAD_FAST",
        "header"
    ],
    [
        "LOAD_FAST",
        "parse_float"
    ],
    [
        "CALL",
        "key_value_rule(src, pos, out, header, parse_float)"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "skip_chars"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "TOML_WS"
    ],
    [
        "CALL",
        "skip_chars(src, pos, TOML_WS)"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "char"
    ],
    [
        "COMPARE_OP",
        "char == \"[\""
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos + 1"
    ],
    [
        "BINARY_SUBSCR",
        "src[pos + 1]"
    ],
    [
        "STORE_FAST",
        "second_char"
    ],
    [
        "LOAD_FAST",
        "out"
    ],
    [
        "LOAD_ATTR",
        "out.flags"
    ],
    [
        "LOAD_ATTR",
        "out.flags.finalize_pending"
    ],
    [
        "CALL",
        "out.flags.finalize_pending()"
    ],
    [
        "LOAD_FAST",
        "second_char"
    ],
    [
        "COMPARE_OP",
        "second_char == \"[\""
    ],
    [
        "LOAD_GLOBAL",
        "create_list_rule"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "out"
    ],
    [
        "CALL",
        "create_list_rule(src, pos, out)"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "STORE_FAST",
        "header"
    ],
    [
        "LOAD_GLOBAL",
        "create_dict_rule"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "out"
    ],
    [
        "CALL",
        "create_dict_rule(src, pos, out)"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "STORE_FAST",
        "header"
    ],
    [
        "LOAD_GLOBAL",
        "skip_chars"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "TOML_WS"
    ],
    [
        "CALL",
        "skip_chars(src, pos, TOML_WS)"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "char"
    ],
    [
        "COMPARE_OP",
        "char != \"#\""
    ],
    [
        "LOAD_GLOBAL",
        "suffixed_err"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "suffixed_err(src, pos, \"Invalid statement\")"
    ],
    [
        "LOAD_GLOBAL",
        "skip_comment"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "skip_comment(src, pos)"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_SUBSCR",
        "src[pos]"
    ],
    [
        "STORE_FAST",
        "char"
    ],
    [
        "LOAD_FAST",
        "char"
    ],
    [
        "COMPARE_OP",
        "char != \"\\n\""
    ],
    [
        "LOAD_GLOBAL",
        "suffixed_err"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "suffixed_err(\n                src, pos, \"Expected newline or end of document after a statement\"\n            )"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos += 1"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "IndexError"
    ],
    [
        "LOAD_FAST",
        "out"
    ],
    [
        "LOAD_ATTR",
        "out.data"
    ],
    [
        "LOAD_ATTR",
        "out.data.dict"
    ],
    [
        "LOAD_GLOBAL",
        "IndexError"
    ],
    [
        "STORE_FAST",
        "second_char"
    ],
    [
        "LOAD_GLOBAL",
        "IndexError"
    ],
    [
        "LOAD_FAST",
        "out"
    ],
    [
        "LOAD_ATTR",
        "out.data"
    ],
    [
        "LOAD_ATTR",
        "out.data.dict"
    ],
    [
        "STORE_NAME",
        "\"\"\"Flags that map to parsed keys/namespaces.\"\"\""
    ],
    [
        "STORE_NAME",
        "FROZEN"
    ],
    [
        "STORE_NAME",
        "EXPLICIT_NEST"
    ],
    [
        "STORE_NAME",
        "    def __init__(self) -> None:\n        self._flags: dict[str, dict] = {}\n        self._pending_flags: set[tuple[Key, int]] = set()"
    ],
    [
        "STORE_NAME",
        "    def add_pending(self, key: Key, flag: int) -> None:\n        self._pending_flags.add((key, flag))"
    ],
    [
        "STORE_NAME",
        "    def finalize_pending(self) -> None:\n        for key, flag in self._pending_flags:\n            self.set(key, flag, recursive=False)\n        self._pending_flags.clear()"
    ],
    [
        "STORE_NAME",
        "    def unset_all(self, key: Key) -> None:\n        cont = self._flags\n        for k in key[:-1]:\n            if k not in cont:\n                return\n            cont = cont[k][\"nested\"]\n        cont.pop(key[-1], None)"
    ],
    [
        "STORE_NAME",
        "    def set(self, key: Key, flag: int, *, recursive: bool) -> None:  # noqa: A003\n        cont = self._flags\n        key_parent, key_stem = key[:-1], key[-1]\n        for k in key_parent:\n            if k not in cont:\n                cont[k] = {\"flags\": set(), \"recursive_flags\": set(), \"nested\": {}}\n            cont = cont[k][\"nested\"]\n        if key_stem not in cont:\n            cont[key_stem] = {\"flags\": set(), \"recursive_flags\": set(), \"nested\": {}}\n        cont[key_stem][\"recursive_flags\" if recursive else \"flags\"].add(flag)"
    ],
    [
        "STORE_NAME",
        "    def is_(self, key: Key, flag: int) -> bool:\n        if not key:\n            return False  # document root has no flags\n        cont = self._flags\n        for k in key[:-1]:\n            if k not in cont:\n                return False\n            inner_cont = cont[k]\n            if flag in inner_cont[\"recursive_flags\"]:\n                return True\n            cont = inner_cont[\"nested\"]\n        key_stem = key[-1]\n        if key_stem in cont:\n            cont = cont[key_stem]\n            return flag in cont[\"flags\"] or flag in cont[\"recursive_flags\"]\n        return False"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._flags"
    ],
    [
        "LOAD_GLOBAL",
        "set"
    ],
    [
        "CALL",
        "set()"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._pending_flags"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._pending_flags"
    ],
    [
        "LOAD_ATTR",
        "self._pending_flags.add"
    ],
    [
        "LOAD_FAST",
        "key"
    ],
    [
        "LOAD_FAST",
        "flag"
    ],
    [
        "CALL",
        "self._pending_flags.add((key, flag))"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._pending_flags"
    ],
    [
        "STORE_FAST",
        "key"
    ],
    [
        "STORE_FAST",
        "flag"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.set"
    ],
    [
        "LOAD_FAST",
        "key"
    ],
    [
        "LOAD_FAST",
        "flag"
    ],
    [
        "CALL",
        "self.set(key, flag, recursive=False)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._pending_flags"
    ],
    [
        "LOAD_ATTR",
        "self._pending_flags.clear"
    ],
    [
        "CALL",
        "self._pending_flags.clear()"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._flags"
    ],
    [
        "STORE_FAST",
        "cont"
    ],
    [
        "LOAD_FAST",
        "key"
    ],
    [
        "BINARY_SLICE",
        "key[:-1]"
    ],
    [
        "STORE_FAST",
        "k"
    ],
    [
        "LOAD_FAST",
        "k"
    ],
    [
        "LOAD_FAST",
        "cont"
    ],
    [
        "CONTAINS_OP",
        "k not in cont"
    ],
    [
        "LOAD_FAST",
        "cont"
    ],
    [
        "LOAD_FAST",
        "k"
    ],
    [
        "BINARY_SUBSCR",
        "cont[k]"
    ],
    [
        "BINARY_SUBSCR",
        "cont[k][\"nested\"]"
    ],
    [
        "STORE_FAST",
        "cont"
    ],
    [
        "LOAD_FAST",
        "cont"
    ],
    [
        "LOAD_ATTR",
        "cont.pop"
    ],
    [
        "LOAD_FAST",
        "key"
    ],
    [
        "BINARY_SUBSCR",
        "key[-1]"
    ],
    [
        "CALL",
        "cont.pop(key[-1], None)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._flags"
    ],
    [
        "STORE_FAST",
        "cont"
    ],
    [
        "LOAD_FAST",
        "key"
    ],
    [
        "BINARY_SLICE",
        "key[:-1]"
    ],
    [
        "LOAD_FAST",
        "key"
    ],
    [
        "BINARY_SUBSCR",
        "key[-1]"
    ],
    [
        "STORE_FAST",
        "key_stem"
    ],
    [
        "STORE_FAST",
        "key_parent"
    ],
    [
        "LOAD_FAST",
        "key_parent"
    ],
    [
        "STORE_FAST",
        "k"
    ],
    [
        "LOAD_FAST",
        "k"
    ],
    [
        "LOAD_FAST",
        "cont"
    ],
    [
        "CONTAINS_OP",
        "k not in cont"
    ],
    [
        "LOAD_GLOBAL",
        "set"
    ],
    [
        "CALL",
        "set()"
    ],
    [
        "LOAD_GLOBAL",
        "set"
    ],
    [
        "CALL",
        "set()"
    ],
    [
        "LOAD_FAST",
        "cont"
    ],
    [
        "LOAD_FAST",
        "k"
    ],
    [
        "STORE_SUBSCR",
        "cont[k]"
    ],
    [
        "LOAD_FAST",
        "cont"
    ],
    [
        "LOAD_FAST",
        "k"
    ],
    [
        "BINARY_SUBSCR",
        "cont[k]"
    ],
    [
        "BINARY_SUBSCR",
        "cont[k][\"nested\"]"
    ],
    [
        "STORE_FAST",
        "cont"
    ],
    [
        "LOAD_FAST",
        "key_stem"
    ],
    [
        "LOAD_FAST",
        "cont"
    ],
    [
        "CONTAINS_OP",
        "key_stem not in cont"
    ],
    [
        "LOAD_GLOBAL",
        "set"
    ],
    [
        "CALL",
        "set()"
    ],
    [
        "LOAD_GLOBAL",
        "set"
    ],
    [
        "CALL",
        "set()"
    ],
    [
        "LOAD_FAST",
        "cont"
    ],
    [
        "LOAD_FAST",
        "key_stem"
    ],
    [
        "STORE_SUBSCR",
        "cont[key_stem]"
    ],
    [
        "LOAD_FAST",
        "cont"
    ],
    [
        "LOAD_FAST",
        "key_stem"
    ],
    [
        "BINARY_SUBSCR",
        "cont[key_stem]"
    ],
    [
        "LOAD_FAST",
        "recursive"
    ],
    [
        "BINARY_SUBSCR",
        "cont[key_stem][\"recursive_flags\" if recursive else \"flags\"]"
    ],
    [
        "LOAD_ATTR",
        "cont[key_stem][\"recursive_flags\" if recursive else \"flags\"].add"
    ],
    [
        "LOAD_FAST",
        "flag"
    ],
    [
        "CALL",
        "cont[key_stem][\"recursive_flags\" if recursive else \"flags\"].add(flag)"
    ],
    [
        "LOAD_FAST",
        "key"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._flags"
    ],
    [
        "STORE_FAST",
        "cont"
    ],
    [
        "LOAD_FAST",
        "key"
    ],
    [
        "BINARY_SLICE",
        "key[:-1]"
    ],
    [
        "STORE_FAST",
        "k"
    ],
    [
        "LOAD_FAST",
        "k"
    ],
    [
        "LOAD_FAST",
        "cont"
    ],
    [
        "CONTAINS_OP",
        "k not in cont"
    ],
    [
        "LOAD_FAST",
        "cont"
    ],
    [
        "LOAD_FAST",
        "k"
    ],
    [
        "BINARY_SUBSCR",
        "cont[k]"
    ],
    [
        "STORE_FAST",
        "inner_cont"
    ],
    [
        "LOAD_FAST",
        "flag"
    ],
    [
        "LOAD_FAST",
        "inner_cont"
    ],
    [
        "BINARY_SUBSCR",
        "inner_cont[\"recursive_flags\"]"
    ],
    [
        "CONTAINS_OP",
        "flag in inner_cont[\"recursive_flags\"]"
    ],
    [
        "LOAD_FAST",
        "inner_cont"
    ],
    [
        "BINARY_SUBSCR",
        "inner_cont[\"nested\"]"
    ],
    [
        "STORE_FAST",
        "cont"
    ],
    [
        "LOAD_FAST",
        "key"
    ],
    [
        "BINARY_SUBSCR",
        "key[-1]"
    ],
    [
        "STORE_FAST",
        "key_stem"
    ],
    [
        "LOAD_FAST",
        "key_stem"
    ],
    [
        "LOAD_FAST",
        "cont"
    ],
    [
        "CONTAINS_OP",
        "key_stem in cont"
    ],
    [
        "LOAD_FAST",
        "cont"
    ],
    [
        "LOAD_FAST",
        "key_stem"
    ],
    [
        "BINARY_SUBSCR",
        "cont[key_stem]"
    ],
    [
        "STORE_FAST",
        "cont"
    ],
    [
        "LOAD_FAST",
        "flag"
    ],
    [
        "LOAD_FAST",
        "cont"
    ],
    [
        "BINARY_SUBSCR",
        "cont[\"flags\"]"
    ],
    [
        "CONTAINS_OP",
        "flag in cont[\"flags\"]"
    ],
    [
        "LOAD_FAST",
        "flag"
    ],
    [
        "LOAD_FAST",
        "cont"
    ],
    [
        "BINARY_SUBSCR",
        "cont[\"recursive_flags\"]"
    ],
    [
        "CONTAINS_OP",
        "flag in cont[\"recursive_flags\"]"
    ],
    [
        "STORE_NAME",
        "    def __init__(self) -> None:\n        # The parsed content of the TOML document\n        self.dict: dict[str, Any] = {}"
    ],
    [
        "STORE_NAME",
        "    def get_or_create_nest(\n        self,\n        key: Key,\n        *,\n        access_lists: bool = True,\n    ) -> dict:\n        cont: Any = self.dict\n        for k in key:\n            if k not in cont:\n                cont[k] = {}\n            cont = cont[k]\n            if access_lists and isinstance(cont, list):\n                cont = cont[-1]\n            if not isinstance(cont, dict):\n                raise KeyError(\"There is no nest behind this key\")\n        return cont"
    ],
    [
        "STORE_NAME",
        "    def append_nest_to_list(self, key: Key) -> None:\n        cont = self.get_or_create_nest(key[:-1])\n        last_key = key[-1]\n        if last_key in cont:\n            list_ = cont[last_key]\n            if not isinstance(list_, list):\n                raise KeyError(\"An object other than list found behind this key\")\n            list_.append({})\n        else:\n            cont[last_key] = [{}]"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.dict"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.dict"
    ],
    [
        "STORE_FAST",
        "cont"
    ],
    [
        "LOAD_FAST",
        "key"
    ],
    [
        "STORE_FAST",
        "k"
    ],
    [
        "LOAD_FAST",
        "k"
    ],
    [
        "LOAD_FAST",
        "cont"
    ],
    [
        "CONTAINS_OP",
        "k not in cont"
    ],
    [
        "LOAD_FAST",
        "cont"
    ],
    [
        "LOAD_FAST",
        "k"
    ],
    [
        "STORE_SUBSCR",
        "cont[k]"
    ],
    [
        "LOAD_FAST",
        "cont"
    ],
    [
        "LOAD_FAST",
        "k"
    ],
    [
        "BINARY_SUBSCR",
        "cont[k]"
    ],
    [
        "STORE_FAST",
        "cont"
    ],
    [
        "LOAD_FAST",
        "access_lists"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "cont"
    ],
    [
        "LOAD_GLOBAL",
        "list"
    ],
    [
        "CALL",
        "isinstance(cont, list)"
    ],
    [
        "LOAD_FAST",
        "cont"
    ],
    [
        "BINARY_SUBSCR",
        "cont[-1]"
    ],
    [
        "STORE_FAST",
        "cont"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "cont"
    ],
    [
        "LOAD_GLOBAL",
        "dict"
    ],
    [
        "CALL",
        "isinstance(cont, dict)"
    ],
    [
        "LOAD_GLOBAL",
        "KeyError"
    ],
    [
        "CALL",
        "KeyError(\"There is no nest behind this key\")"
    ],
    [
        "LOAD_FAST",
        "cont"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.get_or_create_nest"
    ],
    [
        "LOAD_FAST",
        "key"
    ],
    [
        "BINARY_SLICE",
        "key[:-1]"
    ],
    [
        "CALL",
        "self.get_or_create_nest(key[:-1])"
    ],
    [
        "STORE_FAST",
        "cont"
    ],
    [
        "LOAD_FAST",
        "key"
    ],
    [
        "BINARY_SUBSCR",
        "key[-1]"
    ],
    [
        "STORE_FAST",
        "last_key"
    ],
    [
        "LOAD_FAST",
        "last_key"
    ],
    [
        "LOAD_FAST",
        "cont"
    ],
    [
        "CONTAINS_OP",
        "last_key in cont"
    ],
    [
        "LOAD_FAST",
        "cont"
    ],
    [
        "LOAD_FAST",
        "last_key"
    ],
    [
        "BINARY_SUBSCR",
        "cont[last_key]"
    ],
    [
        "STORE_FAST",
        "list_"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "list_"
    ],
    [
        "LOAD_GLOBAL",
        "list"
    ],
    [
        "CALL",
        "isinstance(list_, list)"
    ],
    [
        "LOAD_GLOBAL",
        "KeyError"
    ],
    [
        "CALL",
        "KeyError(\"An object other than list found behind this key\")"
    ],
    [
        "LOAD_FAST",
        "list_"
    ],
    [
        "LOAD_ATTR",
        "list_.append"
    ],
    [
        "CALL",
        "list_.append({})"
    ],
    [
        "LOAD_FAST",
        "cont"
    ],
    [
        "LOAD_FAST",
        "last_key"
    ],
    [
        "STORE_SUBSCR",
        "cont[last_key]"
    ],
    [
        "LOAD_NAME",
        "data: NestedDict"
    ],
    [
        "STORE_SUBSCR",
        "data: NestedDict"
    ],
    [
        "LOAD_NAME",
        "flags: Flags"
    ],
    [
        "STORE_SUBSCR",
        "flags: Flags"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_SUBSCR",
        "src[pos]"
    ],
    [
        "LOAD_FAST",
        "chars"
    ],
    [
        "CONTAINS_OP",
        "src[pos] in chars"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos += 1"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_SUBSCR",
        "src[pos]"
    ],
    [
        "LOAD_FAST",
        "chars"
    ],
    [
        "CONTAINS_OP",
        "src[pos] in chars"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "IndexError"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_ATTR",
        "src.index"
    ],
    [
        "LOAD_FAST",
        "expect"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "src.index(expect, pos)"
    ],
    [
        "STORE_FAST",
        "new_pos"
    ],
    [
        "LOAD_FAST",
        "error_on"
    ],
    [
        "LOAD_ATTR",
        "error_on.isdisjoint"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "new_pos"
    ],
    [
        "BINARY_SLICE",
        "src[pos:new_pos]"
    ],
    [
        "CALL",
        "error_on.isdisjoint(src[pos:new_pos])"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_SUBSCR",
        "src[pos]"
    ],
    [
        "LOAD_FAST",
        "error_on"
    ],
    [
        "CONTAINS_OP",
        "src[pos] not in error_on"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos += 1"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_SUBSCR",
        "src[pos]"
    ],
    [
        "LOAD_FAST",
        "error_on"
    ],
    [
        "CONTAINS_OP",
        "src[pos] not in error_on"
    ],
    [
        "LOAD_GLOBAL",
        "suffixed_err"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_SUBSCR",
        "src[pos]"
    ],
    [
        "BUILD_STRING",
        "f\"Found invalid character {src[pos]!r}\""
    ],
    [
        "CALL",
        "suffixed_err(src, pos, f\"Found invalid character {src[pos]!r}\")"
    ],
    [
        "LOAD_FAST",
        "new_pos"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "LOAD_GLOBAL",
        "len"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "CALL",
        "len(src)"
    ],
    [
        "STORE_FAST",
        "new_pos"
    ],
    [
        "LOAD_FAST",
        "error_on_eof"
    ],
    [
        "LOAD_GLOBAL",
        "suffixed_err"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "new_pos"
    ],
    [
        "LOAD_FAST",
        "expect"
    ],
    [
        "BUILD_STRING",
        "f\"Expected {expect!r}\""
    ],
    [
        "CALL",
        "suffixed_err(src, new_pos, f\"Expected {expect!r}\")"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_SUBSCR",
        "src[pos]"
    ],
    [
        "STORE_FAST",
        "char"
    ],
    [
        "LOAD_FAST",
        "char"
    ],
    [
        "COMPARE_OP",
        "char == \"#\""
    ],
    [
        "LOAD_GLOBAL",
        "skip_until"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos + 1"
    ],
    [
        "LOAD_GLOBAL",
        "ILLEGAL_COMMENT_CHARS"
    ],
    [
        "CALL",
        "skip_until(\n            src, pos + 1, \"\\n\", error_on=ILLEGAL_COMMENT_CHARS, error_on_eof=False\n        )"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "IndexError"
    ],
    [
        "STORE_FAST",
        "char"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "STORE_FAST",
        "pos_before_skip"
    ],
    [
        "LOAD_GLOBAL",
        "skip_chars"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "TOML_WS_AND_NEWLINE"
    ],
    [
        "CALL",
        "skip_chars(src, pos, TOML_WS_AND_NEWLINE)"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "skip_comment"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "skip_comment(src, pos)"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "pos_before_skip"
    ],
    [
        "COMPARE_OP",
        "pos == pos_before_skip"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos += 1"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "skip_chars"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "TOML_WS"
    ],
    [
        "CALL",
        "skip_chars(src, pos, TOML_WS)"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "parse_key"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "parse_key(src, pos)"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "STORE_FAST",
        "key"
    ],
    [
        "LOAD_FAST",
        "out"
    ],
    [
        "LOAD_ATTR",
        "out.flags"
    ],
    [
        "LOAD_ATTR",
        "out.flags.is_"
    ],
    [
        "LOAD_FAST",
        "key"
    ],
    [
        "LOAD_GLOBAL",
        "Flags"
    ],
    [
        "LOAD_ATTR",
        "Flags.EXPLICIT_NEST"
    ],
    [
        "CALL",
        "out.flags.is_(key, Flags.EXPLICIT_NEST)"
    ],
    [
        "LOAD_FAST",
        "out"
    ],
    [
        "LOAD_ATTR",
        "out.flags"
    ],
    [
        "LOAD_ATTR",
        "out.flags.is_"
    ],
    [
        "LOAD_FAST",
        "key"
    ],
    [
        "LOAD_GLOBAL",
        "Flags"
    ],
    [
        "LOAD_ATTR",
        "Flags.FROZEN"
    ],
    [
        "CALL",
        "out.flags.is_(key, Flags.FROZEN)"
    ],
    [
        "LOAD_GLOBAL",
        "suffixed_err"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "key"
    ],
    [
        "BUILD_STRING",
        "f\"Cannot declare {key} twice\""
    ],
    [
        "CALL",
        "suffixed_err(src, pos, f\"Cannot declare {key} twice\")"
    ],
    [
        "LOAD_FAST",
        "out"
    ],
    [
        "LOAD_ATTR",
        "out.flags"
    ],
    [
        "LOAD_ATTR",
        "out.flags.set"
    ],
    [
        "LOAD_FAST",
        "key"
    ],
    [
        "LOAD_GLOBAL",
        "Flags"
    ],
    [
        "LOAD_ATTR",
        "Flags.EXPLICIT_NEST"
    ],
    [
        "CALL",
        "out.flags.set(key, Flags.EXPLICIT_NEST, recursive=False)"
    ],
    [
        "LOAD_FAST",
        "out"
    ],
    [
        "LOAD_ATTR",
        "out.data"
    ],
    [
        "LOAD_ATTR",
        "out.data.get_or_create_nest"
    ],
    [
        "LOAD_FAST",
        "key"
    ],
    [
        "CALL",
        "out.data.get_or_create_nest(key)"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_ATTR",
        "src.startswith"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "src.startswith(\"]\", pos)"
    ],
    [
        "LOAD_GLOBAL",
        "suffixed_err"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "suffixed_err(src, pos, \"Expected ']' at the end of a table declaration\")"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos + 1"
    ],
    [
        "LOAD_FAST",
        "key"
    ],
    [
        "LOAD_GLOBAL",
        "KeyError"
    ],
    [
        "LOAD_GLOBAL",
        "suffixed_err"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "suffixed_err(src, pos, \"Cannot overwrite a value\")"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos += 2"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "skip_chars"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "TOML_WS"
    ],
    [
        "CALL",
        "skip_chars(src, pos, TOML_WS)"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "parse_key"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "parse_key(src, pos)"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "STORE_FAST",
        "key"
    ],
    [
        "LOAD_FAST",
        "out"
    ],
    [
        "LOAD_ATTR",
        "out.flags"
    ],
    [
        "LOAD_ATTR",
        "out.flags.is_"
    ],
    [
        "LOAD_FAST",
        "key"
    ],
    [
        "LOAD_GLOBAL",
        "Flags"
    ],
    [
        "LOAD_ATTR",
        "Flags.FROZEN"
    ],
    [
        "CALL",
        "out.flags.is_(key, Flags.FROZEN)"
    ],
    [
        "LOAD_GLOBAL",
        "suffixed_err"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "key"
    ],
    [
        "BUILD_STRING",
        "f\"Cannot mutate immutable namespace {key}\""
    ],
    [
        "CALL",
        "suffixed_err(src, pos, f\"Cannot mutate immutable namespace {key}\")"
    ],
    [
        "LOAD_FAST",
        "out"
    ],
    [
        "LOAD_ATTR",
        "out.flags"
    ],
    [
        "LOAD_ATTR",
        "out.flags.unset_all"
    ],
    [
        "LOAD_FAST",
        "key"
    ],
    [
        "CALL",
        "out.flags.unset_all(key)"
    ],
    [
        "LOAD_FAST",
        "out"
    ],
    [
        "LOAD_ATTR",
        "out.flags"
    ],
    [
        "LOAD_ATTR",
        "out.flags.set"
    ],
    [
        "LOAD_FAST",
        "key"
    ],
    [
        "LOAD_GLOBAL",
        "Flags"
    ],
    [
        "LOAD_ATTR",
        "Flags.EXPLICIT_NEST"
    ],
    [
        "CALL",
        "out.flags.set(key, Flags.EXPLICIT_NEST, recursive=False)"
    ],
    [
        "LOAD_FAST",
        "out"
    ],
    [
        "LOAD_ATTR",
        "out.data"
    ],
    [
        "LOAD_ATTR",
        "out.data.append_nest_to_list"
    ],
    [
        "LOAD_FAST",
        "key"
    ],
    [
        "CALL",
        "out.data.append_nest_to_list(key)"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_ATTR",
        "src.startswith"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "src.startswith(\"]]\", pos)"
    ],
    [
        "LOAD_GLOBAL",
        "suffixed_err"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "suffixed_err(src, pos, \"Expected ']]' at the end of an array declaration\")"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos + 2"
    ],
    [
        "LOAD_FAST",
        "key"
    ],
    [
        "LOAD_GLOBAL",
        "KeyError"
    ],
    [
        "LOAD_GLOBAL",
        "suffixed_err"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "suffixed_err(src, pos, \"Cannot overwrite a value\")"
    ],
    [
        "LOAD_GLOBAL",
        "parse_key_value_pair"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "parse_float"
    ],
    [
        "CALL",
        "parse_key_value_pair(src, pos, parse_float)"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "STORE_DEREF",
        "key"
    ],
    [
        "STORE_FAST",
        "value"
    ],
    [
        "LOAD_DEREF",
        "key"
    ],
    [
        "BINARY_SLICE",
        "key[:-1]"
    ],
    [
        "LOAD_DEREF",
        "key"
    ],
    [
        "BINARY_SUBSCR",
        "key[-1]"
    ],
    [
        "STORE_FAST",
        "key_stem"
    ],
    [
        "STORE_FAST",
        "key_parent"
    ],
    [
        "LOAD_DEREF",
        "header"
    ],
    [
        "LOAD_FAST",
        "key_parent"
    ],
    [
        "BINARY_OP",
        "header + key_parent"
    ],
    [
        "STORE_FAST",
        "abs_key_parent"
    ],
    [
        "LOAD_GLOBAL",
        "range"
    ],
    [
        "LOAD_GLOBAL",
        "len"
    ],
    [
        "LOAD_DEREF",
        "key"
    ],
    [
        "CALL",
        "len(key)"
    ],
    [
        "CALL",
        "range(1, len(key))"
    ],
    [
        "CALL",
        "(header + key[:i] for i in range(1, len(key)))"
    ],
    [
        "STORE_FAST",
        "relative_path_cont_keys"
    ],
    [
        "LOAD_FAST",
        "relative_path_cont_keys"
    ],
    [
        "STORE_FAST",
        "cont_key"
    ],
    [
        "LOAD_FAST",
        "out"
    ],
    [
        "LOAD_ATTR",
        "out.flags"
    ],
    [
        "LOAD_ATTR",
        "out.flags.is_"
    ],
    [
        "LOAD_FAST",
        "cont_key"
    ],
    [
        "LOAD_GLOBAL",
        "Flags"
    ],
    [
        "LOAD_ATTR",
        "Flags.EXPLICIT_NEST"
    ],
    [
        "CALL",
        "out.flags.is_(cont_key, Flags.EXPLICIT_NEST)"
    ],
    [
        "LOAD_GLOBAL",
        "suffixed_err"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "cont_key"
    ],
    [
        "BUILD_STRING",
        "f\"Cannot redefine namespace {cont_key}\""
    ],
    [
        "CALL",
        "suffixed_err(src, pos, f\"Cannot redefine namespace {cont_key}\")"
    ],
    [
        "LOAD_FAST",
        "out"
    ],
    [
        "LOAD_ATTR",
        "out.flags"
    ],
    [
        "LOAD_ATTR",
        "out.flags.add_pending"
    ],
    [
        "LOAD_FAST",
        "cont_key"
    ],
    [
        "LOAD_GLOBAL",
        "Flags"
    ],
    [
        "LOAD_ATTR",
        "Flags.EXPLICIT_NEST"
    ],
    [
        "CALL",
        "out.flags.add_pending(cont_key, Flags.EXPLICIT_NEST)"
    ],
    [
        "LOAD_FAST",
        "out"
    ],
    [
        "LOAD_ATTR",
        "out.flags"
    ],
    [
        "LOAD_ATTR",
        "out.flags.is_"
    ],
    [
        "LOAD_FAST",
        "abs_key_parent"
    ],
    [
        "LOAD_GLOBAL",
        "Flags"
    ],
    [
        "LOAD_ATTR",
        "Flags.FROZEN"
    ],
    [
        "CALL",
        "out.flags.is_(abs_key_parent, Flags.FROZEN)"
    ],
    [
        "LOAD_GLOBAL",
        "suffixed_err"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "abs_key_parent"
    ],
    [
        "BUILD_STRING",
        "f\"Cannot mutate immutable namespace {abs_key_parent}\""
    ],
    [
        "CALL",
        "suffixed_err(\n            src, pos, f\"Cannot mutate immutable namespace {abs_key_parent}\"\n        )"
    ],
    [
        "LOAD_FAST",
        "out"
    ],
    [
        "LOAD_ATTR",
        "out.data"
    ],
    [
        "LOAD_ATTR",
        "out.data.get_or_create_nest"
    ],
    [
        "LOAD_FAST",
        "abs_key_parent"
    ],
    [
        "CALL",
        "out.data.get_or_create_nest(abs_key_parent)"
    ],
    [
        "STORE_FAST",
        "nest"
    ],
    [
        "LOAD_FAST",
        "key_stem"
    ],
    [
        "LOAD_FAST",
        "nest"
    ],
    [
        "CONTAINS_OP",
        "key_stem in nest"
    ],
    [
        "LOAD_GLOBAL",
        "suffixed_err"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "suffixed_err(src, pos, \"Cannot overwrite a value\")"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "value"
    ],
    [
        "LOAD_GLOBAL",
        "dict"
    ],
    [
        "LOAD_GLOBAL",
        "list"
    ],
    [
        "CALL",
        "isinstance(value, (dict, list))"
    ],
    [
        "LOAD_FAST",
        "out"
    ],
    [
        "LOAD_ATTR",
        "out.flags"
    ],
    [
        "LOAD_ATTR",
        "out.flags.set"
    ],
    [
        "LOAD_DEREF",
        "header"
    ],
    [
        "LOAD_DEREF",
        "key"
    ],
    [
        "BINARY_OP",
        "header + key"
    ],
    [
        "LOAD_GLOBAL",
        "Flags"
    ],
    [
        "LOAD_ATTR",
        "Flags.FROZEN"
    ],
    [
        "CALL",
        "out.flags.set(header + key, Flags.FROZEN, recursive=True)"
    ],
    [
        "LOAD_FAST",
        "value"
    ],
    [
        "LOAD_FAST",
        "nest"
    ],
    [
        "LOAD_FAST",
        "key_stem"
    ],
    [
        "STORE_SUBSCR",
        "nest[key_stem]"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "KeyError"
    ],
    [
        "LOAD_GLOBAL",
        "suffixed_err"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "suffixed_err(src, pos, \"Cannot overwrite a value\")"
    ],
    [
        "LOAD_FAST",
        "(header + key[:i] for i in range(1, len(key)))"
    ],
    [
        "STORE_FAST",
        "i"
    ],
    [
        "LOAD_DEREF",
        "header"
    ],
    [
        "LOAD_DEREF",
        "key"
    ],
    [
        "LOAD_FAST",
        "i"
    ],
    [
        "BINARY_SLICE",
        "key[:i]"
    ],
    [
        "BINARY_OP",
        "header + key[:i]"
    ],
    [
        "LOAD_GLOBAL",
        "parse_key"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "parse_key(src, pos)"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "STORE_FAST",
        "key"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_SUBSCR",
        "src[pos]"
    ],
    [
        "STORE_FAST",
        "char"
    ],
    [
        "LOAD_FAST",
        "char"
    ],
    [
        "COMPARE_OP",
        "char != \"=\""
    ],
    [
        "LOAD_GLOBAL",
        "suffixed_err"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "suffixed_err(src, pos, \"Expected '=' after a key in a key/value pair\")"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos += 1"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "skip_chars"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "TOML_WS"
    ],
    [
        "CALL",
        "skip_chars(src, pos, TOML_WS)"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "parse_value"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "parse_float"
    ],
    [
        "CALL",
        "parse_value(src, pos, parse_float)"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "STORE_FAST",
        "value"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "key"
    ],
    [
        "LOAD_FAST",
        "value"
    ],
    [
        "LOAD_GLOBAL",
        "IndexError"
    ],
    [
        "STORE_FAST",
        "char"
    ],
    [
        "LOAD_GLOBAL",
        "parse_key_part"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "parse_key_part(src, pos)"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "STORE_FAST",
        "key_part"
    ],
    [
        "LOAD_FAST",
        "key_part"
    ],
    [
        "STORE_FAST",
        "key"
    ],
    [
        "LOAD_GLOBAL",
        "skip_chars"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "TOML_WS"
    ],
    [
        "CALL",
        "skip_chars(src, pos, TOML_WS)"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_SUBSCR",
        "src[pos]"
    ],
    [
        "STORE_FAST",
        "char"
    ],
    [
        "LOAD_FAST",
        "char"
    ],
    [
        "COMPARE_OP",
        "char != \".\""
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "key"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos += 1"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "skip_chars"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "TOML_WS"
    ],
    [
        "CALL",
        "skip_chars(src, pos, TOML_WS)"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "parse_key_part"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "parse_key_part(src, pos)"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "STORE_FAST",
        "key_part"
    ],
    [
        "LOAD_FAST",
        "key"
    ],
    [
        "LOAD_FAST",
        "key_part"
    ],
    [
        "BINARY_OP",
        "key += (key_part,)"
    ],
    [
        "STORE_FAST",
        "key"
    ],
    [
        "LOAD_GLOBAL",
        "skip_chars"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "TOML_WS"
    ],
    [
        "CALL",
        "skip_chars(src, pos, TOML_WS)"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "IndexError"
    ],
    [
        "STORE_FAST",
        "char"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_SUBSCR",
        "src[pos]"
    ],
    [
        "STORE_FAST",
        "char"
    ],
    [
        "LOAD_FAST",
        "char"
    ],
    [
        "LOAD_GLOBAL",
        "BARE_KEY_CHARS"
    ],
    [
        "CONTAINS_OP",
        "char in BARE_KEY_CHARS"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "STORE_FAST",
        "start_pos"
    ],
    [
        "LOAD_GLOBAL",
        "skip_chars"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "BARE_KEY_CHARS"
    ],
    [
        "CALL",
        "skip_chars(src, pos, BARE_KEY_CHARS)"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "start_pos"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_SLICE",
        "src[start_pos:pos]"
    ],
    [
        "LOAD_FAST",
        "char"
    ],
    [
        "COMPARE_OP",
        "char == \"'\""
    ],
    [
        "LOAD_GLOBAL",
        "parse_literal_str"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "parse_literal_str(src, pos)"
    ],
    [
        "LOAD_FAST",
        "char"
    ],
    [
        "COMPARE_OP",
        "char == '\"'"
    ],
    [
        "LOAD_GLOBAL",
        "parse_one_line_basic_str"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "parse_one_line_basic_str(src, pos)"
    ],
    [
        "LOAD_GLOBAL",
        "suffixed_err"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "suffixed_err(src, pos, \"Invalid initial character for a key part\")"
    ],
    [
        "LOAD_GLOBAL",
        "IndexError"
    ],
    [
        "STORE_FAST",
        "char"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos += 1"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "parse_basic_str"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "parse_basic_str(src, pos, multiline=False)"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos += 1"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "STORE_FAST",
        "array"
    ],
    [
        "LOAD_GLOBAL",
        "skip_comments_and_array_ws"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "skip_comments_and_array_ws(src, pos)"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_ATTR",
        "src.startswith"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "src.startswith(\"]\", pos)"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos + 1"
    ],
    [
        "LOAD_FAST",
        "array"
    ],
    [
        "LOAD_GLOBAL",
        "parse_value"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "parse_float"
    ],
    [
        "CALL",
        "parse_value(src, pos, parse_float)"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "STORE_FAST",
        "val"
    ],
    [
        "LOAD_FAST",
        "array"
    ],
    [
        "LOAD_ATTR",
        "array.append"
    ],
    [
        "LOAD_FAST",
        "val"
    ],
    [
        "CALL",
        "array.append(val)"
    ],
    [
        "LOAD_GLOBAL",
        "skip_comments_and_array_ws"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "skip_comments_and_array_ws(src, pos)"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos + 1"
    ],
    [
        "BINARY_SLICE",
        "src[pos : pos + 1]"
    ],
    [
        "STORE_FAST",
        "c"
    ],
    [
        "LOAD_FAST",
        "c"
    ],
    [
        "COMPARE_OP",
        "c == \"]\""
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos + 1"
    ],
    [
        "LOAD_FAST",
        "array"
    ],
    [
        "LOAD_FAST",
        "c"
    ],
    [
        "COMPARE_OP",
        "c != \",\""
    ],
    [
        "LOAD_GLOBAL",
        "suffixed_err"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "suffixed_err(src, pos, \"Unclosed array\")"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos += 1"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "skip_comments_and_array_ws"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "skip_comments_and_array_ws(src, pos)"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_ATTR",
        "src.startswith"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "src.startswith(\"]\", pos)"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos + 1"
    ],
    [
        "LOAD_FAST",
        "array"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos += 1"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "NestedDict"
    ],
    [
        "CALL",
        "NestedDict()"
    ],
    [
        "STORE_FAST",
        "nested_dict"
    ],
    [
        "LOAD_GLOBAL",
        "Flags"
    ],
    [
        "CALL",
        "Flags()"
    ],
    [
        "STORE_FAST",
        "flags"
    ],
    [
        "LOAD_GLOBAL",
        "skip_chars"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "TOML_WS"
    ],
    [
        "CALL",
        "skip_chars(src, pos, TOML_WS)"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_ATTR",
        "src.startswith"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "src.startswith(\"}\", pos)"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos + 1"
    ],
    [
        "LOAD_FAST",
        "nested_dict"
    ],
    [
        "LOAD_ATTR",
        "nested_dict.dict"
    ],
    [
        "LOAD_GLOBAL",
        "parse_key_value_pair"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "parse_float"
    ],
    [
        "CALL",
        "parse_key_value_pair(src, pos, parse_float)"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "STORE_FAST",
        "key"
    ],
    [
        "STORE_FAST",
        "value"
    ],
    [
        "LOAD_FAST",
        "key"
    ],
    [
        "BINARY_SLICE",
        "key[:-1]"
    ],
    [
        "LOAD_FAST",
        "key"
    ],
    [
        "BINARY_SUBSCR",
        "key[-1]"
    ],
    [
        "STORE_FAST",
        "key_stem"
    ],
    [
        "STORE_FAST",
        "key_parent"
    ],
    [
        "LOAD_FAST",
        "flags"
    ],
    [
        "LOAD_ATTR",
        "flags.is_"
    ],
    [
        "LOAD_FAST",
        "key"
    ],
    [
        "LOAD_GLOBAL",
        "Flags"
    ],
    [
        "LOAD_ATTR",
        "Flags.FROZEN"
    ],
    [
        "CALL",
        "flags.is_(key, Flags.FROZEN)"
    ],
    [
        "LOAD_GLOBAL",
        "suffixed_err"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "key"
    ],
    [
        "BUILD_STRING",
        "f\"Cannot mutate immutable namespace {key}\""
    ],
    [
        "CALL",
        "suffixed_err(src, pos, f\"Cannot mutate immutable namespace {key}\")"
    ],
    [
        "LOAD_FAST",
        "nested_dict"
    ],
    [
        "LOAD_ATTR",
        "nested_dict.get_or_create_nest"
    ],
    [
        "LOAD_FAST",
        "key_parent"
    ],
    [
        "CALL",
        "nested_dict.get_or_create_nest(key_parent, access_lists=False)"
    ],
    [
        "STORE_FAST",
        "nest"
    ],
    [
        "LOAD_FAST",
        "key_stem"
    ],
    [
        "LOAD_FAST",
        "nest"
    ],
    [
        "CONTAINS_OP",
        "key_stem in nest"
    ],
    [
        "LOAD_GLOBAL",
        "suffixed_err"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "key_stem"
    ],
    [
        "BUILD_STRING",
        "f\"Duplicate inline table key {key_stem!r}\""
    ],
    [
        "CALL",
        "suffixed_err(src, pos, f\"Duplicate inline table key {key_stem!r}\")"
    ],
    [
        "LOAD_FAST",
        "value"
    ],
    [
        "LOAD_FAST",
        "nest"
    ],
    [
        "LOAD_FAST",
        "key_stem"
    ],
    [
        "STORE_SUBSCR",
        "nest[key_stem]"
    ],
    [
        "LOAD_GLOBAL",
        "skip_chars"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "TOML_WS"
    ],
    [
        "CALL",
        "skip_chars(src, pos, TOML_WS)"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos + 1"
    ],
    [
        "BINARY_SLICE",
        "src[pos : pos + 1]"
    ],
    [
        "STORE_FAST",
        "c"
    ],
    [
        "LOAD_FAST",
        "c"
    ],
    [
        "COMPARE_OP",
        "c == \"}\""
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos + 1"
    ],
    [
        "LOAD_FAST",
        "nested_dict"
    ],
    [
        "LOAD_ATTR",
        "nested_dict.dict"
    ],
    [
        "LOAD_FAST",
        "c"
    ],
    [
        "COMPARE_OP",
        "c != \",\""
    ],
    [
        "LOAD_GLOBAL",
        "suffixed_err"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "suffixed_err(src, pos, \"Unclosed inline table\")"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "value"
    ],
    [
        "LOAD_GLOBAL",
        "dict"
    ],
    [
        "LOAD_GLOBAL",
        "list"
    ],
    [
        "CALL",
        "isinstance(value, (dict, list))"
    ],
    [
        "LOAD_FAST",
        "flags"
    ],
    [
        "LOAD_ATTR",
        "flags.set"
    ],
    [
        "LOAD_FAST",
        "key"
    ],
    [
        "LOAD_GLOBAL",
        "Flags"
    ],
    [
        "LOAD_ATTR",
        "Flags.FROZEN"
    ],
    [
        "CALL",
        "flags.set(key, Flags.FROZEN, recursive=True)"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos += 1"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "skip_chars"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "TOML_WS"
    ],
    [
        "CALL",
        "skip_chars(src, pos, TOML_WS)"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "KeyError"
    ],
    [
        "LOAD_GLOBAL",
        "suffixed_err"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "suffixed_err(src, pos, \"Cannot overwrite a value\")"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos + 2"
    ],
    [
        "BINARY_SLICE",
        "src[pos : pos + 2]"
    ],
    [
        "STORE_FAST",
        "escape_id"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos += 2"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "multiline"
    ],
    [
        "LOAD_FAST",
        "escape_id"
    ],
    [
        "CONTAINS_OP",
        "escape_id in {\"\\\\ \", \"\\\\\\t\", \"\\\\\\n\"}"
    ],
    [
        "LOAD_FAST",
        "escape_id"
    ],
    [
        "COMPARE_OP",
        "escape_id != \"\\\\\\n\""
    ],
    [
        "LOAD_GLOBAL",
        "skip_chars"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "TOML_WS"
    ],
    [
        "CALL",
        "skip_chars(src, pos, TOML_WS)"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_SUBSCR",
        "src[pos]"
    ],
    [
        "STORE_FAST",
        "char"
    ],
    [
        "LOAD_FAST",
        "char"
    ],
    [
        "COMPARE_OP",
        "char != \"\\n\""
    ],
    [
        "LOAD_GLOBAL",
        "suffixed_err"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "suffixed_err(src, pos, \"Unescaped '\\\\' in a string\")"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos += 1"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "skip_chars"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "TOML_WS_AND_NEWLINE"
    ],
    [
        "CALL",
        "skip_chars(src, pos, TOML_WS_AND_NEWLINE)"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "escape_id"
    ],
    [
        "COMPARE_OP",
        "escape_id == \"\\\\u\""
    ],
    [
        "LOAD_GLOBAL",
        "parse_hex_char"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "parse_hex_char(src, pos, 4)"
    ],
    [
        "LOAD_FAST",
        "escape_id"
    ],
    [
        "COMPARE_OP",
        "escape_id == \"\\\\U\""
    ],
    [
        "LOAD_GLOBAL",
        "parse_hex_char"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "parse_hex_char(src, pos, 8)"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "BASIC_STR_ESCAPE_REPLACEMENTS"
    ],
    [
        "LOAD_FAST",
        "escape_id"
    ],
    [
        "BINARY_SUBSCR",
        "BASIC_STR_ESCAPE_REPLACEMENTS[escape_id]"
    ],
    [
        "LOAD_GLOBAL",
        "IndexError"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "KeyError"
    ],
    [
        "LOAD_GLOBAL",
        "suffixed_err"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "suffixed_err(src, pos, \"Unescaped '\\\\' in a string\")"
    ],
    [
        "LOAD_GLOBAL",
        "parse_basic_str_escape"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "parse_basic_str_escape(src, pos, multiline=True)"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "hex_len"
    ],
    [
        "BINARY_OP",
        "pos + hex_len"
    ],
    [
        "BINARY_SLICE",
        "src[pos : pos + hex_len]"
    ],
    [
        "STORE_FAST",
        "hex_str"
    ],
    [
        "LOAD_GLOBAL",
        "len"
    ],
    [
        "LOAD_FAST",
        "hex_str"
    ],
    [
        "CALL",
        "len(hex_str)"
    ],
    [
        "LOAD_FAST",
        "hex_len"
    ],
    [
        "COMPARE_OP",
        "len(hex_str) != hex_len"
    ],
    [
        "LOAD_GLOBAL",
        "HEXDIGIT_CHARS"
    ],
    [
        "LOAD_ATTR",
        "HEXDIGIT_CHARS.issuperset"
    ],
    [
        "LOAD_FAST",
        "hex_str"
    ],
    [
        "CALL",
        "HEXDIGIT_CHARS.issuperset(hex_str)"
    ],
    [
        "LOAD_GLOBAL",
        "suffixed_err"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "suffixed_err(src, pos, \"Invalid hex value\")"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "hex_len"
    ],
    [
        "BINARY_OP",
        "pos += hex_len"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "int"
    ],
    [
        "LOAD_FAST",
        "hex_str"
    ],
    [
        "CALL",
        "int(hex_str, 16)"
    ],
    [
        "STORE_FAST",
        "hex_int"
    ],
    [
        "LOAD_GLOBAL",
        "is_unicode_scalar_value"
    ],
    [
        "LOAD_FAST",
        "hex_int"
    ],
    [
        "CALL",
        "is_unicode_scalar_value(hex_int)"
    ],
    [
        "LOAD_GLOBAL",
        "suffixed_err"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "suffixed_err(src, pos, \"Escaped character is not a Unicode scalar value\")"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "chr"
    ],
    [
        "LOAD_FAST",
        "hex_int"
    ],
    [
        "CALL",
        "chr(hex_int)"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos += 1"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "STORE_FAST",
        "start_pos"
    ],
    [
        "LOAD_GLOBAL",
        "skip_until"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "ILLEGAL_LITERAL_STR_CHARS"
    ],
    [
        "CALL",
        "skip_until(\n        src, pos, \"'\", error_on=ILLEGAL_LITERAL_STR_CHARS, error_on_eof=True\n    )"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos + 1"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "start_pos"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_SLICE",
        "src[start_pos:pos]"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos += 3"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_ATTR",
        "src.startswith"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "src.startswith(\"\\n\", pos)"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos += 1"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "literal"
    ],
    [
        "STORE_FAST",
        "delim"
    ],
    [
        "LOAD_GLOBAL",
        "skip_until"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "ILLEGAL_MULTILINE_LITERAL_STR_CHARS"
    ],
    [
        "CALL",
        "skip_until(\n            src,\n            pos,\n            \"'''\",\n            error_on=ILLEGAL_MULTILINE_LITERAL_STR_CHARS,\n            error_on_eof=True,\n        )"
    ],
    [
        "STORE_FAST",
        "end_pos"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "end_pos"
    ],
    [
        "BINARY_SLICE",
        "src[pos:end_pos]"
    ],
    [
        "STORE_FAST",
        "result"
    ],
    [
        "LOAD_FAST",
        "end_pos"
    ],
    [
        "BINARY_OP",
        "end_pos + 3"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "STORE_FAST",
        "delim"
    ],
    [
        "LOAD_GLOBAL",
        "parse_basic_str"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "parse_basic_str(src, pos, multiline=True)"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "STORE_FAST",
        "result"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_ATTR",
        "src.startswith"
    ],
    [
        "LOAD_FAST",
        "delim"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "src.startswith(delim, pos)"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "result"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos += 1"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_ATTR",
        "src.startswith"
    ],
    [
        "LOAD_FAST",
        "delim"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "src.startswith(delim, pos)"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "result"
    ],
    [
        "LOAD_FAST",
        "delim"
    ],
    [
        "BINARY_OP",
        "result + delim"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos += 1"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "result"
    ],
    [
        "LOAD_FAST",
        "delim"
    ],
    [
        "BINARY_OP",
        "delim * 2"
    ],
    [
        "BINARY_OP",
        "result + (delim * 2)"
    ],
    [
        "LOAD_FAST",
        "multiline"
    ],
    [
        "LOAD_GLOBAL",
        "ILLEGAL_MULTILINE_BASIC_STR_CHARS"
    ],
    [
        "STORE_FAST",
        "error_on"
    ],
    [
        "LOAD_GLOBAL",
        "parse_basic_str_escape_multiline"
    ],
    [
        "STORE_FAST",
        "parse_escapes"
    ],
    [
        "LOAD_GLOBAL",
        "ILLEGAL_BASIC_STR_CHARS"
    ],
    [
        "STORE_FAST",
        "error_on"
    ],
    [
        "LOAD_GLOBAL",
        "parse_basic_str_escape"
    ],
    [
        "STORE_FAST",
        "parse_escapes"
    ],
    [
        "STORE_FAST",
        "result"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "STORE_FAST",
        "start_pos"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_SUBSCR",
        "src[pos]"
    ],
    [
        "STORE_FAST",
        "char"
    ],
    [
        "LOAD_FAST",
        "char"
    ],
    [
        "COMPARE_OP",
        "char == '\"'"
    ],
    [
        "LOAD_FAST",
        "multiline"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos + 1"
    ],
    [
        "LOAD_FAST",
        "result"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "start_pos"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_SLICE",
        "src[start_pos:pos]"
    ],
    [
        "BINARY_OP",
        "result + src[start_pos:pos]"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_ATTR",
        "src.startswith"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "src.startswith('\"\"\"', pos)"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos + 3"
    ],
    [
        "LOAD_FAST",
        "result"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "start_pos"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_SLICE",
        "src[start_pos:pos]"
    ],
    [
        "BINARY_OP",
        "result + src[start_pos:pos]"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos += 1"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "char"
    ],
    [
        "COMPARE_OP",
        "char == \"\\\\\""
    ],
    [
        "LOAD_FAST",
        "result"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "start_pos"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_SLICE",
        "src[start_pos:pos]"
    ],
    [
        "BINARY_OP",
        "result += src[start_pos:pos]"
    ],
    [
        "STORE_FAST",
        "result"
    ],
    [
        "LOAD_FAST",
        "parse_escapes"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "parse_escapes(src, pos)"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "STORE_FAST",
        "parsed_escape"
    ],
    [
        "LOAD_FAST",
        "result"
    ],
    [
        "LOAD_FAST",
        "parsed_escape"
    ],
    [
        "BINARY_OP",
        "result += parsed_escape"
    ],
    [
        "STORE_FAST",
        "result"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "STORE_FAST",
        "start_pos"
    ],
    [
        "LOAD_FAST",
        "char"
    ],
    [
        "LOAD_FAST",
        "error_on"
    ],
    [
        "CONTAINS_OP",
        "char in error_on"
    ],
    [
        "LOAD_GLOBAL",
        "suffixed_err"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "char"
    ],
    [
        "BUILD_STRING",
        "f\"Illegal character {char!r}\""
    ],
    [
        "CALL",
        "suffixed_err(src, pos, f\"Illegal character {char!r}\")"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos += 1"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "IndexError"
    ],
    [
        "LOAD_GLOBAL",
        "suffixed_err"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "suffixed_err(src, pos, \"Unterminated string\")"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_SUBSCR",
        "src[pos]"
    ],
    [
        "STORE_FAST",
        "char"
    ],
    [
        "LOAD_FAST",
        "char"
    ],
    [
        "COMPARE_OP",
        "char == '\"'"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_ATTR",
        "src.startswith"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "src.startswith('\"\"\"', pos)"
    ],
    [
        "LOAD_GLOBAL",
        "parse_multiline_str"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "parse_multiline_str(src, pos, literal=False)"
    ],
    [
        "LOAD_GLOBAL",
        "parse_one_line_basic_str"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "parse_one_line_basic_str(src, pos)"
    ],
    [
        "LOAD_FAST",
        "char"
    ],
    [
        "COMPARE_OP",
        "char == \"'\""
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_ATTR",
        "src.startswith"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "src.startswith(\"'''\", pos)"
    ],
    [
        "LOAD_GLOBAL",
        "parse_multiline_str"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "parse_multiline_str(src, pos, literal=True)"
    ],
    [
        "LOAD_GLOBAL",
        "parse_literal_str"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "parse_literal_str(src, pos)"
    ],
    [
        "LOAD_FAST",
        "char"
    ],
    [
        "COMPARE_OP",
        "char == \"t\""
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_ATTR",
        "src.startswith"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "src.startswith(\"true\", pos)"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos + 4"
    ],
    [
        "LOAD_FAST",
        "char"
    ],
    [
        "COMPARE_OP",
        "char == \"f\""
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_ATTR",
        "src.startswith"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "src.startswith(\"false\", pos)"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos + 5"
    ],
    [
        "LOAD_FAST",
        "char"
    ],
    [
        "COMPARE_OP",
        "char == \"[\""
    ],
    [
        "LOAD_GLOBAL",
        "parse_array"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "parse_float"
    ],
    [
        "CALL",
        "parse_array(src, pos, parse_float)"
    ],
    [
        "LOAD_FAST",
        "char"
    ],
    [
        "COMPARE_OP",
        "char == \"{\""
    ],
    [
        "LOAD_GLOBAL",
        "parse_inline_table"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "parse_float"
    ],
    [
        "CALL",
        "parse_inline_table(src, pos, parse_float)"
    ],
    [
        "LOAD_GLOBAL",
        "RE_DATETIME"
    ],
    [
        "LOAD_ATTR",
        "RE_DATETIME.match"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "RE_DATETIME.match(src, pos)"
    ],
    [
        "STORE_FAST",
        "datetime_match"
    ],
    [
        "LOAD_FAST",
        "datetime_match"
    ],
    [
        "LOAD_GLOBAL",
        "match_to_datetime"
    ],
    [
        "LOAD_FAST",
        "datetime_match"
    ],
    [
        "CALL",
        "match_to_datetime(datetime_match)"
    ],
    [
        "STORE_FAST",
        "datetime_obj"
    ],
    [
        "LOAD_FAST",
        "datetime_match"
    ],
    [
        "LOAD_ATTR",
        "datetime_match.end"
    ],
    [
        "CALL",
        "datetime_match.end()"
    ],
    [
        "LOAD_FAST",
        "datetime_obj"
    ],
    [
        "LOAD_GLOBAL",
        "RE_LOCALTIME"
    ],
    [
        "LOAD_ATTR",
        "RE_LOCALTIME.match"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "RE_LOCALTIME.match(src, pos)"
    ],
    [
        "STORE_FAST",
        "localtime_match"
    ],
    [
        "LOAD_FAST",
        "localtime_match"
    ],
    [
        "LOAD_FAST",
        "localtime_match"
    ],
    [
        "LOAD_ATTR",
        "localtime_match.end"
    ],
    [
        "CALL",
        "localtime_match.end()"
    ],
    [
        "LOAD_GLOBAL",
        "match_to_localtime"
    ],
    [
        "LOAD_FAST",
        "localtime_match"
    ],
    [
        "CALL",
        "match_to_localtime(localtime_match)"
    ],
    [
        "LOAD_GLOBAL",
        "RE_NUMBER"
    ],
    [
        "LOAD_ATTR",
        "RE_NUMBER.match"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "RE_NUMBER.match(src, pos)"
    ],
    [
        "STORE_FAST",
        "number_match"
    ],
    [
        "LOAD_FAST",
        "number_match"
    ],
    [
        "LOAD_FAST",
        "number_match"
    ],
    [
        "LOAD_ATTR",
        "number_match.end"
    ],
    [
        "CALL",
        "number_match.end()"
    ],
    [
        "LOAD_GLOBAL",
        "match_to_number"
    ],
    [
        "LOAD_FAST",
        "number_match"
    ],
    [
        "LOAD_FAST",
        "parse_float"
    ],
    [
        "CALL",
        "match_to_number(number_match, parse_float)"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos + 3"
    ],
    [
        "BINARY_SLICE",
        "src[pos : pos + 3]"
    ],
    [
        "STORE_FAST",
        "first_three"
    ],
    [
        "LOAD_FAST",
        "first_three"
    ],
    [
        "CONTAINS_OP",
        "first_three in {\"inf\", \"nan\"}"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos + 3"
    ],
    [
        "LOAD_FAST",
        "parse_float"
    ],
    [
        "LOAD_FAST",
        "first_three"
    ],
    [
        "CALL",
        "parse_float(first_three)"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos + 4"
    ],
    [
        "BINARY_SLICE",
        "src[pos : pos + 4]"
    ],
    [
        "STORE_FAST",
        "first_four"
    ],
    [
        "LOAD_FAST",
        "first_four"
    ],
    [
        "CONTAINS_OP",
        "first_four in {\"-inf\", \"+inf\", \"-nan\", \"+nan\"}"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos + 4"
    ],
    [
        "LOAD_FAST",
        "parse_float"
    ],
    [
        "LOAD_FAST",
        "first_four"
    ],
    [
        "CALL",
        "parse_float(first_four)"
    ],
    [
        "LOAD_GLOBAL",
        "suffixed_err"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "suffixed_err(src, pos, \"Invalid value\")"
    ],
    [
        "LOAD_GLOBAL",
        "IndexError"
    ],
    [
        "STORE_FAST",
        "char"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "STORE_FAST",
        "        except ValueError as e:\n            raise suffixed_err(src, pos, \"Invalid date or datetime\") from e"
    ],
    [
        "LOAD_GLOBAL",
        "suffixed_err"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "suffixed_err(src, pos, \"Invalid date or datetime\")"
    ],
    [
        "LOAD_FAST",
        "e"
    ],
    [
        "STORE_FAST",
        "    def coord_repr(src: str, pos: Pos) -> str:\n        if pos >= len(src):\n            return \"end of document\"\n        line = src.count(\"\\n\", 0, pos) + 1\n        if line == 1:\n            column = pos + 1\n        else:\n            column = pos - src.rindex(\"\\n\", 0, pos)\n        return f\"line {line}, column {column}\""
    ],
    [
        "LOAD_GLOBAL",
        "TOMLDecodeError"
    ],
    [
        "LOAD_FAST",
        "msg"
    ],
    [
        "LOAD_FAST",
        "coord_repr"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "coord_repr(src, pos)"
    ],
    [
        "BUILD_STRING",
        "f\"{msg} (at {coord_repr(src, pos)})\""
    ],
    [
        "CALL",
        "TOMLDecodeError(f\"{msg} (at {coord_repr(src, pos)})\")"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "len"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "CALL",
        "len(src)"
    ],
    [
        "COMPARE_OP",
        "pos >= len(src)"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_ATTR",
        "src.count"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "src.count(\"\\n\", 0, pos)"
    ],
    [
        "BINARY_OP",
        "src.count(\"\\n\", 0, pos) + 1"
    ],
    [
        "STORE_FAST",
        "line"
    ],
    [
        "LOAD_FAST",
        "line"
    ],
    [
        "COMPARE_OP",
        "line == 1"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos + 1"
    ],
    [
        "STORE_FAST",
        "column"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "src"
    ],
    [
        "LOAD_ATTR",
        "src.rindex"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "CALL",
        "src.rindex(\"\\n\", 0, pos)"
    ],
    [
        "BINARY_OP",
        "pos - src.rindex(\"\\n\", 0, pos)"
    ],
    [
        "STORE_FAST",
        "column"
    ],
    [
        "LOAD_FAST",
        "line"
    ],
    [
        "LOAD_FAST",
        "column"
    ],
    [
        "BUILD_STRING",
        "f\"line {line}, column {column}\""
    ],
    [
        "LOAD_FAST",
        "codepoint"
    ],
    [
        "COMPARE_OP",
        "0 <= codepoint <= 55295"
    ],
    [
        "COMPARE_OP",
        "0 <= codepoint <= 55295"
    ],
    [
        "LOAD_FAST",
        "codepoint"
    ],
    [
        "COMPARE_OP",
        "57344 <= codepoint <= 1114111"
    ],
    [
        "COMPARE_OP",
        "57344 <= codepoint <= 1114111"
    ],
    [
        "LOAD_DEREF",
        "parse_float"
    ],
    [
        "LOAD_GLOBAL",
        "float"
    ],
    [
        "IS_OP",
        "parse_float is float"
    ],
    [
        "LOAD_GLOBAL",
        "float"
    ],
    [
        "STORE_FAST",
        "    def safe_parse_float(float_str: str) -> Any:\n        float_value = parse_float(float_str)\n        if isinstance(float_value, (dict, list)):\n            raise ValueError(\"parse_float must not return dicts or lists\")\n        return float_value"
    ],
    [
        "LOAD_FAST",
        "safe_parse_float"
    ],
    [
        "LOAD_DEREF",
        "parse_float"
    ],
    [
        "LOAD_FAST",
        "float_str"
    ],
    [
        "CALL",
        "parse_float(float_str)"
    ],
    [
        "STORE_FAST",
        "float_value"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "float_value"
    ],
    [
        "LOAD_GLOBAL",
        "dict"
    ],
    [
        "LOAD_GLOBAL",
        "list"
    ],
    [
        "CALL",
        "isinstance(float_value, (dict, list))"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "CALL",
        "ValueError(\"parse_float must not return dicts or lists\")"
    ],
    [
        "LOAD_FAST",
        "float_value"
    ]
]