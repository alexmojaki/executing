[
    [
        "STORE_NAME",
        "\"\"\"Concrete date/time and related types.\n\nSee http://www.iana.org/time-zones/repository/tz-link.html for\ntime zone and DST data sources.\n\"\"\""
    ],
    [
        "STORE_NAME",
        "__all__"
    ],
    [
        "STORE_NAME",
        "import time as _time"
    ],
    [
        "STORE_NAME",
        "import math as _math"
    ],
    [
        "STORE_NAME",
        "import sys"
    ],
    [
        "STORE_NAME",
        "from operator import index as _index"
    ],
    [
        "STORE_NAME",
        "def _cmp(x, y):\n    return 0 if x == y else 1 if x > y else -1"
    ],
    [
        "STORE_NAME",
        "MINYEAR"
    ],
    [
        "STORE_NAME",
        "MAXYEAR"
    ],
    [
        "STORE_NAME",
        "_MAXORDINAL"
    ],
    [
        "STORE_NAME",
        "_DAYS_IN_MONTH"
    ],
    [
        "STORE_NAME",
        "_DAYS_BEFORE_MONTH"
    ],
    [
        "STORE_NAME",
        "dbm"
    ],
    [
        "LOAD_NAME",
        "_DAYS_IN_MONTH"
    ],
    [
        "BINARY_SLICE",
        "_DAYS_IN_MONTH[1:]"
    ],
    [
        "STORE_NAME",
        "dim"
    ],
    [
        "LOAD_NAME",
        "_DAYS_BEFORE_MONTH"
    ],
    [
        "LOAD_ATTR",
        "_DAYS_BEFORE_MONTH.append"
    ],
    [
        "LOAD_NAME",
        "dbm"
    ],
    [
        "CALL",
        "_DAYS_BEFORE_MONTH.append(dbm)"
    ],
    [
        "LOAD_NAME",
        "dbm"
    ],
    [
        "LOAD_NAME",
        "dim"
    ],
    [
        "BINARY_OP",
        "dbm += dim"
    ],
    [
        "STORE_NAME",
        "dbm"
    ],
    [
        "DELETE_NAME",
        "dbm"
    ],
    [
        "DELETE_NAME",
        "dim"
    ],
    [
        "STORE_NAME",
        "def _is_leap(year):\n    \"year -> 1 if leap year, else 0.\"\n    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)"
    ],
    [
        "STORE_NAME",
        "def _days_before_year(year):\n    \"year -> number of days before January 1st of year.\"\n    y = year - 1\n    return y*365 + y//4 - y//100 + y//400"
    ],
    [
        "STORE_NAME",
        "def _days_in_month(year, month):\n    \"year, month -> number of days in that month in that year.\"\n    assert 1 <= month <= 12, month\n    if month == 2 and _is_leap(year):\n        return 29\n    return _DAYS_IN_MONTH[month]"
    ],
    [
        "STORE_NAME",
        "def _days_before_month(year, month):\n    \"year, month -> number of days in year preceding first day of month.\"\n    assert 1 <= month <= 12, 'month must be in 1..12'\n    return _DAYS_BEFORE_MONTH[month] + (month > 2 and _is_leap(year))"
    ],
    [
        "STORE_NAME",
        "def _ymd2ord(year, month, day):\n    \"year, month, day -> ordinal, considering 01-Jan-0001 as day 1.\"\n    assert 1 <= month <= 12, 'month must be in 1..12'\n    dim = _days_in_month(year, month)\n    assert 1 <= day <= dim, ('day must be in 1..%d' % dim)\n    return (_days_before_year(year) +\n            _days_before_month(year, month) +\n            day)"
    ],
    [
        "LOAD_NAME",
        "_days_before_year"
    ],
    [
        "CALL",
        "_days_before_year(401)"
    ],
    [
        "STORE_NAME",
        "_DI400Y"
    ],
    [
        "LOAD_NAME",
        "_days_before_year"
    ],
    [
        "CALL",
        "_days_before_year(101)"
    ],
    [
        "STORE_NAME",
        "_DI100Y"
    ],
    [
        "LOAD_NAME",
        "_days_before_year"
    ],
    [
        "CALL",
        "_days_before_year(5)"
    ],
    [
        "STORE_NAME",
        "_DI4Y"
    ],
    [
        "LOAD_NAME",
        "_DI4Y"
    ],
    [
        "COMPARE_OP",
        "_DI4Y == 4 * 365 + 1"
    ],
    [
        "LOAD_NAME",
        "_DI400Y"
    ],
    [
        "LOAD_NAME",
        "_DI100Y"
    ],
    [
        "BINARY_OP",
        "4 * _DI100Y"
    ],
    [
        "BINARY_OP",
        "4 * _DI100Y + 1"
    ],
    [
        "COMPARE_OP",
        "_DI400Y == 4 * _DI100Y + 1"
    ],
    [
        "LOAD_NAME",
        "_DI100Y"
    ],
    [
        "LOAD_NAME",
        "_DI4Y"
    ],
    [
        "BINARY_OP",
        "25 * _DI4Y"
    ],
    [
        "BINARY_OP",
        "25 * _DI4Y - 1"
    ],
    [
        "COMPARE_OP",
        "_DI100Y == 25 * _DI4Y - 1"
    ],
    [
        "STORE_NAME",
        "def _ord2ymd(n):\n    \"ordinal -> (year, month, day), considering 01-Jan-0001 as day 1.\"\n\n    # n is a 1-based index, starting at 1-Jan-1.  The pattern of leap years\n    # repeats exactly every 400 years.  The basic strategy is to find the\n    # closest 400-year boundary at or before n, then work with the offset\n    # from that boundary to n.  Life is much clearer if we subtract 1 from\n    # n first -- then the values of n at 400-year boundaries are exactly\n    # those divisible by _DI400Y:\n    #\n    #     D  M   Y            n              n-1\n    #     -- --- ----        ----------     ----------------\n    #     31 Dec -400        -_DI400Y       -_DI400Y -1\n    #      1 Jan -399         -_DI400Y +1   -_DI400Y      400-year boundary\n    #     ...\n    #     30 Dec  000        -1             -2\n    #     31 Dec  000         0             -1\n    #      1 Jan  001         1              0            400-year boundary\n    #      2 Jan  001         2              1\n    #      3 Jan  001         3              2\n    #     ...\n    #     31 Dec  400         _DI400Y        _DI400Y -1\n    #      1 Jan  401         _DI400Y +1     _DI400Y      400-year boundary\n    n -= 1\n    n400, n = divmod(n, _DI400Y)\n    year = n400 * 400 + 1   # ..., -399, 1, 401, ...\n\n    # Now n is the (non-negative) offset, in days, from January 1 of year, to\n    # the desired date.  Now compute how many 100-year cycles precede n.\n    # Note that it's possible for n100 to equal 4!  In that case 4 full\n    # 100-year cycles precede the desired day, which implies the desired\n    # day is December 31 at the end of a 400-year cycle.\n    n100, n = divmod(n, _DI100Y)\n\n    # Now compute how many 4-year cycles precede it.\n    n4, n = divmod(n, _DI4Y)\n\n    # And now how many single years.  Again n1 can be 4, and again meaning\n    # that the desired day is December 31 at the end of the 4-year cycle.\n    n1, n = divmod(n, 365)\n\n    year += n100 * 100 + n4 * 4 + n1\n    if n1 == 4 or n100 == 4:\n        assert n == 0\n        return year-1, 12, 31\n\n    # Now the year is correct, and n is the offset from January 1.  We find\n    # the month via an estimate that's either exact or one too large.\n    leapyear = n1 == 3 and (n4 != 24 or n100 == 3)\n    assert leapyear == _is_leap(year)\n    month = (n + 50) >> 5\n    preceding = _DAYS_BEFORE_MONTH[month] + (month > 2 and leapyear)\n    if preceding > n:  # estimate is too large\n        month -= 1\n        preceding -= _DAYS_IN_MONTH[month] + (month == 2 and leapyear)\n    n -= preceding\n    assert 0 <= n < _days_in_month(year, month)\n\n    # Now the year and month are correct, and n is the offset from the\n    # start of that month:  we're done!\n    return year, month, n+1"
    ],
    [
        "STORE_NAME",
        "_MONTHNAMES"
    ],
    [
        "STORE_NAME",
        "_DAYNAMES"
    ],
    [
        "STORE_NAME",
        "def _build_struct_time(y, m, d, hh, mm, ss, dstflag):\n    wday = (_ymd2ord(y, m, d) + 6) % 7\n    dnum = _days_before_month(y, m) + d\n    return _time.struct_time((y, m, d, hh, mm, ss, wday, dnum, dstflag))"
    ],
    [
        "STORE_NAME",
        "def _format_time(hh, mm, ss, us, timespec='auto'):\n    specs = {\n        'hours': '{:02d}',\n        'minutes': '{:02d}:{:02d}',\n        'seconds': '{:02d}:{:02d}:{:02d}',\n        'milliseconds': '{:02d}:{:02d}:{:02d}.{:03d}',\n        'microseconds': '{:02d}:{:02d}:{:02d}.{:06d}'\n    }\n\n    if timespec == 'auto':\n        # Skip trailing microseconds when us==0.\n        timespec = 'microseconds' if us else 'seconds'\n    elif timespec == 'milliseconds':\n        us //= 1000\n    try:\n        fmt = specs[timespec]\n    except KeyError:\n        raise ValueError('Unknown timespec value')\n    else:\n        return fmt.format(hh, mm, ss, us)"
    ],
    [
        "STORE_NAME",
        "def _format_offset(off):\n    s = ''\n    if off is not None:\n        if off.days < 0:\n            sign = \"-\"\n            off = -off\n        else:\n            sign = \"+\"\n        hh, mm = divmod(off, timedelta(hours=1))\n        mm, ss = divmod(mm, timedelta(minutes=1))\n        s += \"%s%02d:%02d\" % (sign, hh, mm)\n        if ss or ss.microseconds:\n            s += \":%02d\" % ss.seconds\n\n            if ss.microseconds:\n                s += '.%06d' % ss.microseconds\n    return s"
    ],
    [
        "STORE_NAME",
        "def _wrap_strftime(object, format, timetuple):\n    # Don't call utcoffset() or tzname() unless actually needed.\n    freplace = None  # the string to use for %f\n    zreplace = None  # the string to use for %z\n    Zreplace = None  # the string to use for %Z\n\n    # Scan format for %z and %Z escapes, replacing as needed.\n    newformat = []\n    push = newformat.append\n    i, n = 0, len(format)\n    while i < n:\n        ch = format[i]\n        i += 1\n        if ch == '%':\n            if i < n:\n                ch = format[i]\n                i += 1\n                if ch == 'f':\n                    if freplace is None:\n                        freplace = '%06d' % getattr(object,\n                                                    'microsecond', 0)\n                    newformat.append(freplace)\n                elif ch == 'z':\n                    if zreplace is None:\n                        zreplace = \"\"\n                        if hasattr(object, \"utcoffset\"):\n                            offset = object.utcoffset()\n                            if offset is not None:\n                                sign = '+'\n                                if offset.days < 0:\n                                    offset = -offset\n                                    sign = '-'\n                                h, rest = divmod(offset, timedelta(hours=1))\n                                m, rest = divmod(rest, timedelta(minutes=1))\n                                s = rest.seconds\n                                u = offset.microseconds\n                                if u:\n                                    zreplace = '%c%02d%02d%02d.%06d' % (sign, h, m, s, u)\n                                elif s:\n                                    zreplace = '%c%02d%02d%02d' % (sign, h, m, s)\n                                else:\n                                    zreplace = '%c%02d%02d' % (sign, h, m)\n                    assert '%' not in zreplace\n                    newformat.append(zreplace)\n                elif ch == 'Z':\n                    if Zreplace is None:\n                        Zreplace = \"\"\n                        if hasattr(object, \"tzname\"):\n                            s = object.tzname()\n                            if s is not None:\n                                # strftime is going to have at this: escape %\n                                Zreplace = s.replace('%', '%%')\n                    newformat.append(Zreplace)\n                else:\n                    push('%')\n                    push(ch)\n            else:\n                push('%')\n        else:\n            push(ch)\n    newformat = \"\".join(newformat)\n    return _time.strftime(newformat, timetuple)"
    ],
    [
        "STORE_NAME",
        "def _is_ascii_digit(c):\n    return c in \"0123456789\""
    ],
    [
        "STORE_NAME",
        "def _find_isoformat_datetime_separator(dtstr):\n    # See the comment in _datetimemodule.c:_find_isoformat_datetime_separator\n    len_dtstr = len(dtstr)\n    if len_dtstr == 7:\n        return 7\n\n    assert len_dtstr > 7\n    date_separator = \"-\"\n    week_indicator = \"W\"\n\n    if dtstr[4] == date_separator:\n        if dtstr[5] == week_indicator:\n            if len_dtstr < 8:\n                raise ValueError(\"Invalid ISO string\")\n            if len_dtstr > 8 and dtstr[8] == date_separator:\n                if len_dtstr == 9:\n                    raise ValueError(\"Invalid ISO string\")\n                if len_dtstr > 10 and _is_ascii_digit(dtstr[10]):\n                    # This is as far as we need to resolve the ambiguity for\n                    # the moment - if we have YYYY-Www-##, the separator is\n                    # either a hyphen at 8 or a number at 10.\n                    #\n                    # We'll assume it's a hyphen at 8 because it's way more\n                    # likely that someone will use a hyphen as a separator than\n                    # a number, but at this point it's really best effort\n                    # because this is an extension of the spec anyway.\n                    # TODO(pganssle): Document this\n                    return 8\n                return 10\n            else:\n                # YYYY-Www (8)\n                return 8\n        else:\n            # YYYY-MM-DD (10)\n            return 10\n    else:\n        if dtstr[4] == week_indicator:\n            # YYYYWww (7) or YYYYWwwd (8)\n            idx = 7\n            while idx < len_dtstr:\n                if not _is_ascii_digit(dtstr[idx]):\n                    break\n                idx += 1\n\n            if idx < 9:\n                return idx\n\n            if idx % 2 == 0:\n                # If the index of the last number is even, it's YYYYWwwd\n                return 7\n            else:\n                return 8\n        else:\n            # YYYYMMDD (8)\n            return 8"
    ],
    [
        "STORE_NAME",
        "def _parse_isoformat_date(dtstr):\n    # It is assumed that this is an ASCII-only string of lengths 7, 8 or 10,\n    # see the comment on Modules/_datetimemodule.c:_find_isoformat_datetime_separator\n    assert len(dtstr) in (7, 8, 10)\n    year = int(dtstr[0:4])\n    has_sep = dtstr[4] == '-'\n\n    pos = 4 + has_sep\n    if dtstr[pos:pos + 1] == \"W\":\n        # YYYY-?Www-?D?\n        pos += 1\n        weekno = int(dtstr[pos:pos + 2])\n        pos += 2\n\n        dayno = 1\n        if len(dtstr) > pos:\n            if (dtstr[pos:pos + 1] == '-') != has_sep:\n                raise ValueError(\"Inconsistent use of dash separator\")\n\n            pos += has_sep\n\n            dayno = int(dtstr[pos:pos + 1])\n\n        return list(_isoweek_to_gregorian(year, weekno, dayno))\n    else:\n        month = int(dtstr[pos:pos + 2])\n        pos += 2\n        if (dtstr[pos:pos + 1] == \"-\") != has_sep:\n            raise ValueError(\"Inconsistent use of dash separator\")\n\n        pos += has_sep\n        day = int(dtstr[pos:pos + 2])\n\n        return [year, month, day]"
    ],
    [
        "STORE_NAME",
        "_FRACTION_CORRECTION"
    ],
    [
        "STORE_NAME",
        "def _parse_hh_mm_ss_ff(tstr):\n    # Parses things of the form HH[:?MM[:?SS[{.,}fff[fff]]]]\n    len_str = len(tstr)\n\n    time_comps = [0, 0, 0, 0]\n    pos = 0\n    for comp in range(0, 3):\n        if (len_str - pos) < 2:\n            raise ValueError(\"Incomplete time component\")\n\n        time_comps[comp] = int(tstr[pos:pos+2])\n\n        pos += 2\n        next_char = tstr[pos:pos+1]\n\n        if comp == 0:\n            has_sep = next_char == ':'\n\n        if not next_char or comp >= 2:\n            break\n\n        if has_sep and next_char != ':':\n            raise ValueError(\"Invalid time separator: %c\" % next_char)\n\n        pos += has_sep\n\n    if pos < len_str:\n        if tstr[pos] not in '.,':\n            raise ValueError(\"Invalid microsecond component\")\n        else:\n            pos += 1\n\n            len_remainder = len_str - pos\n\n            if len_remainder >= 6:\n                to_parse = 6\n            else:\n                to_parse = len_remainder\n\n            time_comps[3] = int(tstr[pos:(pos+to_parse)])\n            if to_parse < 6:\n                time_comps[3] *= _FRACTION_CORRECTION[to_parse-1]\n            if (len_remainder > to_parse\n                    and not all(map(_is_ascii_digit, tstr[(pos+to_parse):]))):\n                raise ValueError(\"Non-digit values in unparsed fraction\")\n\n    return time_comps"
    ],
    [
        "STORE_NAME",
        "def _parse_isoformat_time(tstr):\n    # Format supported is HH[:MM[:SS[.fff[fff]]]][+HH:MM[:SS[.ffffff]]]\n    len_str = len(tstr)\n    if len_str < 2:\n        raise ValueError(\"Isoformat time too short\")\n\n    # This is equivalent to re.search('[+-Z]', tstr), but faster\n    tz_pos = (tstr.find('-') + 1 or tstr.find('+') + 1 or tstr.find('Z') + 1)\n    timestr = tstr[:tz_pos-1] if tz_pos > 0 else tstr\n\n    time_comps = _parse_hh_mm_ss_ff(timestr)\n\n    tzi = None\n    if tz_pos == len_str and tstr[-1] == 'Z':\n        tzi = timezone.utc\n    elif tz_pos > 0:\n        tzstr = tstr[tz_pos:]\n\n        # Valid time zone strings are:\n        # HH                  len: 2\n        # HHMM                len: 4\n        # HH:MM               len: 5\n        # HHMMSS              len: 6\n        # HHMMSS.f+           len: 7+\n        # HH:MM:SS            len: 8\n        # HH:MM:SS.f+         len: 10+\n\n        if len(tzstr) in (0, 1, 3):\n            raise ValueError(\"Malformed time zone string\")\n\n        tz_comps = _parse_hh_mm_ss_ff(tzstr)\n\n        if all(x == 0 for x in tz_comps):\n            tzi = timezone.utc\n        else:\n            tzsign = -1 if tstr[tz_pos - 1] == '-' else 1\n\n            td = timedelta(hours=tz_comps[0], minutes=tz_comps[1],\n                           seconds=tz_comps[2], microseconds=tz_comps[3])\n\n            tzi = timezone(tzsign * td)\n\n    time_comps.append(tzi)\n\n    return time_comps"
    ],
    [
        "STORE_NAME",
        "def _isoweek_to_gregorian(year, week, day):\n    # Year is bounded this way because 9999-12-31 is (9999, 52, 5)\n    if not MINYEAR <= year <= MAXYEAR:\n        raise ValueError(f\"Year is out of range: {year}\")\n\n    if not 0 < week < 53:\n        out_of_range = True\n\n        if week == 53:\n            # ISO years have 53 weeks in them on years starting with a\n            # Thursday and leap years starting on a Wednesday\n            first_weekday = _ymd2ord(year, 1, 1) % 7\n            if (first_weekday == 4 or (first_weekday == 3 and\n                                       _is_leap(year))):\n                out_of_range = False\n\n        if out_of_range:\n            raise ValueError(f\"Invalid week: {week}\")\n\n    if not 0 < day < 8:\n        raise ValueError(f\"Invalid weekday: {day} (range is [1, 7])\")\n\n    # Now compute the offset from (Y, 1, 1) in days:\n    day_offset = (week - 1) * 7 + (day - 1)\n\n    # Calculate the ordinal day for monday, week 1\n    day_1 = _isoweek1monday(year)\n    ord_day = day_1 + day_offset\n\n    return _ord2ymd(ord_day)"
    ],
    [
        "STORE_NAME",
        "def _check_tzname(name):\n    if name is not None and not isinstance(name, str):\n        raise TypeError(\"tzinfo.tzname() must return None or string, \"\n                        \"not '%s'\" % type(name))"
    ],
    [
        "STORE_NAME",
        "def _check_utc_offset(name, offset):\n    assert name in (\"utcoffset\", \"dst\")\n    if offset is None:\n        return\n    if not isinstance(offset, timedelta):\n        raise TypeError(\"tzinfo.%s() must return None \"\n                        \"or timedelta, not '%s'\" % (name, type(offset)))\n    if not -timedelta(1) < offset < timedelta(1):\n        raise ValueError(\"%s()=%s, must be strictly between \"\n                         \"-timedelta(hours=24) and timedelta(hours=24)\" %\n                         (name, offset))"
    ],
    [
        "STORE_NAME",
        "def _check_date_fields(year, month, day):\n    year = _index(year)\n    month = _index(month)\n    day = _index(day)\n    if not MINYEAR <= year <= MAXYEAR:\n        raise ValueError('year must be in %d..%d' % (MINYEAR, MAXYEAR), year)\n    if not 1 <= month <= 12:\n        raise ValueError('month must be in 1..12', month)\n    dim = _days_in_month(year, month)\n    if not 1 <= day <= dim:\n        raise ValueError('day must be in 1..%d' % dim, day)\n    return year, month, day"
    ],
    [
        "STORE_NAME",
        "def _check_time_fields(hour, minute, second, microsecond, fold):\n    hour = _index(hour)\n    minute = _index(minute)\n    second = _index(second)\n    microsecond = _index(microsecond)\n    if not 0 <= hour <= 23:\n        raise ValueError('hour must be in 0..23', hour)\n    if not 0 <= minute <= 59:\n        raise ValueError('minute must be in 0..59', minute)\n    if not 0 <= second <= 59:\n        raise ValueError('second must be in 0..59', second)\n    if not 0 <= microsecond <= 999999:\n        raise ValueError('microsecond must be in 0..999999', microsecond)\n    if fold not in (0, 1):\n        raise ValueError('fold must be either 0 or 1', fold)\n    return hour, minute, second, microsecond, fold"
    ],
    [
        "STORE_NAME",
        "def _check_tzinfo_arg(tz):\n    if tz is not None and not isinstance(tz, tzinfo):\n        raise TypeError(\"tzinfo argument must be None or of a tzinfo subclass\")"
    ],
    [
        "STORE_NAME",
        "def _cmperror(x, y):\n    raise TypeError(\"can't compare '%s' to '%s'\" % (\n                    type(x).__name__, type(y).__name__))"
    ],
    [
        "STORE_NAME",
        "def _divide_and_round(a, b):\n    \"\"\"divide a by b and round result to the nearest integer\n\n    When the ratio is exactly half-way between two integers,\n    the even integer is returned.\n    \"\"\"\n    # Based on the reference implementation for divmod_near\n    # in Objects/longobject.c.\n    q, r = divmod(a, b)\n    # round up if either r / b > 0.5, or r / b == 0.5 and q is odd.\n    # The expression r / b > 0.5 is equivalent to 2 * r > b if b is\n    # positive, 2 * r < b if b negative.\n    r *= 2\n    greater_than_half = r > b if b > 0 else r < b\n    if greater_than_half or r == b and q % 2 == 1:\n        q += 1\n\n    return q"
    ],
    [
        "CALL",
        "class timedelta:\n    \"\"\"Represent the difference between two datetime objects.\n\n    Supported operators:\n\n    - add, subtract timedelta\n    - unary plus, minus, abs\n    - compare to timedelta\n    - multiply, divide by int\n\n    In addition, datetime supports subtraction of two datetime objects\n    returning a timedelta, and addition or subtraction of a datetime\n    and a timedelta giving a datetime.\n\n    Representation: (days, seconds, microseconds).  Why?  Because I\n    felt like it.\n    \"\"\"\n    __slots__ = '_days', '_seconds', '_microseconds', '_hashcode'\n\n    def __new__(cls, days=0, seconds=0, microseconds=0,\n                milliseconds=0, minutes=0, hours=0, weeks=0):\n        # Doing this efficiently and accurately in C is going to be difficult\n        # and error-prone, due to ubiquitous overflow possibilities, and that\n        # C double doesn't have enough bits of precision to represent\n        # microseconds over 10K years faithfully.  The code here tries to make\n        # explicit where go-fast assumptions can be relied on, in order to\n        # guide the C implementation; it's way more convoluted than speed-\n        # ignoring auto-overflow-to-long idiomatic Python could be.\n\n        # XXX Check that all inputs are ints or floats.\n\n        # Final values, all integer.\n        # s and us fit in 32-bit signed ints; d isn't bounded.\n        d = s = us = 0\n\n        # Normalize everything to days, seconds, microseconds.\n        days += weeks*7\n        seconds += minutes*60 + hours*3600\n        microseconds += milliseconds*1000\n\n        # Get rid of all fractions, and normalize s and us.\n        # Take a deep breath <wink>.\n        if isinstance(days, float):\n            dayfrac, days = _math.modf(days)\n            daysecondsfrac, daysecondswhole = _math.modf(dayfrac * (24.*3600.))\n            assert daysecondswhole == int(daysecondswhole)  # can't overflow\n            s = int(daysecondswhole)\n            assert days == int(days)\n            d = int(days)\n        else:\n            daysecondsfrac = 0.0\n            d = days\n        assert isinstance(daysecondsfrac, float)\n        assert abs(daysecondsfrac) <= 1.0\n        assert isinstance(d, int)\n        assert abs(s) <= 24 * 3600\n        # days isn't referenced again before redefinition\n\n        if isinstance(seconds, float):\n            secondsfrac, seconds = _math.modf(seconds)\n            assert seconds == int(seconds)\n            seconds = int(seconds)\n            secondsfrac += daysecondsfrac\n            assert abs(secondsfrac) <= 2.0\n        else:\n            secondsfrac = daysecondsfrac\n        # daysecondsfrac isn't referenced again\n        assert isinstance(secondsfrac, float)\n        assert abs(secondsfrac) <= 2.0\n\n        assert isinstance(seconds, int)\n        days, seconds = divmod(seconds, 24*3600)\n        d += days\n        s += int(seconds)    # can't overflow\n        assert isinstance(s, int)\n        assert abs(s) <= 2 * 24 * 3600\n        # seconds isn't referenced again before redefinition\n\n        usdouble = secondsfrac * 1e6\n        assert abs(usdouble) < 2.1e6    # exact value not critical\n        # secondsfrac isn't referenced again\n\n        if isinstance(microseconds, float):\n            microseconds = round(microseconds + usdouble)\n            seconds, microseconds = divmod(microseconds, 1000000)\n            days, seconds = divmod(seconds, 24*3600)\n            d += days\n            s += seconds\n        else:\n            microseconds = int(microseconds)\n            seconds, microseconds = divmod(microseconds, 1000000)\n            days, seconds = divmod(seconds, 24*3600)\n            d += days\n            s += seconds\n            microseconds = round(microseconds + usdouble)\n        assert isinstance(s, int)\n        assert isinstance(microseconds, int)\n        assert abs(s) <= 3 * 24 * 3600\n        assert abs(microseconds) < 3.1e6\n\n        # Just a little bit of carrying possible for microseconds and seconds.\n        seconds, us = divmod(microseconds, 1000000)\n        s += seconds\n        days, s = divmod(s, 24*3600)\n        d += days\n\n        assert isinstance(d, int)\n        assert isinstance(s, int) and 0 <= s < 24*3600\n        assert isinstance(us, int) and 0 <= us < 1000000\n\n        if abs(d) > 999999999:\n            raise OverflowError(\"timedelta # of days is too large: %d\" % d)\n\n        self = object.__new__(cls)\n        self._days = d\n        self._seconds = s\n        self._microseconds = us\n        self._hashcode = -1\n        return self\n\n    def __repr__(self):\n        args = []\n        if self._days:\n            args.append(\"days=%d\" % self._days)\n        if self._seconds:\n            args.append(\"seconds=%d\" % self._seconds)\n        if self._microseconds:\n            args.append(\"microseconds=%d\" % self._microseconds)\n        if not args:\n            args.append('0')\n        return \"%s.%s(%s)\" % (self.__class__.__module__,\n                              self.__class__.__qualname__,\n                              ', '.join(args))\n\n    def __str__(self):\n        mm, ss = divmod(self._seconds, 60)\n        hh, mm = divmod(mm, 60)\n        s = \"%d:%02d:%02d\" % (hh, mm, ss)\n        if self._days:\n            def plural(n):\n                return n, abs(n) != 1 and \"s\" or \"\"\n            s = (\"%d day%s, \" % plural(self._days)) + s\n        if self._microseconds:\n            s = s + \".%06d\" % self._microseconds\n        return s\n\n    def total_seconds(self):\n        \"\"\"Total seconds in the duration.\"\"\"\n        return ((self.days * 86400 + self.seconds) * 10**6 +\n                self.microseconds) / 10**6\n\n    # Read-only field accessors\n    @property\n    def days(self):\n        \"\"\"days\"\"\"\n        return self._days\n\n    @property\n    def seconds(self):\n        \"\"\"seconds\"\"\"\n        return self._seconds\n\n    @property\n    def microseconds(self):\n        \"\"\"microseconds\"\"\"\n        return self._microseconds\n\n    def __add__(self, other):\n        if isinstance(other, timedelta):\n            # for CPython compatibility, we cannot use\n            # our __class__ here, but need a real timedelta\n            return timedelta(self._days + other._days,\n                             self._seconds + other._seconds,\n                             self._microseconds + other._microseconds)\n        return NotImplemented\n\n    __radd__ = __add__\n\n    def __sub__(self, other):\n        if isinstance(other, timedelta):\n            # for CPython compatibility, we cannot use\n            # our __class__ here, but need a real timedelta\n            return timedelta(self._days - other._days,\n                             self._seconds - other._seconds,\n                             self._microseconds - other._microseconds)\n        return NotImplemented\n\n    def __rsub__(self, other):\n        if isinstance(other, timedelta):\n            return -self + other\n        return NotImplemented\n\n    def __neg__(self):\n        # for CPython compatibility, we cannot use\n        # our __class__ here, but need a real timedelta\n        return timedelta(-self._days,\n                         -self._seconds,\n                         -self._microseconds)\n\n    def __pos__(self):\n        return self\n\n    def __abs__(self):\n        if self._days < 0:\n            return -self\n        else:\n            return self\n\n    def __mul__(self, other):\n        if isinstance(other, int):\n            # for CPython compatibility, we cannot use\n            # our __class__ here, but need a real timedelta\n            return timedelta(self._days * other,\n                             self._seconds * other,\n                             self._microseconds * other)\n        if isinstance(other, float):\n            usec = self._to_microseconds()\n            a, b = other.as_integer_ratio()\n            return timedelta(0, 0, _divide_and_round(usec * a, b))\n        return NotImplemented\n\n    __rmul__ = __mul__\n\n    def _to_microseconds(self):\n        return ((self._days * (24*3600) + self._seconds) * 1000000 +\n                self._microseconds)\n\n    def __floordiv__(self, other):\n        if not isinstance(other, (int, timedelta)):\n            return NotImplemented\n        usec = self._to_microseconds()\n        if isinstance(other, timedelta):\n            return usec // other._to_microseconds()\n        if isinstance(other, int):\n            return timedelta(0, 0, usec // other)\n\n    def __truediv__(self, other):\n        if not isinstance(other, (int, float, timedelta)):\n            return NotImplemented\n        usec = self._to_microseconds()\n        if isinstance(other, timedelta):\n            return usec / other._to_microseconds()\n        if isinstance(other, int):\n            return timedelta(0, 0, _divide_and_round(usec, other))\n        if isinstance(other, float):\n            a, b = other.as_integer_ratio()\n            return timedelta(0, 0, _divide_and_round(b * usec, a))\n\n    def __mod__(self, other):\n        if isinstance(other, timedelta):\n            r = self._to_microseconds() % other._to_microseconds()\n            return timedelta(0, 0, r)\n        return NotImplemented\n\n    def __divmod__(self, other):\n        if isinstance(other, timedelta):\n            q, r = divmod(self._to_microseconds(),\n                          other._to_microseconds())\n            return q, timedelta(0, 0, r)\n        return NotImplemented\n\n    # Comparisons of timedelta objects with other.\n\n    def __eq__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) == 0\n        else:\n            return NotImplemented\n\n    def __le__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) <= 0\n        else:\n            return NotImplemented\n\n    def __lt__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) < 0\n        else:\n            return NotImplemented\n\n    def __ge__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) >= 0\n        else:\n            return NotImplemented\n\n    def __gt__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) > 0\n        else:\n            return NotImplemented\n\n    def _cmp(self, other):\n        assert isinstance(other, timedelta)\n        return _cmp(self._getstate(), other._getstate())\n\n    def __hash__(self):\n        if self._hashcode == -1:\n            self._hashcode = hash(self._getstate())\n        return self._hashcode\n\n    def __bool__(self):\n        return (self._days != 0 or\n                self._seconds != 0 or\n                self._microseconds != 0)\n\n    # Pickle support.\n\n    def _getstate(self):\n        return (self._days, self._seconds, self._microseconds)\n\n    def __reduce__(self):\n        return (self.__class__, self._getstate())"
    ],
    [
        "STORE_NAME",
        "class timedelta:\n    \"\"\"Represent the difference between two datetime objects.\n\n    Supported operators:\n\n    - add, subtract timedelta\n    - unary plus, minus, abs\n    - compare to timedelta\n    - multiply, divide by int\n\n    In addition, datetime supports subtraction of two datetime objects\n    returning a timedelta, and addition or subtraction of a datetime\n    and a timedelta giving a datetime.\n\n    Representation: (days, seconds, microseconds).  Why?  Because I\n    felt like it.\n    \"\"\"\n    __slots__ = '_days', '_seconds', '_microseconds', '_hashcode'\n\n    def __new__(cls, days=0, seconds=0, microseconds=0,\n                milliseconds=0, minutes=0, hours=0, weeks=0):\n        # Doing this efficiently and accurately in C is going to be difficult\n        # and error-prone, due to ubiquitous overflow possibilities, and that\n        # C double doesn't have enough bits of precision to represent\n        # microseconds over 10K years faithfully.  The code here tries to make\n        # explicit where go-fast assumptions can be relied on, in order to\n        # guide the C implementation; it's way more convoluted than speed-\n        # ignoring auto-overflow-to-long idiomatic Python could be.\n\n        # XXX Check that all inputs are ints or floats.\n\n        # Final values, all integer.\n        # s and us fit in 32-bit signed ints; d isn't bounded.\n        d = s = us = 0\n\n        # Normalize everything to days, seconds, microseconds.\n        days += weeks*7\n        seconds += minutes*60 + hours*3600\n        microseconds += milliseconds*1000\n\n        # Get rid of all fractions, and normalize s and us.\n        # Take a deep breath <wink>.\n        if isinstance(days, float):\n            dayfrac, days = _math.modf(days)\n            daysecondsfrac, daysecondswhole = _math.modf(dayfrac * (24.*3600.))\n            assert daysecondswhole == int(daysecondswhole)  # can't overflow\n            s = int(daysecondswhole)\n            assert days == int(days)\n            d = int(days)\n        else:\n            daysecondsfrac = 0.0\n            d = days\n        assert isinstance(daysecondsfrac, float)\n        assert abs(daysecondsfrac) <= 1.0\n        assert isinstance(d, int)\n        assert abs(s) <= 24 * 3600\n        # days isn't referenced again before redefinition\n\n        if isinstance(seconds, float):\n            secondsfrac, seconds = _math.modf(seconds)\n            assert seconds == int(seconds)\n            seconds = int(seconds)\n            secondsfrac += daysecondsfrac\n            assert abs(secondsfrac) <= 2.0\n        else:\n            secondsfrac = daysecondsfrac\n        # daysecondsfrac isn't referenced again\n        assert isinstance(secondsfrac, float)\n        assert abs(secondsfrac) <= 2.0\n\n        assert isinstance(seconds, int)\n        days, seconds = divmod(seconds, 24*3600)\n        d += days\n        s += int(seconds)    # can't overflow\n        assert isinstance(s, int)\n        assert abs(s) <= 2 * 24 * 3600\n        # seconds isn't referenced again before redefinition\n\n        usdouble = secondsfrac * 1e6\n        assert abs(usdouble) < 2.1e6    # exact value not critical\n        # secondsfrac isn't referenced again\n\n        if isinstance(microseconds, float):\n            microseconds = round(microseconds + usdouble)\n            seconds, microseconds = divmod(microseconds, 1000000)\n            days, seconds = divmod(seconds, 24*3600)\n            d += days\n            s += seconds\n        else:\n            microseconds = int(microseconds)\n            seconds, microseconds = divmod(microseconds, 1000000)\n            days, seconds = divmod(seconds, 24*3600)\n            d += days\n            s += seconds\n            microseconds = round(microseconds + usdouble)\n        assert isinstance(s, int)\n        assert isinstance(microseconds, int)\n        assert abs(s) <= 3 * 24 * 3600\n        assert abs(microseconds) < 3.1e6\n\n        # Just a little bit of carrying possible for microseconds and seconds.\n        seconds, us = divmod(microseconds, 1000000)\n        s += seconds\n        days, s = divmod(s, 24*3600)\n        d += days\n\n        assert isinstance(d, int)\n        assert isinstance(s, int) and 0 <= s < 24*3600\n        assert isinstance(us, int) and 0 <= us < 1000000\n\n        if abs(d) > 999999999:\n            raise OverflowError(\"timedelta # of days is too large: %d\" % d)\n\n        self = object.__new__(cls)\n        self._days = d\n        self._seconds = s\n        self._microseconds = us\n        self._hashcode = -1\n        return self\n\n    def __repr__(self):\n        args = []\n        if self._days:\n            args.append(\"days=%d\" % self._days)\n        if self._seconds:\n            args.append(\"seconds=%d\" % self._seconds)\n        if self._microseconds:\n            args.append(\"microseconds=%d\" % self._microseconds)\n        if not args:\n            args.append('0')\n        return \"%s.%s(%s)\" % (self.__class__.__module__,\n                              self.__class__.__qualname__,\n                              ', '.join(args))\n\n    def __str__(self):\n        mm, ss = divmod(self._seconds, 60)\n        hh, mm = divmod(mm, 60)\n        s = \"%d:%02d:%02d\" % (hh, mm, ss)\n        if self._days:\n            def plural(n):\n                return n, abs(n) != 1 and \"s\" or \"\"\n            s = (\"%d day%s, \" % plural(self._days)) + s\n        if self._microseconds:\n            s = s + \".%06d\" % self._microseconds\n        return s\n\n    def total_seconds(self):\n        \"\"\"Total seconds in the duration.\"\"\"\n        return ((self.days * 86400 + self.seconds) * 10**6 +\n                self.microseconds) / 10**6\n\n    # Read-only field accessors\n    @property\n    def days(self):\n        \"\"\"days\"\"\"\n        return self._days\n\n    @property\n    def seconds(self):\n        \"\"\"seconds\"\"\"\n        return self._seconds\n\n    @property\n    def microseconds(self):\n        \"\"\"microseconds\"\"\"\n        return self._microseconds\n\n    def __add__(self, other):\n        if isinstance(other, timedelta):\n            # for CPython compatibility, we cannot use\n            # our __class__ here, but need a real timedelta\n            return timedelta(self._days + other._days,\n                             self._seconds + other._seconds,\n                             self._microseconds + other._microseconds)\n        return NotImplemented\n\n    __radd__ = __add__\n\n    def __sub__(self, other):\n        if isinstance(other, timedelta):\n            # for CPython compatibility, we cannot use\n            # our __class__ here, but need a real timedelta\n            return timedelta(self._days - other._days,\n                             self._seconds - other._seconds,\n                             self._microseconds - other._microseconds)\n        return NotImplemented\n\n    def __rsub__(self, other):\n        if isinstance(other, timedelta):\n            return -self + other\n        return NotImplemented\n\n    def __neg__(self):\n        # for CPython compatibility, we cannot use\n        # our __class__ here, but need a real timedelta\n        return timedelta(-self._days,\n                         -self._seconds,\n                         -self._microseconds)\n\n    def __pos__(self):\n        return self\n\n    def __abs__(self):\n        if self._days < 0:\n            return -self\n        else:\n            return self\n\n    def __mul__(self, other):\n        if isinstance(other, int):\n            # for CPython compatibility, we cannot use\n            # our __class__ here, but need a real timedelta\n            return timedelta(self._days * other,\n                             self._seconds * other,\n                             self._microseconds * other)\n        if isinstance(other, float):\n            usec = self._to_microseconds()\n            a, b = other.as_integer_ratio()\n            return timedelta(0, 0, _divide_and_round(usec * a, b))\n        return NotImplemented\n\n    __rmul__ = __mul__\n\n    def _to_microseconds(self):\n        return ((self._days * (24*3600) + self._seconds) * 1000000 +\n                self._microseconds)\n\n    def __floordiv__(self, other):\n        if not isinstance(other, (int, timedelta)):\n            return NotImplemented\n        usec = self._to_microseconds()\n        if isinstance(other, timedelta):\n            return usec // other._to_microseconds()\n        if isinstance(other, int):\n            return timedelta(0, 0, usec // other)\n\n    def __truediv__(self, other):\n        if not isinstance(other, (int, float, timedelta)):\n            return NotImplemented\n        usec = self._to_microseconds()\n        if isinstance(other, timedelta):\n            return usec / other._to_microseconds()\n        if isinstance(other, int):\n            return timedelta(0, 0, _divide_and_round(usec, other))\n        if isinstance(other, float):\n            a, b = other.as_integer_ratio()\n            return timedelta(0, 0, _divide_and_round(b * usec, a))\n\n    def __mod__(self, other):\n        if isinstance(other, timedelta):\n            r = self._to_microseconds() % other._to_microseconds()\n            return timedelta(0, 0, r)\n        return NotImplemented\n\n    def __divmod__(self, other):\n        if isinstance(other, timedelta):\n            q, r = divmod(self._to_microseconds(),\n                          other._to_microseconds())\n            return q, timedelta(0, 0, r)\n        return NotImplemented\n\n    # Comparisons of timedelta objects with other.\n\n    def __eq__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) == 0\n        else:\n            return NotImplemented\n\n    def __le__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) <= 0\n        else:\n            return NotImplemented\n\n    def __lt__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) < 0\n        else:\n            return NotImplemented\n\n    def __ge__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) >= 0\n        else:\n            return NotImplemented\n\n    def __gt__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) > 0\n        else:\n            return NotImplemented\n\n    def _cmp(self, other):\n        assert isinstance(other, timedelta)\n        return _cmp(self._getstate(), other._getstate())\n\n    def __hash__(self):\n        if self._hashcode == -1:\n            self._hashcode = hash(self._getstate())\n        return self._hashcode\n\n    def __bool__(self):\n        return (self._days != 0 or\n                self._seconds != 0 or\n                self._microseconds != 0)\n\n    # Pickle support.\n\n    def _getstate(self):\n        return (self._days, self._seconds, self._microseconds)\n\n    def __reduce__(self):\n        return (self.__class__, self._getstate())"
    ],
    [
        "LOAD_NAME",
        "timedelta"
    ],
    [
        "CALL",
        "timedelta(-999999999)"
    ],
    [
        "LOAD_NAME",
        "timedelta"
    ],
    [
        "STORE_ATTR",
        "timedelta.min"
    ],
    [
        "LOAD_NAME",
        "timedelta"
    ],
    [
        "CALL",
        "timedelta(days=999999999, hours=23, minutes=59, seconds=59,\n                          microseconds=999999)"
    ],
    [
        "LOAD_NAME",
        "timedelta"
    ],
    [
        "STORE_ATTR",
        "timedelta.max"
    ],
    [
        "LOAD_NAME",
        "timedelta"
    ],
    [
        "CALL",
        "timedelta(microseconds=1)"
    ],
    [
        "LOAD_NAME",
        "timedelta"
    ],
    [
        "STORE_ATTR",
        "timedelta.resolution"
    ],
    [
        "CALL",
        "class date:\n    \"\"\"Concrete date type.\n\n    Constructors:\n\n    __new__()\n    fromtimestamp()\n    today()\n    fromordinal()\n\n    Operators:\n\n    __repr__, __str__\n    __eq__, __le__, __lt__, __ge__, __gt__, __hash__\n    __add__, __radd__, __sub__ (add/radd only with timedelta arg)\n\n    Methods:\n\n    timetuple()\n    toordinal()\n    weekday()\n    isoweekday(), isocalendar(), isoformat()\n    ctime()\n    strftime()\n\n    Properties (readonly):\n    year, month, day\n    \"\"\"\n    __slots__ = '_year', '_month', '_day', '_hashcode'\n\n    def __new__(cls, year, month=None, day=None):\n        \"\"\"Constructor.\n\n        Arguments:\n\n        year, month, day (required, base 1)\n        \"\"\"\n        if (month is None and\n            isinstance(year, (bytes, str)) and len(year) == 4 and\n            1 <= ord(year[2:3]) <= 12):\n            # Pickle support\n            if isinstance(year, str):\n                try:\n                    year = year.encode('latin1')\n                except UnicodeEncodeError:\n                    # More informative error message.\n                    raise ValueError(\n                        \"Failed to encode latin1 string when unpickling \"\n                        \"a date object. \"\n                        \"pickle.load(data, encoding='latin1') is assumed.\")\n            self = object.__new__(cls)\n            self.__setstate(year)\n            self._hashcode = -1\n            return self\n        year, month, day = _check_date_fields(year, month, day)\n        self = object.__new__(cls)\n        self._year = year\n        self._month = month\n        self._day = day\n        self._hashcode = -1\n        return self\n\n    # Additional constructors\n\n    @classmethod\n    def fromtimestamp(cls, t):\n        \"Construct a date from a POSIX timestamp (like time.time()).\"\n        y, m, d, hh, mm, ss, weekday, jday, dst = _time.localtime(t)\n        return cls(y, m, d)\n\n    @classmethod\n    def today(cls):\n        \"Construct a date from time.time().\"\n        t = _time.time()\n        return cls.fromtimestamp(t)\n\n    @classmethod\n    def fromordinal(cls, n):\n        \"\"\"Construct a date from a proleptic Gregorian ordinal.\n\n        January 1 of year 1 is day 1.  Only the year, month and day are\n        non-zero in the result.\n        \"\"\"\n        y, m, d = _ord2ymd(n)\n        return cls(y, m, d)\n\n    @classmethod\n    def fromisoformat(cls, date_string):\n        \"\"\"Construct a date from a string in ISO 8601 format.\"\"\"\n        if not isinstance(date_string, str):\n            raise TypeError('fromisoformat: argument must be str')\n\n        if len(date_string) not in (7, 8, 10):\n            raise ValueError(f'Invalid isoformat string: {date_string!r}')\n\n        try:\n            return cls(*_parse_isoformat_date(date_string))\n        except Exception:\n            raise ValueError(f'Invalid isoformat string: {date_string!r}')\n\n    @classmethod\n    def fromisocalendar(cls, year, week, day):\n        \"\"\"Construct a date from the ISO year, week number and weekday.\n\n        This is the inverse of the date.isocalendar() function\"\"\"\n        return cls(*_isoweek_to_gregorian(year, week, day))\n\n    # Conversions to string\n\n    def __repr__(self):\n        \"\"\"Convert to formal string, for repr().\n\n        >>> dt = datetime(2010, 1, 1)\n        >>> repr(dt)\n        'datetime.datetime(2010, 1, 1, 0, 0)'\n\n        >>> dt = datetime(2010, 1, 1, tzinfo=timezone.utc)\n        >>> repr(dt)\n        'datetime.datetime(2010, 1, 1, 0, 0, tzinfo=datetime.timezone.utc)'\n        \"\"\"\n        return \"%s.%s(%d, %d, %d)\" % (self.__class__.__module__,\n                                      self.__class__.__qualname__,\n                                      self._year,\n                                      self._month,\n                                      self._day)\n    # XXX These shouldn't depend on time.localtime(), because that\n    # clips the usable dates to [1970 .. 2038).  At least ctime() is\n    # easily done without using strftime() -- that's better too because\n    # strftime(\"%c\", ...) is locale specific.\n\n\n    def ctime(self):\n        \"Return ctime() style string.\"\n        weekday = self.toordinal() % 7 or 7\n        return \"%s %s %2d 00:00:00 %04d\" % (\n            _DAYNAMES[weekday],\n            _MONTHNAMES[self._month],\n            self._day, self._year)\n\n    def strftime(self, fmt):\n        \"Format using strftime().\"\n        return _wrap_strftime(self, fmt, self.timetuple())\n\n    def __format__(self, fmt):\n        if not isinstance(fmt, str):\n            raise TypeError(\"must be str, not %s\" % type(fmt).__name__)\n        if len(fmt) != 0:\n            return self.strftime(fmt)\n        return str(self)\n\n    def isoformat(self):\n        \"\"\"Return the date formatted according to ISO.\n\n        This is 'YYYY-MM-DD'.\n\n        References:\n        - http://www.w3.org/TR/NOTE-datetime\n        - http://www.cl.cam.ac.uk/~mgk25/iso-time.html\n        \"\"\"\n        return \"%04d-%02d-%02d\" % (self._year, self._month, self._day)\n\n    __str__ = isoformat\n\n    # Read-only field accessors\n    @property\n    def year(self):\n        \"\"\"year (1-9999)\"\"\"\n        return self._year\n\n    @property\n    def month(self):\n        \"\"\"month (1-12)\"\"\"\n        return self._month\n\n    @property\n    def day(self):\n        \"\"\"day (1-31)\"\"\"\n        return self._day\n\n    # Standard conversions, __eq__, __le__, __lt__, __ge__, __gt__,\n    # __hash__ (and helpers)\n\n    def timetuple(self):\n        \"Return local time tuple compatible with time.localtime().\"\n        return _build_struct_time(self._year, self._month, self._day,\n                                  0, 0, 0, -1)\n\n    def toordinal(self):\n        \"\"\"Return proleptic Gregorian ordinal for the year, month and day.\n\n        January 1 of year 1 is day 1.  Only the year, month and day values\n        contribute to the result.\n        \"\"\"\n        return _ymd2ord(self._year, self._month, self._day)\n\n    def replace(self, year=None, month=None, day=None):\n        \"\"\"Return a new date with new values for the specified fields.\"\"\"\n        if year is None:\n            year = self._year\n        if month is None:\n            month = self._month\n        if day is None:\n            day = self._day\n        return type(self)(year, month, day)\n\n    # Comparisons of date objects with other.\n\n    def __eq__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) == 0\n        return NotImplemented\n\n    def __le__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) <= 0\n        return NotImplemented\n\n    def __lt__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) < 0\n        return NotImplemented\n\n    def __ge__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) >= 0\n        return NotImplemented\n\n    def __gt__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) > 0\n        return NotImplemented\n\n    def _cmp(self, other):\n        assert isinstance(other, date)\n        y, m, d = self._year, self._month, self._day\n        y2, m2, d2 = other._year, other._month, other._day\n        return _cmp((y, m, d), (y2, m2, d2))\n\n    def __hash__(self):\n        \"Hash.\"\n        if self._hashcode == -1:\n            self._hashcode = hash(self._getstate())\n        return self._hashcode\n\n    # Computations\n\n    def __add__(self, other):\n        \"Add a date to a timedelta.\"\n        if isinstance(other, timedelta):\n            o = self.toordinal() + other.days\n            if 0 < o <= _MAXORDINAL:\n                return type(self).fromordinal(o)\n            raise OverflowError(\"result out of range\")\n        return NotImplemented\n\n    __radd__ = __add__\n\n    def __sub__(self, other):\n        \"\"\"Subtract two dates, or a date and a timedelta.\"\"\"\n        if isinstance(other, timedelta):\n            return self + timedelta(-other.days)\n        if isinstance(other, date):\n            days1 = self.toordinal()\n            days2 = other.toordinal()\n            return timedelta(days1 - days2)\n        return NotImplemented\n\n    def weekday(self):\n        \"Return day of the week, where Monday == 0 ... Sunday == 6.\"\n        return (self.toordinal() + 6) % 7\n\n    # Day-of-the-week and week-of-the-year, according to ISO\n\n    def isoweekday(self):\n        \"Return day of the week, where Monday == 1 ... Sunday == 7.\"\n        # 1-Jan-0001 is a Monday\n        return self.toordinal() % 7 or 7\n\n    def isocalendar(self):\n        \"\"\"Return a named tuple containing ISO year, week number, and weekday.\n\n        The first ISO week of the year is the (Mon-Sun) week\n        containing the year's first Thursday; everything else derives\n        from that.\n\n        The first week is 1; Monday is 1 ... Sunday is 7.\n\n        ISO calendar algorithm taken from\n        http://www.phys.uu.nl/~vgent/calendar/isocalendar.htm\n        (used with permission)\n        \"\"\"\n        year = self._year\n        week1monday = _isoweek1monday(year)\n        today = _ymd2ord(self._year, self._month, self._day)\n        # Internally, week and day have origin 0\n        week, day = divmod(today - week1monday, 7)\n        if week < 0:\n            year -= 1\n            week1monday = _isoweek1monday(year)\n            week, day = divmod(today - week1monday, 7)\n        elif week >= 52:\n            if today >= _isoweek1monday(year+1):\n                year += 1\n                week = 0\n        return _IsoCalendarDate(year, week+1, day+1)\n\n    # Pickle support.\n\n    def _getstate(self):\n        yhi, ylo = divmod(self._year, 256)\n        return bytes([yhi, ylo, self._month, self._day]),\n\n    def __setstate(self, string):\n        yhi, ylo, self._month, self._day = string\n        self._year = yhi * 256 + ylo\n\n    def __reduce__(self):\n        return (self.__class__, self._getstate())"
    ],
    [
        "STORE_NAME",
        "class date:\n    \"\"\"Concrete date type.\n\n    Constructors:\n\n    __new__()\n    fromtimestamp()\n    today()\n    fromordinal()\n\n    Operators:\n\n    __repr__, __str__\n    __eq__, __le__, __lt__, __ge__, __gt__, __hash__\n    __add__, __radd__, __sub__ (add/radd only with timedelta arg)\n\n    Methods:\n\n    timetuple()\n    toordinal()\n    weekday()\n    isoweekday(), isocalendar(), isoformat()\n    ctime()\n    strftime()\n\n    Properties (readonly):\n    year, month, day\n    \"\"\"\n    __slots__ = '_year', '_month', '_day', '_hashcode'\n\n    def __new__(cls, year, month=None, day=None):\n        \"\"\"Constructor.\n\n        Arguments:\n\n        year, month, day (required, base 1)\n        \"\"\"\n        if (month is None and\n            isinstance(year, (bytes, str)) and len(year) == 4 and\n            1 <= ord(year[2:3]) <= 12):\n            # Pickle support\n            if isinstance(year, str):\n                try:\n                    year = year.encode('latin1')\n                except UnicodeEncodeError:\n                    # More informative error message.\n                    raise ValueError(\n                        \"Failed to encode latin1 string when unpickling \"\n                        \"a date object. \"\n                        \"pickle.load(data, encoding='latin1') is assumed.\")\n            self = object.__new__(cls)\n            self.__setstate(year)\n            self._hashcode = -1\n            return self\n        year, month, day = _check_date_fields(year, month, day)\n        self = object.__new__(cls)\n        self._year = year\n        self._month = month\n        self._day = day\n        self._hashcode = -1\n        return self\n\n    # Additional constructors\n\n    @classmethod\n    def fromtimestamp(cls, t):\n        \"Construct a date from a POSIX timestamp (like time.time()).\"\n        y, m, d, hh, mm, ss, weekday, jday, dst = _time.localtime(t)\n        return cls(y, m, d)\n\n    @classmethod\n    def today(cls):\n        \"Construct a date from time.time().\"\n        t = _time.time()\n        return cls.fromtimestamp(t)\n\n    @classmethod\n    def fromordinal(cls, n):\n        \"\"\"Construct a date from a proleptic Gregorian ordinal.\n\n        January 1 of year 1 is day 1.  Only the year, month and day are\n        non-zero in the result.\n        \"\"\"\n        y, m, d = _ord2ymd(n)\n        return cls(y, m, d)\n\n    @classmethod\n    def fromisoformat(cls, date_string):\n        \"\"\"Construct a date from a string in ISO 8601 format.\"\"\"\n        if not isinstance(date_string, str):\n            raise TypeError('fromisoformat: argument must be str')\n\n        if len(date_string) not in (7, 8, 10):\n            raise ValueError(f'Invalid isoformat string: {date_string!r}')\n\n        try:\n            return cls(*_parse_isoformat_date(date_string))\n        except Exception:\n            raise ValueError(f'Invalid isoformat string: {date_string!r}')\n\n    @classmethod\n    def fromisocalendar(cls, year, week, day):\n        \"\"\"Construct a date from the ISO year, week number and weekday.\n\n        This is the inverse of the date.isocalendar() function\"\"\"\n        return cls(*_isoweek_to_gregorian(year, week, day))\n\n    # Conversions to string\n\n    def __repr__(self):\n        \"\"\"Convert to formal string, for repr().\n\n        >>> dt = datetime(2010, 1, 1)\n        >>> repr(dt)\n        'datetime.datetime(2010, 1, 1, 0, 0)'\n\n        >>> dt = datetime(2010, 1, 1, tzinfo=timezone.utc)\n        >>> repr(dt)\n        'datetime.datetime(2010, 1, 1, 0, 0, tzinfo=datetime.timezone.utc)'\n        \"\"\"\n        return \"%s.%s(%d, %d, %d)\" % (self.__class__.__module__,\n                                      self.__class__.__qualname__,\n                                      self._year,\n                                      self._month,\n                                      self._day)\n    # XXX These shouldn't depend on time.localtime(), because that\n    # clips the usable dates to [1970 .. 2038).  At least ctime() is\n    # easily done without using strftime() -- that's better too because\n    # strftime(\"%c\", ...) is locale specific.\n\n\n    def ctime(self):\n        \"Return ctime() style string.\"\n        weekday = self.toordinal() % 7 or 7\n        return \"%s %s %2d 00:00:00 %04d\" % (\n            _DAYNAMES[weekday],\n            _MONTHNAMES[self._month],\n            self._day, self._year)\n\n    def strftime(self, fmt):\n        \"Format using strftime().\"\n        return _wrap_strftime(self, fmt, self.timetuple())\n\n    def __format__(self, fmt):\n        if not isinstance(fmt, str):\n            raise TypeError(\"must be str, not %s\" % type(fmt).__name__)\n        if len(fmt) != 0:\n            return self.strftime(fmt)\n        return str(self)\n\n    def isoformat(self):\n        \"\"\"Return the date formatted according to ISO.\n\n        This is 'YYYY-MM-DD'.\n\n        References:\n        - http://www.w3.org/TR/NOTE-datetime\n        - http://www.cl.cam.ac.uk/~mgk25/iso-time.html\n        \"\"\"\n        return \"%04d-%02d-%02d\" % (self._year, self._month, self._day)\n\n    __str__ = isoformat\n\n    # Read-only field accessors\n    @property\n    def year(self):\n        \"\"\"year (1-9999)\"\"\"\n        return self._year\n\n    @property\n    def month(self):\n        \"\"\"month (1-12)\"\"\"\n        return self._month\n\n    @property\n    def day(self):\n        \"\"\"day (1-31)\"\"\"\n        return self._day\n\n    # Standard conversions, __eq__, __le__, __lt__, __ge__, __gt__,\n    # __hash__ (and helpers)\n\n    def timetuple(self):\n        \"Return local time tuple compatible with time.localtime().\"\n        return _build_struct_time(self._year, self._month, self._day,\n                                  0, 0, 0, -1)\n\n    def toordinal(self):\n        \"\"\"Return proleptic Gregorian ordinal for the year, month and day.\n\n        January 1 of year 1 is day 1.  Only the year, month and day values\n        contribute to the result.\n        \"\"\"\n        return _ymd2ord(self._year, self._month, self._day)\n\n    def replace(self, year=None, month=None, day=None):\n        \"\"\"Return a new date with new values for the specified fields.\"\"\"\n        if year is None:\n            year = self._year\n        if month is None:\n            month = self._month\n        if day is None:\n            day = self._day\n        return type(self)(year, month, day)\n\n    # Comparisons of date objects with other.\n\n    def __eq__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) == 0\n        return NotImplemented\n\n    def __le__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) <= 0\n        return NotImplemented\n\n    def __lt__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) < 0\n        return NotImplemented\n\n    def __ge__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) >= 0\n        return NotImplemented\n\n    def __gt__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) > 0\n        return NotImplemented\n\n    def _cmp(self, other):\n        assert isinstance(other, date)\n        y, m, d = self._year, self._month, self._day\n        y2, m2, d2 = other._year, other._month, other._day\n        return _cmp((y, m, d), (y2, m2, d2))\n\n    def __hash__(self):\n        \"Hash.\"\n        if self._hashcode == -1:\n            self._hashcode = hash(self._getstate())\n        return self._hashcode\n\n    # Computations\n\n    def __add__(self, other):\n        \"Add a date to a timedelta.\"\n        if isinstance(other, timedelta):\n            o = self.toordinal() + other.days\n            if 0 < o <= _MAXORDINAL:\n                return type(self).fromordinal(o)\n            raise OverflowError(\"result out of range\")\n        return NotImplemented\n\n    __radd__ = __add__\n\n    def __sub__(self, other):\n        \"\"\"Subtract two dates, or a date and a timedelta.\"\"\"\n        if isinstance(other, timedelta):\n            return self + timedelta(-other.days)\n        if isinstance(other, date):\n            days1 = self.toordinal()\n            days2 = other.toordinal()\n            return timedelta(days1 - days2)\n        return NotImplemented\n\n    def weekday(self):\n        \"Return day of the week, where Monday == 0 ... Sunday == 6.\"\n        return (self.toordinal() + 6) % 7\n\n    # Day-of-the-week and week-of-the-year, according to ISO\n\n    def isoweekday(self):\n        \"Return day of the week, where Monday == 1 ... Sunday == 7.\"\n        # 1-Jan-0001 is a Monday\n        return self.toordinal() % 7 or 7\n\n    def isocalendar(self):\n        \"\"\"Return a named tuple containing ISO year, week number, and weekday.\n\n        The first ISO week of the year is the (Mon-Sun) week\n        containing the year's first Thursday; everything else derives\n        from that.\n\n        The first week is 1; Monday is 1 ... Sunday is 7.\n\n        ISO calendar algorithm taken from\n        http://www.phys.uu.nl/~vgent/calendar/isocalendar.htm\n        (used with permission)\n        \"\"\"\n        year = self._year\n        week1monday = _isoweek1monday(year)\n        today = _ymd2ord(self._year, self._month, self._day)\n        # Internally, week and day have origin 0\n        week, day = divmod(today - week1monday, 7)\n        if week < 0:\n            year -= 1\n            week1monday = _isoweek1monday(year)\n            week, day = divmod(today - week1monday, 7)\n        elif week >= 52:\n            if today >= _isoweek1monday(year+1):\n                year += 1\n                week = 0\n        return _IsoCalendarDate(year, week+1, day+1)\n\n    # Pickle support.\n\n    def _getstate(self):\n        yhi, ylo = divmod(self._year, 256)\n        return bytes([yhi, ylo, self._month, self._day]),\n\n    def __setstate(self, string):\n        yhi, ylo, self._month, self._day = string\n        self._year = yhi * 256 + ylo\n\n    def __reduce__(self):\n        return (self.__class__, self._getstate())"
    ],
    [
        "LOAD_NAME",
        "date"
    ],
    [
        "STORE_NAME",
        "_date_class"
    ],
    [
        "LOAD_NAME",
        "date"
    ],
    [
        "CALL",
        "date(1, 1, 1)"
    ],
    [
        "LOAD_NAME",
        "date"
    ],
    [
        "STORE_ATTR",
        "date.min"
    ],
    [
        "LOAD_NAME",
        "date"
    ],
    [
        "CALL",
        "date(9999, 12, 31)"
    ],
    [
        "LOAD_NAME",
        "date"
    ],
    [
        "STORE_ATTR",
        "date.max"
    ],
    [
        "LOAD_NAME",
        "timedelta"
    ],
    [
        "CALL",
        "timedelta(days=1)"
    ],
    [
        "LOAD_NAME",
        "date"
    ],
    [
        "STORE_ATTR",
        "date.resolution"
    ],
    [
        "CALL",
        "class tzinfo:\n    \"\"\"Abstract base class for time zone info classes.\n\n    Subclasses must override the name(), utcoffset() and dst() methods.\n    \"\"\"\n    __slots__ = ()\n\n    def tzname(self, dt):\n        \"datetime -> string name of time zone.\"\n        raise NotImplementedError(\"tzinfo subclass must override tzname()\")\n\n    def utcoffset(self, dt):\n        \"datetime -> timedelta, positive for east of UTC, negative for west of UTC\"\n        raise NotImplementedError(\"tzinfo subclass must override utcoffset()\")\n\n    def dst(self, dt):\n        \"\"\"datetime -> DST offset as timedelta, positive for east of UTC.\n\n        Return 0 if DST not in effect.  utcoffset() must include the DST\n        offset.\n        \"\"\"\n        raise NotImplementedError(\"tzinfo subclass must override dst()\")\n\n    def fromutc(self, dt):\n        \"datetime in UTC -> datetime in local time.\"\n\n        if not isinstance(dt, datetime):\n            raise TypeError(\"fromutc() requires a datetime argument\")\n        if dt.tzinfo is not self:\n            raise ValueError(\"dt.tzinfo is not self\")\n\n        dtoff = dt.utcoffset()\n        if dtoff is None:\n            raise ValueError(\"fromutc() requires a non-None utcoffset() \"\n                             \"result\")\n\n        # See the long comment block at the end of this file for an\n        # explanation of this algorithm.\n        dtdst = dt.dst()\n        if dtdst is None:\n            raise ValueError(\"fromutc() requires a non-None dst() result\")\n        delta = dtoff - dtdst\n        if delta:\n            dt += delta\n            dtdst = dt.dst()\n            if dtdst is None:\n                raise ValueError(\"fromutc(): dt.dst gave inconsistent \"\n                                 \"results; cannot convert\")\n        return dt + dtdst\n\n    # Pickle support.\n\n    def __reduce__(self):\n        getinitargs = getattr(self, \"__getinitargs__\", None)\n        if getinitargs:\n            args = getinitargs()\n        else:\n            args = ()\n        return (self.__class__, args, self.__getstate__())"
    ],
    [
        "STORE_NAME",
        "class tzinfo:\n    \"\"\"Abstract base class for time zone info classes.\n\n    Subclasses must override the name(), utcoffset() and dst() methods.\n    \"\"\"\n    __slots__ = ()\n\n    def tzname(self, dt):\n        \"datetime -> string name of time zone.\"\n        raise NotImplementedError(\"tzinfo subclass must override tzname()\")\n\n    def utcoffset(self, dt):\n        \"datetime -> timedelta, positive for east of UTC, negative for west of UTC\"\n        raise NotImplementedError(\"tzinfo subclass must override utcoffset()\")\n\n    def dst(self, dt):\n        \"\"\"datetime -> DST offset as timedelta, positive for east of UTC.\n\n        Return 0 if DST not in effect.  utcoffset() must include the DST\n        offset.\n        \"\"\"\n        raise NotImplementedError(\"tzinfo subclass must override dst()\")\n\n    def fromutc(self, dt):\n        \"datetime in UTC -> datetime in local time.\"\n\n        if not isinstance(dt, datetime):\n            raise TypeError(\"fromutc() requires a datetime argument\")\n        if dt.tzinfo is not self:\n            raise ValueError(\"dt.tzinfo is not self\")\n\n        dtoff = dt.utcoffset()\n        if dtoff is None:\n            raise ValueError(\"fromutc() requires a non-None utcoffset() \"\n                             \"result\")\n\n        # See the long comment block at the end of this file for an\n        # explanation of this algorithm.\n        dtdst = dt.dst()\n        if dtdst is None:\n            raise ValueError(\"fromutc() requires a non-None dst() result\")\n        delta = dtoff - dtdst\n        if delta:\n            dt += delta\n            dtdst = dt.dst()\n            if dtdst is None:\n                raise ValueError(\"fromutc(): dt.dst gave inconsistent \"\n                                 \"results; cannot convert\")\n        return dt + dtdst\n\n    # Pickle support.\n\n    def __reduce__(self):\n        getinitargs = getattr(self, \"__getinitargs__\", None)\n        if getinitargs:\n            args = getinitargs()\n        else:\n            args = ()\n        return (self.__class__, args, self.__getstate__())"
    ],
    [
        "LOAD_NAME",
        "tuple"
    ],
    [
        "CALL",
        "class IsoCalendarDate(tuple):\n\n    def __new__(cls, year, week, weekday, /):\n        return super().__new__(cls, (year, week, weekday))\n\n    @property\n    def year(self):\n        return self[0]\n\n    @property\n    def week(self):\n        return self[1]\n\n    @property\n    def weekday(self):\n        return self[2]\n\n    def __reduce__(self):\n        # This code is intended to pickle the object without making the\n        # class public. See https://bugs.python.org/msg352381\n        return (tuple, (tuple(self),))\n\n    def __repr__(self):\n        return (f'{self.__class__.__name__}'\n                f'(year={self[0]}, week={self[1]}, weekday={self[2]})')"
    ],
    [
        "STORE_NAME",
        "class IsoCalendarDate(tuple):\n\n    def __new__(cls, year, week, weekday, /):\n        return super().__new__(cls, (year, week, weekday))\n\n    @property\n    def year(self):\n        return self[0]\n\n    @property\n    def week(self):\n        return self[1]\n\n    @property\n    def weekday(self):\n        return self[2]\n\n    def __reduce__(self):\n        # This code is intended to pickle the object without making the\n        # class public. See https://bugs.python.org/msg352381\n        return (tuple, (tuple(self),))\n\n    def __repr__(self):\n        return (f'{self.__class__.__name__}'\n                f'(year={self[0]}, week={self[1]}, weekday={self[2]})')"
    ],
    [
        "LOAD_NAME",
        "IsoCalendarDate"
    ],
    [
        "STORE_NAME",
        "_IsoCalendarDate"
    ],
    [
        "DELETE_NAME",
        "IsoCalendarDate"
    ],
    [
        "LOAD_NAME",
        "tzinfo"
    ],
    [
        "STORE_NAME",
        "_tzinfo_class"
    ],
    [
        "CALL",
        "class time:\n    \"\"\"Time with time zone.\n\n    Constructors:\n\n    __new__()\n\n    Operators:\n\n    __repr__, __str__\n    __eq__, __le__, __lt__, __ge__, __gt__, __hash__\n\n    Methods:\n\n    strftime()\n    isoformat()\n    utcoffset()\n    tzname()\n    dst()\n\n    Properties (readonly):\n    hour, minute, second, microsecond, tzinfo, fold\n    \"\"\"\n    __slots__ = '_hour', '_minute', '_second', '_microsecond', '_tzinfo', '_hashcode', '_fold'\n\n    def __new__(cls, hour=0, minute=0, second=0, microsecond=0, tzinfo=None, *, fold=0):\n        \"\"\"Constructor.\n\n        Arguments:\n\n        hour, minute (required)\n        second, microsecond (default to zero)\n        tzinfo (default to None)\n        fold (keyword only, default to zero)\n        \"\"\"\n        if (isinstance(hour, (bytes, str)) and len(hour) == 6 and\n            ord(hour[0:1])&0x7F < 24):\n            # Pickle support\n            if isinstance(hour, str):\n                try:\n                    hour = hour.encode('latin1')\n                except UnicodeEncodeError:\n                    # More informative error message.\n                    raise ValueError(\n                        \"Failed to encode latin1 string when unpickling \"\n                        \"a time object. \"\n                        \"pickle.load(data, encoding='latin1') is assumed.\")\n            self = object.__new__(cls)\n            self.__setstate(hour, minute or None)\n            self._hashcode = -1\n            return self\n        hour, minute, second, microsecond, fold = _check_time_fields(\n            hour, minute, second, microsecond, fold)\n        _check_tzinfo_arg(tzinfo)\n        self = object.__new__(cls)\n        self._hour = hour\n        self._minute = minute\n        self._second = second\n        self._microsecond = microsecond\n        self._tzinfo = tzinfo\n        self._hashcode = -1\n        self._fold = fold\n        return self\n\n    # Read-only field accessors\n    @property\n    def hour(self):\n        \"\"\"hour (0-23)\"\"\"\n        return self._hour\n\n    @property\n    def minute(self):\n        \"\"\"minute (0-59)\"\"\"\n        return self._minute\n\n    @property\n    def second(self):\n        \"\"\"second (0-59)\"\"\"\n        return self._second\n\n    @property\n    def microsecond(self):\n        \"\"\"microsecond (0-999999)\"\"\"\n        return self._microsecond\n\n    @property\n    def tzinfo(self):\n        \"\"\"timezone info object\"\"\"\n        return self._tzinfo\n\n    @property\n    def fold(self):\n        return self._fold\n\n    # Standard conversions, __hash__ (and helpers)\n\n    # Comparisons of time objects with other.\n\n    def __eq__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other, allow_mixed=True) == 0\n        else:\n            return NotImplemented\n\n    def __le__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) <= 0\n        else:\n            return NotImplemented\n\n    def __lt__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) < 0\n        else:\n            return NotImplemented\n\n    def __ge__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) >= 0\n        else:\n            return NotImplemented\n\n    def __gt__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) > 0\n        else:\n            return NotImplemented\n\n    def _cmp(self, other, allow_mixed=False):\n        assert isinstance(other, time)\n        mytz = self._tzinfo\n        ottz = other._tzinfo\n        myoff = otoff = None\n\n        if mytz is ottz:\n            base_compare = True\n        else:\n            myoff = self.utcoffset()\n            otoff = other.utcoffset()\n            base_compare = myoff == otoff\n\n        if base_compare:\n            return _cmp((self._hour, self._minute, self._second,\n                         self._microsecond),\n                        (other._hour, other._minute, other._second,\n                         other._microsecond))\n        if myoff is None or otoff is None:\n            if allow_mixed:\n                return 2 # arbitrary non-zero value\n            else:\n                raise TypeError(\"cannot compare naive and aware times\")\n        myhhmm = self._hour * 60 + self._minute - myoff//timedelta(minutes=1)\n        othhmm = other._hour * 60 + other._minute - otoff//timedelta(minutes=1)\n        return _cmp((myhhmm, self._second, self._microsecond),\n                    (othhmm, other._second, other._microsecond))\n\n    def __hash__(self):\n        \"\"\"Hash.\"\"\"\n        if self._hashcode == -1:\n            if self.fold:\n                t = self.replace(fold=0)\n            else:\n                t = self\n            tzoff = t.utcoffset()\n            if not tzoff:  # zero or None\n                self._hashcode = hash(t._getstate()[0])\n            else:\n                h, m = divmod(timedelta(hours=self.hour, minutes=self.minute) - tzoff,\n                              timedelta(hours=1))\n                assert not m % timedelta(minutes=1), \"whole minute\"\n                m //= timedelta(minutes=1)\n                if 0 <= h < 24:\n                    self._hashcode = hash(time(h, m, self.second, self.microsecond))\n                else:\n                    self._hashcode = hash((h, m, self.second, self.microsecond))\n        return self._hashcode\n\n    # Conversion to string\n\n    def _tzstr(self):\n        \"\"\"Return formatted timezone offset (+xx:xx) or an empty string.\"\"\"\n        off = self.utcoffset()\n        return _format_offset(off)\n\n    def __repr__(self):\n        \"\"\"Convert to formal string, for repr().\"\"\"\n        if self._microsecond != 0:\n            s = \", %d, %d\" % (self._second, self._microsecond)\n        elif self._second != 0:\n            s = \", %d\" % self._second\n        else:\n            s = \"\"\n        s= \"%s.%s(%d, %d%s)\" % (self.__class__.__module__,\n                                self.__class__.__qualname__,\n                                self._hour, self._minute, s)\n        if self._tzinfo is not None:\n            assert s[-1:] == \")\"\n            s = s[:-1] + \", tzinfo=%r\" % self._tzinfo + \")\"\n        if self._fold:\n            assert s[-1:] == \")\"\n            s = s[:-1] + \", fold=1)\"\n        return s\n\n    def isoformat(self, timespec='auto'):\n        \"\"\"Return the time formatted according to ISO.\n\n        The full format is 'HH:MM:SS.mmmmmm+zz:zz'. By default, the fractional\n        part is omitted if self.microsecond == 0.\n\n        The optional argument timespec specifies the number of additional\n        terms of the time to include. Valid options are 'auto', 'hours',\n        'minutes', 'seconds', 'milliseconds' and 'microseconds'.\n        \"\"\"\n        s = _format_time(self._hour, self._minute, self._second,\n                          self._microsecond, timespec)\n        tz = self._tzstr()\n        if tz:\n            s += tz\n        return s\n\n    __str__ = isoformat\n\n    @classmethod\n    def fromisoformat(cls, time_string):\n        \"\"\"Construct a time from a string in one of the ISO 8601 formats.\"\"\"\n        if not isinstance(time_string, str):\n            raise TypeError('fromisoformat: argument must be str')\n\n        # The spec actually requires that time-only ISO 8601 strings start with\n        # T, but the extended format allows this to be omitted as long as there\n        # is no ambiguity with date strings.\n        time_string = time_string.removeprefix('T')\n\n        try:\n            return cls(*_parse_isoformat_time(time_string))\n        except Exception:\n            raise ValueError(f'Invalid isoformat string: {time_string!r}')\n\n\n    def strftime(self, fmt):\n        \"\"\"Format using strftime().  The date part of the timestamp passed\n        to underlying strftime should not be used.\n        \"\"\"\n        # The year must be >= 1000 else Python's strftime implementation\n        # can raise a bogus exception.\n        timetuple = (1900, 1, 1,\n                     self._hour, self._minute, self._second,\n                     0, 1, -1)\n        return _wrap_strftime(self, fmt, timetuple)\n\n    def __format__(self, fmt):\n        if not isinstance(fmt, str):\n            raise TypeError(\"must be str, not %s\" % type(fmt).__name__)\n        if len(fmt) != 0:\n            return self.strftime(fmt)\n        return str(self)\n\n    # Timezone functions\n\n    def utcoffset(self):\n        \"\"\"Return the timezone offset as timedelta, positive east of UTC\n         (negative west of UTC).\"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.utcoffset(None)\n        _check_utc_offset(\"utcoffset\", offset)\n        return offset\n\n    def tzname(self):\n        \"\"\"Return the timezone name.\n\n        Note that the name is 100% informational -- there's no requirement that\n        it mean anything in particular. For example, \"GMT\", \"UTC\", \"-500\",\n        \"-5:00\", \"EDT\", \"US/Eastern\", \"America/New York\" are all valid replies.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        name = self._tzinfo.tzname(None)\n        _check_tzname(name)\n        return name\n\n    def dst(self):\n        \"\"\"Return 0 if DST is not in effect, or the DST offset (as timedelta\n        positive eastward) if DST is in effect.\n\n        This is purely informational; the DST offset has already been added to\n        the UTC offset returned by utcoffset() if applicable, so there's no\n        need to consult dst() unless you're interested in displaying the DST\n        info.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.dst(None)\n        _check_utc_offset(\"dst\", offset)\n        return offset\n\n    def replace(self, hour=None, minute=None, second=None, microsecond=None,\n                tzinfo=True, *, fold=None):\n        \"\"\"Return a new time with new values for the specified fields.\"\"\"\n        if hour is None:\n            hour = self.hour\n        if minute is None:\n            minute = self.minute\n        if second is None:\n            second = self.second\n        if microsecond is None:\n            microsecond = self.microsecond\n        if tzinfo is True:\n            tzinfo = self.tzinfo\n        if fold is None:\n            fold = self._fold\n        return type(self)(hour, minute, second, microsecond, tzinfo, fold=fold)\n\n    # Pickle support.\n\n    def _getstate(self, protocol=3):\n        us2, us3 = divmod(self._microsecond, 256)\n        us1, us2 = divmod(us2, 256)\n        h = self._hour\n        if self._fold and protocol > 3:\n            h += 128\n        basestate = bytes([h, self._minute, self._second,\n                           us1, us2, us3])\n        if self._tzinfo is None:\n            return (basestate,)\n        else:\n            return (basestate, self._tzinfo)\n\n    def __setstate(self, string, tzinfo):\n        if tzinfo is not None and not isinstance(tzinfo, _tzinfo_class):\n            raise TypeError(\"bad tzinfo state arg\")\n        h, self._minute, self._second, us1, us2, us3 = string\n        if h > 127:\n            self._fold = 1\n            self._hour = h - 128\n        else:\n            self._fold = 0\n            self._hour = h\n        self._microsecond = (((us1 << 8) | us2) << 8) | us3\n        self._tzinfo = tzinfo\n\n    def __reduce_ex__(self, protocol):\n        return (self.__class__, self._getstate(protocol))\n\n    def __reduce__(self):\n        return self.__reduce_ex__(2)"
    ],
    [
        "STORE_NAME",
        "class time:\n    \"\"\"Time with time zone.\n\n    Constructors:\n\n    __new__()\n\n    Operators:\n\n    __repr__, __str__\n    __eq__, __le__, __lt__, __ge__, __gt__, __hash__\n\n    Methods:\n\n    strftime()\n    isoformat()\n    utcoffset()\n    tzname()\n    dst()\n\n    Properties (readonly):\n    hour, minute, second, microsecond, tzinfo, fold\n    \"\"\"\n    __slots__ = '_hour', '_minute', '_second', '_microsecond', '_tzinfo', '_hashcode', '_fold'\n\n    def __new__(cls, hour=0, minute=0, second=0, microsecond=0, tzinfo=None, *, fold=0):\n        \"\"\"Constructor.\n\n        Arguments:\n\n        hour, minute (required)\n        second, microsecond (default to zero)\n        tzinfo (default to None)\n        fold (keyword only, default to zero)\n        \"\"\"\n        if (isinstance(hour, (bytes, str)) and len(hour) == 6 and\n            ord(hour[0:1])&0x7F < 24):\n            # Pickle support\n            if isinstance(hour, str):\n                try:\n                    hour = hour.encode('latin1')\n                except UnicodeEncodeError:\n                    # More informative error message.\n                    raise ValueError(\n                        \"Failed to encode latin1 string when unpickling \"\n                        \"a time object. \"\n                        \"pickle.load(data, encoding='latin1') is assumed.\")\n            self = object.__new__(cls)\n            self.__setstate(hour, minute or None)\n            self._hashcode = -1\n            return self\n        hour, minute, second, microsecond, fold = _check_time_fields(\n            hour, minute, second, microsecond, fold)\n        _check_tzinfo_arg(tzinfo)\n        self = object.__new__(cls)\n        self._hour = hour\n        self._minute = minute\n        self._second = second\n        self._microsecond = microsecond\n        self._tzinfo = tzinfo\n        self._hashcode = -1\n        self._fold = fold\n        return self\n\n    # Read-only field accessors\n    @property\n    def hour(self):\n        \"\"\"hour (0-23)\"\"\"\n        return self._hour\n\n    @property\n    def minute(self):\n        \"\"\"minute (0-59)\"\"\"\n        return self._minute\n\n    @property\n    def second(self):\n        \"\"\"second (0-59)\"\"\"\n        return self._second\n\n    @property\n    def microsecond(self):\n        \"\"\"microsecond (0-999999)\"\"\"\n        return self._microsecond\n\n    @property\n    def tzinfo(self):\n        \"\"\"timezone info object\"\"\"\n        return self._tzinfo\n\n    @property\n    def fold(self):\n        return self._fold\n\n    # Standard conversions, __hash__ (and helpers)\n\n    # Comparisons of time objects with other.\n\n    def __eq__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other, allow_mixed=True) == 0\n        else:\n            return NotImplemented\n\n    def __le__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) <= 0\n        else:\n            return NotImplemented\n\n    def __lt__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) < 0\n        else:\n            return NotImplemented\n\n    def __ge__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) >= 0\n        else:\n            return NotImplemented\n\n    def __gt__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) > 0\n        else:\n            return NotImplemented\n\n    def _cmp(self, other, allow_mixed=False):\n        assert isinstance(other, time)\n        mytz = self._tzinfo\n        ottz = other._tzinfo\n        myoff = otoff = None\n\n        if mytz is ottz:\n            base_compare = True\n        else:\n            myoff = self.utcoffset()\n            otoff = other.utcoffset()\n            base_compare = myoff == otoff\n\n        if base_compare:\n            return _cmp((self._hour, self._minute, self._second,\n                         self._microsecond),\n                        (other._hour, other._minute, other._second,\n                         other._microsecond))\n        if myoff is None or otoff is None:\n            if allow_mixed:\n                return 2 # arbitrary non-zero value\n            else:\n                raise TypeError(\"cannot compare naive and aware times\")\n        myhhmm = self._hour * 60 + self._minute - myoff//timedelta(minutes=1)\n        othhmm = other._hour * 60 + other._minute - otoff//timedelta(minutes=1)\n        return _cmp((myhhmm, self._second, self._microsecond),\n                    (othhmm, other._second, other._microsecond))\n\n    def __hash__(self):\n        \"\"\"Hash.\"\"\"\n        if self._hashcode == -1:\n            if self.fold:\n                t = self.replace(fold=0)\n            else:\n                t = self\n            tzoff = t.utcoffset()\n            if not tzoff:  # zero or None\n                self._hashcode = hash(t._getstate()[0])\n            else:\n                h, m = divmod(timedelta(hours=self.hour, minutes=self.minute) - tzoff,\n                              timedelta(hours=1))\n                assert not m % timedelta(minutes=1), \"whole minute\"\n                m //= timedelta(minutes=1)\n                if 0 <= h < 24:\n                    self._hashcode = hash(time(h, m, self.second, self.microsecond))\n                else:\n                    self._hashcode = hash((h, m, self.second, self.microsecond))\n        return self._hashcode\n\n    # Conversion to string\n\n    def _tzstr(self):\n        \"\"\"Return formatted timezone offset (+xx:xx) or an empty string.\"\"\"\n        off = self.utcoffset()\n        return _format_offset(off)\n\n    def __repr__(self):\n        \"\"\"Convert to formal string, for repr().\"\"\"\n        if self._microsecond != 0:\n            s = \", %d, %d\" % (self._second, self._microsecond)\n        elif self._second != 0:\n            s = \", %d\" % self._second\n        else:\n            s = \"\"\n        s= \"%s.%s(%d, %d%s)\" % (self.__class__.__module__,\n                                self.__class__.__qualname__,\n                                self._hour, self._minute, s)\n        if self._tzinfo is not None:\n            assert s[-1:] == \")\"\n            s = s[:-1] + \", tzinfo=%r\" % self._tzinfo + \")\"\n        if self._fold:\n            assert s[-1:] == \")\"\n            s = s[:-1] + \", fold=1)\"\n        return s\n\n    def isoformat(self, timespec='auto'):\n        \"\"\"Return the time formatted according to ISO.\n\n        The full format is 'HH:MM:SS.mmmmmm+zz:zz'. By default, the fractional\n        part is omitted if self.microsecond == 0.\n\n        The optional argument timespec specifies the number of additional\n        terms of the time to include. Valid options are 'auto', 'hours',\n        'minutes', 'seconds', 'milliseconds' and 'microseconds'.\n        \"\"\"\n        s = _format_time(self._hour, self._minute, self._second,\n                          self._microsecond, timespec)\n        tz = self._tzstr()\n        if tz:\n            s += tz\n        return s\n\n    __str__ = isoformat\n\n    @classmethod\n    def fromisoformat(cls, time_string):\n        \"\"\"Construct a time from a string in one of the ISO 8601 formats.\"\"\"\n        if not isinstance(time_string, str):\n            raise TypeError('fromisoformat: argument must be str')\n\n        # The spec actually requires that time-only ISO 8601 strings start with\n        # T, but the extended format allows this to be omitted as long as there\n        # is no ambiguity with date strings.\n        time_string = time_string.removeprefix('T')\n\n        try:\n            return cls(*_parse_isoformat_time(time_string))\n        except Exception:\n            raise ValueError(f'Invalid isoformat string: {time_string!r}')\n\n\n    def strftime(self, fmt):\n        \"\"\"Format using strftime().  The date part of the timestamp passed\n        to underlying strftime should not be used.\n        \"\"\"\n        # The year must be >= 1000 else Python's strftime implementation\n        # can raise a bogus exception.\n        timetuple = (1900, 1, 1,\n                     self._hour, self._minute, self._second,\n                     0, 1, -1)\n        return _wrap_strftime(self, fmt, timetuple)\n\n    def __format__(self, fmt):\n        if not isinstance(fmt, str):\n            raise TypeError(\"must be str, not %s\" % type(fmt).__name__)\n        if len(fmt) != 0:\n            return self.strftime(fmt)\n        return str(self)\n\n    # Timezone functions\n\n    def utcoffset(self):\n        \"\"\"Return the timezone offset as timedelta, positive east of UTC\n         (negative west of UTC).\"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.utcoffset(None)\n        _check_utc_offset(\"utcoffset\", offset)\n        return offset\n\n    def tzname(self):\n        \"\"\"Return the timezone name.\n\n        Note that the name is 100% informational -- there's no requirement that\n        it mean anything in particular. For example, \"GMT\", \"UTC\", \"-500\",\n        \"-5:00\", \"EDT\", \"US/Eastern\", \"America/New York\" are all valid replies.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        name = self._tzinfo.tzname(None)\n        _check_tzname(name)\n        return name\n\n    def dst(self):\n        \"\"\"Return 0 if DST is not in effect, or the DST offset (as timedelta\n        positive eastward) if DST is in effect.\n\n        This is purely informational; the DST offset has already been added to\n        the UTC offset returned by utcoffset() if applicable, so there's no\n        need to consult dst() unless you're interested in displaying the DST\n        info.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.dst(None)\n        _check_utc_offset(\"dst\", offset)\n        return offset\n\n    def replace(self, hour=None, minute=None, second=None, microsecond=None,\n                tzinfo=True, *, fold=None):\n        \"\"\"Return a new time with new values for the specified fields.\"\"\"\n        if hour is None:\n            hour = self.hour\n        if minute is None:\n            minute = self.minute\n        if second is None:\n            second = self.second\n        if microsecond is None:\n            microsecond = self.microsecond\n        if tzinfo is True:\n            tzinfo = self.tzinfo\n        if fold is None:\n            fold = self._fold\n        return type(self)(hour, minute, second, microsecond, tzinfo, fold=fold)\n\n    # Pickle support.\n\n    def _getstate(self, protocol=3):\n        us2, us3 = divmod(self._microsecond, 256)\n        us1, us2 = divmod(us2, 256)\n        h = self._hour\n        if self._fold and protocol > 3:\n            h += 128\n        basestate = bytes([h, self._minute, self._second,\n                           us1, us2, us3])\n        if self._tzinfo is None:\n            return (basestate,)\n        else:\n            return (basestate, self._tzinfo)\n\n    def __setstate(self, string, tzinfo):\n        if tzinfo is not None and not isinstance(tzinfo, _tzinfo_class):\n            raise TypeError(\"bad tzinfo state arg\")\n        h, self._minute, self._second, us1, us2, us3 = string\n        if h > 127:\n            self._fold = 1\n            self._hour = h - 128\n        else:\n            self._fold = 0\n            self._hour = h\n        self._microsecond = (((us1 << 8) | us2) << 8) | us3\n        self._tzinfo = tzinfo\n\n    def __reduce_ex__(self, protocol):\n        return (self.__class__, self._getstate(protocol))\n\n    def __reduce__(self):\n        return self.__reduce_ex__(2)"
    ],
    [
        "LOAD_NAME",
        "time"
    ],
    [
        "STORE_NAME",
        "_time_class"
    ],
    [
        "LOAD_NAME",
        "time"
    ],
    [
        "CALL",
        "time(0, 0, 0)"
    ],
    [
        "LOAD_NAME",
        "time"
    ],
    [
        "STORE_ATTR",
        "time.min"
    ],
    [
        "LOAD_NAME",
        "time"
    ],
    [
        "CALL",
        "time(23, 59, 59, 999999)"
    ],
    [
        "LOAD_NAME",
        "time"
    ],
    [
        "STORE_ATTR",
        "time.max"
    ],
    [
        "LOAD_NAME",
        "timedelta"
    ],
    [
        "CALL",
        "timedelta(microseconds=1)"
    ],
    [
        "LOAD_NAME",
        "time"
    ],
    [
        "STORE_ATTR",
        "time.resolution"
    ],
    [
        "LOAD_NAME",
        "date"
    ],
    [
        "CALL",
        "class datetime(date):\n    \"\"\"datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])\n\n    The year, month and day arguments are required. tzinfo may be None, or an\n    instance of a tzinfo subclass. The remaining arguments may be ints.\n    \"\"\"\n    __slots__ = date.__slots__ + time.__slots__\n\n    def __new__(cls, year, month=None, day=None, hour=0, minute=0, second=0,\n                microsecond=0, tzinfo=None, *, fold=0):\n        if (isinstance(year, (bytes, str)) and len(year) == 10 and\n            1 <= ord(year[2:3])&0x7F <= 12):\n            # Pickle support\n            if isinstance(year, str):\n                try:\n                    year = bytes(year, 'latin1')\n                except UnicodeEncodeError:\n                    # More informative error message.\n                    raise ValueError(\n                        \"Failed to encode latin1 string when unpickling \"\n                        \"a datetime object. \"\n                        \"pickle.load(data, encoding='latin1') is assumed.\")\n            self = object.__new__(cls)\n            self.__setstate(year, month)\n            self._hashcode = -1\n            return self\n        year, month, day = _check_date_fields(year, month, day)\n        hour, minute, second, microsecond, fold = _check_time_fields(\n            hour, minute, second, microsecond, fold)\n        _check_tzinfo_arg(tzinfo)\n        self = object.__new__(cls)\n        self._year = year\n        self._month = month\n        self._day = day\n        self._hour = hour\n        self._minute = minute\n        self._second = second\n        self._microsecond = microsecond\n        self._tzinfo = tzinfo\n        self._hashcode = -1\n        self._fold = fold\n        return self\n\n    # Read-only field accessors\n    @property\n    def hour(self):\n        \"\"\"hour (0-23)\"\"\"\n        return self._hour\n\n    @property\n    def minute(self):\n        \"\"\"minute (0-59)\"\"\"\n        return self._minute\n\n    @property\n    def second(self):\n        \"\"\"second (0-59)\"\"\"\n        return self._second\n\n    @property\n    def microsecond(self):\n        \"\"\"microsecond (0-999999)\"\"\"\n        return self._microsecond\n\n    @property\n    def tzinfo(self):\n        \"\"\"timezone info object\"\"\"\n        return self._tzinfo\n\n    @property\n    def fold(self):\n        return self._fold\n\n    @classmethod\n    def _fromtimestamp(cls, t, utc, tz):\n        \"\"\"Construct a datetime from a POSIX timestamp (like time.time()).\n\n        A timezone info object may be passed in as well.\n        \"\"\"\n        frac, t = _math.modf(t)\n        us = round(frac * 1e6)\n        if us >= 1000000:\n            t += 1\n            us -= 1000000\n        elif us < 0:\n            t -= 1\n            us += 1000000\n\n        converter = _time.gmtime if utc else _time.localtime\n        y, m, d, hh, mm, ss, weekday, jday, dst = converter(t)\n        ss = min(ss, 59)    # clamp out leap seconds if the platform has them\n        result = cls(y, m, d, hh, mm, ss, us, tz)\n        if tz is None and not utc:\n            # As of version 2015f max fold in IANA database is\n            # 23 hours at 1969-09-30 13:00:00 in Kwajalein.\n            # Let's probe 24 hours in the past to detect a transition:\n            max_fold_seconds = 24 * 3600\n\n            # On Windows localtime_s throws an OSError for negative values,\n            # thus we can't perform fold detection for values of time less\n            # than the max time fold. See comments in _datetimemodule's\n            # version of this method for more details.\n            if t < max_fold_seconds and sys.platform.startswith(\"win\"):\n                return result\n\n            y, m, d, hh, mm, ss = converter(t - max_fold_seconds)[:6]\n            probe1 = cls(y, m, d, hh, mm, ss, us, tz)\n            trans = result - probe1 - timedelta(0, max_fold_seconds)\n            if trans.days < 0:\n                y, m, d, hh, mm, ss = converter(t + trans // timedelta(0, 1))[:6]\n                probe2 = cls(y, m, d, hh, mm, ss, us, tz)\n                if probe2 == result:\n                    result._fold = 1\n        elif tz is not None:\n            result = tz.fromutc(result)\n        return result\n\n    @classmethod\n    def fromtimestamp(cls, t, tz=None):\n        \"\"\"Construct a datetime from a POSIX timestamp (like time.time()).\n\n        A timezone info object may be passed in as well.\n        \"\"\"\n        _check_tzinfo_arg(tz)\n\n        return cls._fromtimestamp(t, tz is not None, tz)\n\n    @classmethod\n    def utcfromtimestamp(cls, t):\n        \"\"\"Construct a naive UTC datetime from a POSIX timestamp.\"\"\"\n        return cls._fromtimestamp(t, True, None)\n\n    @classmethod\n    def now(cls, tz=None):\n        \"Construct a datetime from time.time() and optional time zone info.\"\n        t = _time.time()\n        return cls.fromtimestamp(t, tz)\n\n    @classmethod\n    def utcnow(cls):\n        \"Construct a UTC datetime from time.time().\"\n        t = _time.time()\n        return cls.utcfromtimestamp(t)\n\n    @classmethod\n    def combine(cls, date, time, tzinfo=True):\n        \"Construct a datetime from a given date and a given time.\"\n        if not isinstance(date, _date_class):\n            raise TypeError(\"date argument must be a date instance\")\n        if not isinstance(time, _time_class):\n            raise TypeError(\"time argument must be a time instance\")\n        if tzinfo is True:\n            tzinfo = time.tzinfo\n        return cls(date.year, date.month, date.day,\n                   time.hour, time.minute, time.second, time.microsecond,\n                   tzinfo, fold=time.fold)\n\n    @classmethod\n    def fromisoformat(cls, date_string):\n        \"\"\"Construct a datetime from a string in one of the ISO 8601 formats.\"\"\"\n        if not isinstance(date_string, str):\n            raise TypeError('fromisoformat: argument must be str')\n\n        if len(date_string) < 7:\n            raise ValueError(f'Invalid isoformat string: {date_string!r}')\n\n        # Split this at the separator\n        try:\n            separator_location = _find_isoformat_datetime_separator(date_string)\n            dstr = date_string[0:separator_location]\n            tstr = date_string[(separator_location+1):]\n\n            date_components = _parse_isoformat_date(dstr)\n        except ValueError:\n            raise ValueError(\n                f'Invalid isoformat string: {date_string!r}') from None\n\n        if tstr:\n            try:\n                time_components = _parse_isoformat_time(tstr)\n            except ValueError:\n                raise ValueError(\n                    f'Invalid isoformat string: {date_string!r}') from None\n        else:\n            time_components = [0, 0, 0, 0, None]\n\n        return cls(*(date_components + time_components))\n\n    def timetuple(self):\n        \"Return local time tuple compatible with time.localtime().\"\n        dst = self.dst()\n        if dst is None:\n            dst = -1\n        elif dst:\n            dst = 1\n        else:\n            dst = 0\n        return _build_struct_time(self.year, self.month, self.day,\n                                  self.hour, self.minute, self.second,\n                                  dst)\n\n    def _mktime(self):\n        \"\"\"Return integer POSIX timestamp.\"\"\"\n        epoch = datetime(1970, 1, 1)\n        max_fold_seconds = 24 * 3600\n        t = (self - epoch) // timedelta(0, 1)\n        def local(u):\n            y, m, d, hh, mm, ss = _time.localtime(u)[:6]\n            return (datetime(y, m, d, hh, mm, ss) - epoch) // timedelta(0, 1)\n\n        # Our goal is to solve t = local(u) for u.\n        a = local(t) - t\n        u1 = t - a\n        t1 = local(u1)\n        if t1 == t:\n            # We found one solution, but it may not be the one we need.\n            # Look for an earlier solution (if `fold` is 0), or a\n            # later one (if `fold` is 1).\n            u2 = u1 + (-max_fold_seconds, max_fold_seconds)[self.fold]\n            b = local(u2) - u2\n            if a == b:\n                return u1\n        else:\n            b = t1 - u1\n            assert a != b\n        u2 = t - b\n        t2 = local(u2)\n        if t2 == t:\n            return u2\n        if t1 == t:\n            return u1\n        # We have found both offsets a and b, but neither t - a nor t - b is\n        # a solution.  This means t is in the gap.\n        return (max, min)[self.fold](u1, u2)\n\n\n    def timestamp(self):\n        \"Return POSIX timestamp as float\"\n        if self._tzinfo is None:\n            s = self._mktime()\n            return s + self.microsecond / 1e6\n        else:\n            return (self - _EPOCH).total_seconds()\n\n    def utctimetuple(self):\n        \"Return UTC time tuple compatible with time.gmtime().\"\n        offset = self.utcoffset()\n        if offset:\n            self -= offset\n        y, m, d = self.year, self.month, self.day\n        hh, mm, ss = self.hour, self.minute, self.second\n        return _build_struct_time(y, m, d, hh, mm, ss, 0)\n\n    def date(self):\n        \"Return the date part.\"\n        return date(self._year, self._month, self._day)\n\n    def time(self):\n        \"Return the time part, with tzinfo None.\"\n        return time(self.hour, self.minute, self.second, self.microsecond, fold=self.fold)\n\n    def timetz(self):\n        \"Return the time part, with same tzinfo.\"\n        return time(self.hour, self.minute, self.second, self.microsecond,\n                    self._tzinfo, fold=self.fold)\n\n    def replace(self, year=None, month=None, day=None, hour=None,\n                minute=None, second=None, microsecond=None, tzinfo=True,\n                *, fold=None):\n        \"\"\"Return a new datetime with new values for the specified fields.\"\"\"\n        if year is None:\n            year = self.year\n        if month is None:\n            month = self.month\n        if day is None:\n            day = self.day\n        if hour is None:\n            hour = self.hour\n        if minute is None:\n            minute = self.minute\n        if second is None:\n            second = self.second\n        if microsecond is None:\n            microsecond = self.microsecond\n        if tzinfo is True:\n            tzinfo = self.tzinfo\n        if fold is None:\n            fold = self.fold\n        return type(self)(year, month, day, hour, minute, second,\n                          microsecond, tzinfo, fold=fold)\n\n    def _local_timezone(self):\n        if self.tzinfo is None:\n            ts = self._mktime()\n        else:\n            ts = (self - _EPOCH) // timedelta(seconds=1)\n        localtm = _time.localtime(ts)\n        local = datetime(*localtm[:6])\n        # Extract TZ data\n        gmtoff = localtm.tm_gmtoff\n        zone = localtm.tm_zone\n        return timezone(timedelta(seconds=gmtoff), zone)\n\n    def astimezone(self, tz=None):\n        if tz is None:\n            tz = self._local_timezone()\n        elif not isinstance(tz, tzinfo):\n            raise TypeError(\"tz argument must be an instance of tzinfo\")\n\n        mytz = self.tzinfo\n        if mytz is None:\n            mytz = self._local_timezone()\n            myoffset = mytz.utcoffset(self)\n        else:\n            myoffset = mytz.utcoffset(self)\n            if myoffset is None:\n                mytz = self.replace(tzinfo=None)._local_timezone()\n                myoffset = mytz.utcoffset(self)\n\n        if tz is mytz:\n            return self\n\n        # Convert self to UTC, and attach the new time zone object.\n        utc = (self - myoffset).replace(tzinfo=tz)\n\n        # Convert from UTC to tz's local time.\n        return tz.fromutc(utc)\n\n    # Ways to produce a string.\n\n    def ctime(self):\n        \"Return ctime() style string.\"\n        weekday = self.toordinal() % 7 or 7\n        return \"%s %s %2d %02d:%02d:%02d %04d\" % (\n            _DAYNAMES[weekday],\n            _MONTHNAMES[self._month],\n            self._day,\n            self._hour, self._minute, self._second,\n            self._year)\n\n    def isoformat(self, sep='T', timespec='auto'):\n        \"\"\"Return the time formatted according to ISO.\n\n        The full format looks like 'YYYY-MM-DD HH:MM:SS.mmmmmm'.\n        By default, the fractional part is omitted if self.microsecond == 0.\n\n        If self.tzinfo is not None, the UTC offset is also attached, giving\n        giving a full format of 'YYYY-MM-DD HH:MM:SS.mmmmmm+HH:MM'.\n\n        Optional argument sep specifies the separator between date and\n        time, default 'T'.\n\n        The optional argument timespec specifies the number of additional\n        terms of the time to include. Valid options are 'auto', 'hours',\n        'minutes', 'seconds', 'milliseconds' and 'microseconds'.\n        \"\"\"\n        s = (\"%04d-%02d-%02d%c\" % (self._year, self._month, self._day, sep) +\n             _format_time(self._hour, self._minute, self._second,\n                          self._microsecond, timespec))\n\n        off = self.utcoffset()\n        tz = _format_offset(off)\n        if tz:\n            s += tz\n\n        return s\n\n    def __repr__(self):\n        \"\"\"Convert to formal string, for repr().\"\"\"\n        L = [self._year, self._month, self._day,  # These are never zero\n             self._hour, self._minute, self._second, self._microsecond]\n        if L[-1] == 0:\n            del L[-1]\n        if L[-1] == 0:\n            del L[-1]\n        s = \"%s.%s(%s)\" % (self.__class__.__module__,\n                           self.__class__.__qualname__,\n                           \", \".join(map(str, L)))\n        if self._tzinfo is not None:\n            assert s[-1:] == \")\"\n            s = s[:-1] + \", tzinfo=%r\" % self._tzinfo + \")\"\n        if self._fold:\n            assert s[-1:] == \")\"\n            s = s[:-1] + \", fold=1)\"\n        return s\n\n    def __str__(self):\n        \"Convert to string, for str().\"\n        return self.isoformat(sep=' ')\n\n    @classmethod\n    def strptime(cls, date_string, format):\n        'string, format -> new datetime parsed from a string (like time.strptime()).'\n        import _strptime\n        return _strptime._strptime_datetime(cls, date_string, format)\n\n    def utcoffset(self):\n        \"\"\"Return the timezone offset as timedelta positive east of UTC (negative west of\n        UTC).\"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.utcoffset(self)\n        _check_utc_offset(\"utcoffset\", offset)\n        return offset\n\n    def tzname(self):\n        \"\"\"Return the timezone name.\n\n        Note that the name is 100% informational -- there's no requirement that\n        it mean anything in particular. For example, \"GMT\", \"UTC\", \"-500\",\n        \"-5:00\", \"EDT\", \"US/Eastern\", \"America/New York\" are all valid replies.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        name = self._tzinfo.tzname(self)\n        _check_tzname(name)\n        return name\n\n    def dst(self):\n        \"\"\"Return 0 if DST is not in effect, or the DST offset (as timedelta\n        positive eastward) if DST is in effect.\n\n        This is purely informational; the DST offset has already been added to\n        the UTC offset returned by utcoffset() if applicable, so there's no\n        need to consult dst() unless you're interested in displaying the DST\n        info.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.dst(self)\n        _check_utc_offset(\"dst\", offset)\n        return offset\n\n    # Comparisons of datetime objects with other.\n\n    def __eq__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other, allow_mixed=True) == 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            return False\n\n    def __le__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) <= 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def __lt__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) < 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def __ge__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) >= 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def __gt__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) > 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def _cmp(self, other, allow_mixed=False):\n        assert isinstance(other, datetime)\n        mytz = self._tzinfo\n        ottz = other._tzinfo\n        myoff = otoff = None\n\n        if mytz is ottz:\n            base_compare = True\n        else:\n            myoff = self.utcoffset()\n            otoff = other.utcoffset()\n            # Assume that allow_mixed means that we are called from __eq__\n            if allow_mixed:\n                if myoff != self.replace(fold=not self.fold).utcoffset():\n                    return 2\n                if otoff != other.replace(fold=not other.fold).utcoffset():\n                    return 2\n            base_compare = myoff == otoff\n\n        if base_compare:\n            return _cmp((self._year, self._month, self._day,\n                         self._hour, self._minute, self._second,\n                         self._microsecond),\n                        (other._year, other._month, other._day,\n                         other._hour, other._minute, other._second,\n                         other._microsecond))\n        if myoff is None or otoff is None:\n            if allow_mixed:\n                return 2 # arbitrary non-zero value\n            else:\n                raise TypeError(\"cannot compare naive and aware datetimes\")\n        # XXX What follows could be done more efficiently...\n        diff = self - other     # this will take offsets into account\n        if diff.days < 0:\n            return -1\n        return diff and 1 or 0\n\n    def __add__(self, other):\n        \"Add a datetime and a timedelta.\"\n        if not isinstance(other, timedelta):\n            return NotImplemented\n        delta = timedelta(self.toordinal(),\n                          hours=self._hour,\n                          minutes=self._minute,\n                          seconds=self._second,\n                          microseconds=self._microsecond)\n        delta += other\n        hour, rem = divmod(delta.seconds, 3600)\n        minute, second = divmod(rem, 60)\n        if 0 < delta.days <= _MAXORDINAL:\n            return type(self).combine(date.fromordinal(delta.days),\n                                      time(hour, minute, second,\n                                           delta.microseconds,\n                                           tzinfo=self._tzinfo))\n        raise OverflowError(\"result out of range\")\n\n    __radd__ = __add__\n\n    def __sub__(self, other):\n        \"Subtract two datetimes, or a datetime and a timedelta.\"\n        if not isinstance(other, datetime):\n            if isinstance(other, timedelta):\n                return self + -other\n            return NotImplemented\n\n        days1 = self.toordinal()\n        days2 = other.toordinal()\n        secs1 = self._second + self._minute * 60 + self._hour * 3600\n        secs2 = other._second + other._minute * 60 + other._hour * 3600\n        base = timedelta(days1 - days2,\n                         secs1 - secs2,\n                         self._microsecond - other._microsecond)\n        if self._tzinfo is other._tzinfo:\n            return base\n        myoff = self.utcoffset()\n        otoff = other.utcoffset()\n        if myoff == otoff:\n            return base\n        if myoff is None or otoff is None:\n            raise TypeError(\"cannot mix naive and timezone-aware time\")\n        return base + otoff - myoff\n\n    def __hash__(self):\n        if self._hashcode == -1:\n            if self.fold:\n                t = self.replace(fold=0)\n            else:\n                t = self\n            tzoff = t.utcoffset()\n            if tzoff is None:\n                self._hashcode = hash(t._getstate()[0])\n            else:\n                days = _ymd2ord(self.year, self.month, self.day)\n                seconds = self.hour * 3600 + self.minute * 60 + self.second\n                self._hashcode = hash(timedelta(days, seconds, self.microsecond) - tzoff)\n        return self._hashcode\n\n    # Pickle support.\n\n    def _getstate(self, protocol=3):\n        yhi, ylo = divmod(self._year, 256)\n        us2, us3 = divmod(self._microsecond, 256)\n        us1, us2 = divmod(us2, 256)\n        m = self._month\n        if self._fold and protocol > 3:\n            m += 128\n        basestate = bytes([yhi, ylo, m, self._day,\n                           self._hour, self._minute, self._second,\n                           us1, us2, us3])\n        if self._tzinfo is None:\n            return (basestate,)\n        else:\n            return (basestate, self._tzinfo)\n\n    def __setstate(self, string, tzinfo):\n        if tzinfo is not None and not isinstance(tzinfo, _tzinfo_class):\n            raise TypeError(\"bad tzinfo state arg\")\n        (yhi, ylo, m, self._day, self._hour,\n         self._minute, self._second, us1, us2, us3) = string\n        if m > 127:\n            self._fold = 1\n            self._month = m - 128\n        else:\n            self._fold = 0\n            self._month = m\n        self._year = yhi * 256 + ylo\n        self._microsecond = (((us1 << 8) | us2) << 8) | us3\n        self._tzinfo = tzinfo\n\n    def __reduce_ex__(self, protocol):\n        return (self.__class__, self._getstate(protocol))\n\n    def __reduce__(self):\n        return self.__reduce_ex__(2)"
    ],
    [
        "STORE_NAME",
        "class datetime(date):\n    \"\"\"datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])\n\n    The year, month and day arguments are required. tzinfo may be None, or an\n    instance of a tzinfo subclass. The remaining arguments may be ints.\n    \"\"\"\n    __slots__ = date.__slots__ + time.__slots__\n\n    def __new__(cls, year, month=None, day=None, hour=0, minute=0, second=0,\n                microsecond=0, tzinfo=None, *, fold=0):\n        if (isinstance(year, (bytes, str)) and len(year) == 10 and\n            1 <= ord(year[2:3])&0x7F <= 12):\n            # Pickle support\n            if isinstance(year, str):\n                try:\n                    year = bytes(year, 'latin1')\n                except UnicodeEncodeError:\n                    # More informative error message.\n                    raise ValueError(\n                        \"Failed to encode latin1 string when unpickling \"\n                        \"a datetime object. \"\n                        \"pickle.load(data, encoding='latin1') is assumed.\")\n            self = object.__new__(cls)\n            self.__setstate(year, month)\n            self._hashcode = -1\n            return self\n        year, month, day = _check_date_fields(year, month, day)\n        hour, minute, second, microsecond, fold = _check_time_fields(\n            hour, minute, second, microsecond, fold)\n        _check_tzinfo_arg(tzinfo)\n        self = object.__new__(cls)\n        self._year = year\n        self._month = month\n        self._day = day\n        self._hour = hour\n        self._minute = minute\n        self._second = second\n        self._microsecond = microsecond\n        self._tzinfo = tzinfo\n        self._hashcode = -1\n        self._fold = fold\n        return self\n\n    # Read-only field accessors\n    @property\n    def hour(self):\n        \"\"\"hour (0-23)\"\"\"\n        return self._hour\n\n    @property\n    def minute(self):\n        \"\"\"minute (0-59)\"\"\"\n        return self._minute\n\n    @property\n    def second(self):\n        \"\"\"second (0-59)\"\"\"\n        return self._second\n\n    @property\n    def microsecond(self):\n        \"\"\"microsecond (0-999999)\"\"\"\n        return self._microsecond\n\n    @property\n    def tzinfo(self):\n        \"\"\"timezone info object\"\"\"\n        return self._tzinfo\n\n    @property\n    def fold(self):\n        return self._fold\n\n    @classmethod\n    def _fromtimestamp(cls, t, utc, tz):\n        \"\"\"Construct a datetime from a POSIX timestamp (like time.time()).\n\n        A timezone info object may be passed in as well.\n        \"\"\"\n        frac, t = _math.modf(t)\n        us = round(frac * 1e6)\n        if us >= 1000000:\n            t += 1\n            us -= 1000000\n        elif us < 0:\n            t -= 1\n            us += 1000000\n\n        converter = _time.gmtime if utc else _time.localtime\n        y, m, d, hh, mm, ss, weekday, jday, dst = converter(t)\n        ss = min(ss, 59)    # clamp out leap seconds if the platform has them\n        result = cls(y, m, d, hh, mm, ss, us, tz)\n        if tz is None and not utc:\n            # As of version 2015f max fold in IANA database is\n            # 23 hours at 1969-09-30 13:00:00 in Kwajalein.\n            # Let's probe 24 hours in the past to detect a transition:\n            max_fold_seconds = 24 * 3600\n\n            # On Windows localtime_s throws an OSError for negative values,\n            # thus we can't perform fold detection for values of time less\n            # than the max time fold. See comments in _datetimemodule's\n            # version of this method for more details.\n            if t < max_fold_seconds and sys.platform.startswith(\"win\"):\n                return result\n\n            y, m, d, hh, mm, ss = converter(t - max_fold_seconds)[:6]\n            probe1 = cls(y, m, d, hh, mm, ss, us, tz)\n            trans = result - probe1 - timedelta(0, max_fold_seconds)\n            if trans.days < 0:\n                y, m, d, hh, mm, ss = converter(t + trans // timedelta(0, 1))[:6]\n                probe2 = cls(y, m, d, hh, mm, ss, us, tz)\n                if probe2 == result:\n                    result._fold = 1\n        elif tz is not None:\n            result = tz.fromutc(result)\n        return result\n\n    @classmethod\n    def fromtimestamp(cls, t, tz=None):\n        \"\"\"Construct a datetime from a POSIX timestamp (like time.time()).\n\n        A timezone info object may be passed in as well.\n        \"\"\"\n        _check_tzinfo_arg(tz)\n\n        return cls._fromtimestamp(t, tz is not None, tz)\n\n    @classmethod\n    def utcfromtimestamp(cls, t):\n        \"\"\"Construct a naive UTC datetime from a POSIX timestamp.\"\"\"\n        return cls._fromtimestamp(t, True, None)\n\n    @classmethod\n    def now(cls, tz=None):\n        \"Construct a datetime from time.time() and optional time zone info.\"\n        t = _time.time()\n        return cls.fromtimestamp(t, tz)\n\n    @classmethod\n    def utcnow(cls):\n        \"Construct a UTC datetime from time.time().\"\n        t = _time.time()\n        return cls.utcfromtimestamp(t)\n\n    @classmethod\n    def combine(cls, date, time, tzinfo=True):\n        \"Construct a datetime from a given date and a given time.\"\n        if not isinstance(date, _date_class):\n            raise TypeError(\"date argument must be a date instance\")\n        if not isinstance(time, _time_class):\n            raise TypeError(\"time argument must be a time instance\")\n        if tzinfo is True:\n            tzinfo = time.tzinfo\n        return cls(date.year, date.month, date.day,\n                   time.hour, time.minute, time.second, time.microsecond,\n                   tzinfo, fold=time.fold)\n\n    @classmethod\n    def fromisoformat(cls, date_string):\n        \"\"\"Construct a datetime from a string in one of the ISO 8601 formats.\"\"\"\n        if not isinstance(date_string, str):\n            raise TypeError('fromisoformat: argument must be str')\n\n        if len(date_string) < 7:\n            raise ValueError(f'Invalid isoformat string: {date_string!r}')\n\n        # Split this at the separator\n        try:\n            separator_location = _find_isoformat_datetime_separator(date_string)\n            dstr = date_string[0:separator_location]\n            tstr = date_string[(separator_location+1):]\n\n            date_components = _parse_isoformat_date(dstr)\n        except ValueError:\n            raise ValueError(\n                f'Invalid isoformat string: {date_string!r}') from None\n\n        if tstr:\n            try:\n                time_components = _parse_isoformat_time(tstr)\n            except ValueError:\n                raise ValueError(\n                    f'Invalid isoformat string: {date_string!r}') from None\n        else:\n            time_components = [0, 0, 0, 0, None]\n\n        return cls(*(date_components + time_components))\n\n    def timetuple(self):\n        \"Return local time tuple compatible with time.localtime().\"\n        dst = self.dst()\n        if dst is None:\n            dst = -1\n        elif dst:\n            dst = 1\n        else:\n            dst = 0\n        return _build_struct_time(self.year, self.month, self.day,\n                                  self.hour, self.minute, self.second,\n                                  dst)\n\n    def _mktime(self):\n        \"\"\"Return integer POSIX timestamp.\"\"\"\n        epoch = datetime(1970, 1, 1)\n        max_fold_seconds = 24 * 3600\n        t = (self - epoch) // timedelta(0, 1)\n        def local(u):\n            y, m, d, hh, mm, ss = _time.localtime(u)[:6]\n            return (datetime(y, m, d, hh, mm, ss) - epoch) // timedelta(0, 1)\n\n        # Our goal is to solve t = local(u) for u.\n        a = local(t) - t\n        u1 = t - a\n        t1 = local(u1)\n        if t1 == t:\n            # We found one solution, but it may not be the one we need.\n            # Look for an earlier solution (if `fold` is 0), or a\n            # later one (if `fold` is 1).\n            u2 = u1 + (-max_fold_seconds, max_fold_seconds)[self.fold]\n            b = local(u2) - u2\n            if a == b:\n                return u1\n        else:\n            b = t1 - u1\n            assert a != b\n        u2 = t - b\n        t2 = local(u2)\n        if t2 == t:\n            return u2\n        if t1 == t:\n            return u1\n        # We have found both offsets a and b, but neither t - a nor t - b is\n        # a solution.  This means t is in the gap.\n        return (max, min)[self.fold](u1, u2)\n\n\n    def timestamp(self):\n        \"Return POSIX timestamp as float\"\n        if self._tzinfo is None:\n            s = self._mktime()\n            return s + self.microsecond / 1e6\n        else:\n            return (self - _EPOCH).total_seconds()\n\n    def utctimetuple(self):\n        \"Return UTC time tuple compatible with time.gmtime().\"\n        offset = self.utcoffset()\n        if offset:\n            self -= offset\n        y, m, d = self.year, self.month, self.day\n        hh, mm, ss = self.hour, self.minute, self.second\n        return _build_struct_time(y, m, d, hh, mm, ss, 0)\n\n    def date(self):\n        \"Return the date part.\"\n        return date(self._year, self._month, self._day)\n\n    def time(self):\n        \"Return the time part, with tzinfo None.\"\n        return time(self.hour, self.minute, self.second, self.microsecond, fold=self.fold)\n\n    def timetz(self):\n        \"Return the time part, with same tzinfo.\"\n        return time(self.hour, self.minute, self.second, self.microsecond,\n                    self._tzinfo, fold=self.fold)\n\n    def replace(self, year=None, month=None, day=None, hour=None,\n                minute=None, second=None, microsecond=None, tzinfo=True,\n                *, fold=None):\n        \"\"\"Return a new datetime with new values for the specified fields.\"\"\"\n        if year is None:\n            year = self.year\n        if month is None:\n            month = self.month\n        if day is None:\n            day = self.day\n        if hour is None:\n            hour = self.hour\n        if minute is None:\n            minute = self.minute\n        if second is None:\n            second = self.second\n        if microsecond is None:\n            microsecond = self.microsecond\n        if tzinfo is True:\n            tzinfo = self.tzinfo\n        if fold is None:\n            fold = self.fold\n        return type(self)(year, month, day, hour, minute, second,\n                          microsecond, tzinfo, fold=fold)\n\n    def _local_timezone(self):\n        if self.tzinfo is None:\n            ts = self._mktime()\n        else:\n            ts = (self - _EPOCH) // timedelta(seconds=1)\n        localtm = _time.localtime(ts)\n        local = datetime(*localtm[:6])\n        # Extract TZ data\n        gmtoff = localtm.tm_gmtoff\n        zone = localtm.tm_zone\n        return timezone(timedelta(seconds=gmtoff), zone)\n\n    def astimezone(self, tz=None):\n        if tz is None:\n            tz = self._local_timezone()\n        elif not isinstance(tz, tzinfo):\n            raise TypeError(\"tz argument must be an instance of tzinfo\")\n\n        mytz = self.tzinfo\n        if mytz is None:\n            mytz = self._local_timezone()\n            myoffset = mytz.utcoffset(self)\n        else:\n            myoffset = mytz.utcoffset(self)\n            if myoffset is None:\n                mytz = self.replace(tzinfo=None)._local_timezone()\n                myoffset = mytz.utcoffset(self)\n\n        if tz is mytz:\n            return self\n\n        # Convert self to UTC, and attach the new time zone object.\n        utc = (self - myoffset).replace(tzinfo=tz)\n\n        # Convert from UTC to tz's local time.\n        return tz.fromutc(utc)\n\n    # Ways to produce a string.\n\n    def ctime(self):\n        \"Return ctime() style string.\"\n        weekday = self.toordinal() % 7 or 7\n        return \"%s %s %2d %02d:%02d:%02d %04d\" % (\n            _DAYNAMES[weekday],\n            _MONTHNAMES[self._month],\n            self._day,\n            self._hour, self._minute, self._second,\n            self._year)\n\n    def isoformat(self, sep='T', timespec='auto'):\n        \"\"\"Return the time formatted according to ISO.\n\n        The full format looks like 'YYYY-MM-DD HH:MM:SS.mmmmmm'.\n        By default, the fractional part is omitted if self.microsecond == 0.\n\n        If self.tzinfo is not None, the UTC offset is also attached, giving\n        giving a full format of 'YYYY-MM-DD HH:MM:SS.mmmmmm+HH:MM'.\n\n        Optional argument sep specifies the separator between date and\n        time, default 'T'.\n\n        The optional argument timespec specifies the number of additional\n        terms of the time to include. Valid options are 'auto', 'hours',\n        'minutes', 'seconds', 'milliseconds' and 'microseconds'.\n        \"\"\"\n        s = (\"%04d-%02d-%02d%c\" % (self._year, self._month, self._day, sep) +\n             _format_time(self._hour, self._minute, self._second,\n                          self._microsecond, timespec))\n\n        off = self.utcoffset()\n        tz = _format_offset(off)\n        if tz:\n            s += tz\n\n        return s\n\n    def __repr__(self):\n        \"\"\"Convert to formal string, for repr().\"\"\"\n        L = [self._year, self._month, self._day,  # These are never zero\n             self._hour, self._minute, self._second, self._microsecond]\n        if L[-1] == 0:\n            del L[-1]\n        if L[-1] == 0:\n            del L[-1]\n        s = \"%s.%s(%s)\" % (self.__class__.__module__,\n                           self.__class__.__qualname__,\n                           \", \".join(map(str, L)))\n        if self._tzinfo is not None:\n            assert s[-1:] == \")\"\n            s = s[:-1] + \", tzinfo=%r\" % self._tzinfo + \")\"\n        if self._fold:\n            assert s[-1:] == \")\"\n            s = s[:-1] + \", fold=1)\"\n        return s\n\n    def __str__(self):\n        \"Convert to string, for str().\"\n        return self.isoformat(sep=' ')\n\n    @classmethod\n    def strptime(cls, date_string, format):\n        'string, format -> new datetime parsed from a string (like time.strptime()).'\n        import _strptime\n        return _strptime._strptime_datetime(cls, date_string, format)\n\n    def utcoffset(self):\n        \"\"\"Return the timezone offset as timedelta positive east of UTC (negative west of\n        UTC).\"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.utcoffset(self)\n        _check_utc_offset(\"utcoffset\", offset)\n        return offset\n\n    def tzname(self):\n        \"\"\"Return the timezone name.\n\n        Note that the name is 100% informational -- there's no requirement that\n        it mean anything in particular. For example, \"GMT\", \"UTC\", \"-500\",\n        \"-5:00\", \"EDT\", \"US/Eastern\", \"America/New York\" are all valid replies.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        name = self._tzinfo.tzname(self)\n        _check_tzname(name)\n        return name\n\n    def dst(self):\n        \"\"\"Return 0 if DST is not in effect, or the DST offset (as timedelta\n        positive eastward) if DST is in effect.\n\n        This is purely informational; the DST offset has already been added to\n        the UTC offset returned by utcoffset() if applicable, so there's no\n        need to consult dst() unless you're interested in displaying the DST\n        info.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.dst(self)\n        _check_utc_offset(\"dst\", offset)\n        return offset\n\n    # Comparisons of datetime objects with other.\n\n    def __eq__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other, allow_mixed=True) == 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            return False\n\n    def __le__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) <= 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def __lt__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) < 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def __ge__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) >= 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def __gt__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) > 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)\n\n    def _cmp(self, other, allow_mixed=False):\n        assert isinstance(other, datetime)\n        mytz = self._tzinfo\n        ottz = other._tzinfo\n        myoff = otoff = None\n\n        if mytz is ottz:\n            base_compare = True\n        else:\n            myoff = self.utcoffset()\n            otoff = other.utcoffset()\n            # Assume that allow_mixed means that we are called from __eq__\n            if allow_mixed:\n                if myoff != self.replace(fold=not self.fold).utcoffset():\n                    return 2\n                if otoff != other.replace(fold=not other.fold).utcoffset():\n                    return 2\n            base_compare = myoff == otoff\n\n        if base_compare:\n            return _cmp((self._year, self._month, self._day,\n                         self._hour, self._minute, self._second,\n                         self._microsecond),\n                        (other._year, other._month, other._day,\n                         other._hour, other._minute, other._second,\n                         other._microsecond))\n        if myoff is None or otoff is None:\n            if allow_mixed:\n                return 2 # arbitrary non-zero value\n            else:\n                raise TypeError(\"cannot compare naive and aware datetimes\")\n        # XXX What follows could be done more efficiently...\n        diff = self - other     # this will take offsets into account\n        if diff.days < 0:\n            return -1\n        return diff and 1 or 0\n\n    def __add__(self, other):\n        \"Add a datetime and a timedelta.\"\n        if not isinstance(other, timedelta):\n            return NotImplemented\n        delta = timedelta(self.toordinal(),\n                          hours=self._hour,\n                          minutes=self._minute,\n                          seconds=self._second,\n                          microseconds=self._microsecond)\n        delta += other\n        hour, rem = divmod(delta.seconds, 3600)\n        minute, second = divmod(rem, 60)\n        if 0 < delta.days <= _MAXORDINAL:\n            return type(self).combine(date.fromordinal(delta.days),\n                                      time(hour, minute, second,\n                                           delta.microseconds,\n                                           tzinfo=self._tzinfo))\n        raise OverflowError(\"result out of range\")\n\n    __radd__ = __add__\n\n    def __sub__(self, other):\n        \"Subtract two datetimes, or a datetime and a timedelta.\"\n        if not isinstance(other, datetime):\n            if isinstance(other, timedelta):\n                return self + -other\n            return NotImplemented\n\n        days1 = self.toordinal()\n        days2 = other.toordinal()\n        secs1 = self._second + self._minute * 60 + self._hour * 3600\n        secs2 = other._second + other._minute * 60 + other._hour * 3600\n        base = timedelta(days1 - days2,\n                         secs1 - secs2,\n                         self._microsecond - other._microsecond)\n        if self._tzinfo is other._tzinfo:\n            return base\n        myoff = self.utcoffset()\n        otoff = other.utcoffset()\n        if myoff == otoff:\n            return base\n        if myoff is None or otoff is None:\n            raise TypeError(\"cannot mix naive and timezone-aware time\")\n        return base + otoff - myoff\n\n    def __hash__(self):\n        if self._hashcode == -1:\n            if self.fold:\n                t = self.replace(fold=0)\n            else:\n                t = self\n            tzoff = t.utcoffset()\n            if tzoff is None:\n                self._hashcode = hash(t._getstate()[0])\n            else:\n                days = _ymd2ord(self.year, self.month, self.day)\n                seconds = self.hour * 3600 + self.minute * 60 + self.second\n                self._hashcode = hash(timedelta(days, seconds, self.microsecond) - tzoff)\n        return self._hashcode\n\n    # Pickle support.\n\n    def _getstate(self, protocol=3):\n        yhi, ylo = divmod(self._year, 256)\n        us2, us3 = divmod(self._microsecond, 256)\n        us1, us2 = divmod(us2, 256)\n        m = self._month\n        if self._fold and protocol > 3:\n            m += 128\n        basestate = bytes([yhi, ylo, m, self._day,\n                           self._hour, self._minute, self._second,\n                           us1, us2, us3])\n        if self._tzinfo is None:\n            return (basestate,)\n        else:\n            return (basestate, self._tzinfo)\n\n    def __setstate(self, string, tzinfo):\n        if tzinfo is not None and not isinstance(tzinfo, _tzinfo_class):\n            raise TypeError(\"bad tzinfo state arg\")\n        (yhi, ylo, m, self._day, self._hour,\n         self._minute, self._second, us1, us2, us3) = string\n        if m > 127:\n            self._fold = 1\n            self._month = m - 128\n        else:\n            self._fold = 0\n            self._month = m\n        self._year = yhi * 256 + ylo\n        self._microsecond = (((us1 << 8) | us2) << 8) | us3\n        self._tzinfo = tzinfo\n\n    def __reduce_ex__(self, protocol):\n        return (self.__class__, self._getstate(protocol))\n\n    def __reduce__(self):\n        return self.__reduce_ex__(2)"
    ],
    [
        "LOAD_NAME",
        "datetime"
    ],
    [
        "CALL",
        "datetime(1, 1, 1)"
    ],
    [
        "LOAD_NAME",
        "datetime"
    ],
    [
        "STORE_ATTR",
        "datetime.min"
    ],
    [
        "LOAD_NAME",
        "datetime"
    ],
    [
        "CALL",
        "datetime(9999, 12, 31, 23, 59, 59, 999999)"
    ],
    [
        "LOAD_NAME",
        "datetime"
    ],
    [
        "STORE_ATTR",
        "datetime.max"
    ],
    [
        "LOAD_NAME",
        "timedelta"
    ],
    [
        "CALL",
        "timedelta(microseconds=1)"
    ],
    [
        "LOAD_NAME",
        "datetime"
    ],
    [
        "STORE_ATTR",
        "datetime.resolution"
    ],
    [
        "STORE_NAME",
        "def _isoweek1monday(year):\n    # Helper to calculate the day number of the Monday starting week 1\n    # XXX This could be done more efficiently\n    THURSDAY = 3\n    firstday = _ymd2ord(year, 1, 1)\n    firstweekday = (firstday + 6) % 7  # See weekday() above\n    week1monday = firstday - firstweekday\n    if firstweekday > THURSDAY:\n        week1monday += 7\n    return week1monday"
    ],
    [
        "LOAD_NAME",
        "tzinfo"
    ],
    [
        "CALL",
        "class timezone(tzinfo):\n    __slots__ = '_offset', '_name'\n\n    # Sentinel value to disallow None\n    _Omitted = object()\n    def __new__(cls, offset, name=_Omitted):\n        if not isinstance(offset, timedelta):\n            raise TypeError(\"offset must be a timedelta\")\n        if name is cls._Omitted:\n            if not offset:\n                return cls.utc\n            name = None\n        elif not isinstance(name, str):\n            raise TypeError(\"name must be a string\")\n        if not cls._minoffset <= offset <= cls._maxoffset:\n            raise ValueError(\"offset must be a timedelta \"\n                             \"strictly between -timedelta(hours=24) and \"\n                             \"timedelta(hours=24).\")\n        return cls._create(offset, name)\n\n    @classmethod\n    def _create(cls, offset, name=None):\n        self = tzinfo.__new__(cls)\n        self._offset = offset\n        self._name = name\n        return self\n\n    def __getinitargs__(self):\n        \"\"\"pickle support\"\"\"\n        if self._name is None:\n            return (self._offset,)\n        return (self._offset, self._name)\n\n    def __eq__(self, other):\n        if isinstance(other, timezone):\n            return self._offset == other._offset\n        return NotImplemented\n\n    def __hash__(self):\n        return hash(self._offset)\n\n    def __repr__(self):\n        \"\"\"Convert to formal string, for repr().\n\n        >>> tz = timezone.utc\n        >>> repr(tz)\n        'datetime.timezone.utc'\n        >>> tz = timezone(timedelta(hours=-5), 'EST')\n        >>> repr(tz)\n        \"datetime.timezone(datetime.timedelta(-1, 68400), 'EST')\"\n        \"\"\"\n        if self is self.utc:\n            return 'datetime.timezone.utc'\n        if self._name is None:\n            return \"%s.%s(%r)\" % (self.__class__.__module__,\n                                  self.__class__.__qualname__,\n                                  self._offset)\n        return \"%s.%s(%r, %r)\" % (self.__class__.__module__,\n                                  self.__class__.__qualname__,\n                                  self._offset, self._name)\n\n    def __str__(self):\n        return self.tzname(None)\n\n    def utcoffset(self, dt):\n        if isinstance(dt, datetime) or dt is None:\n            return self._offset\n        raise TypeError(\"utcoffset() argument must be a datetime instance\"\n                        \" or None\")\n\n    def tzname(self, dt):\n        if isinstance(dt, datetime) or dt is None:\n            if self._name is None:\n                return self._name_from_offset(self._offset)\n            return self._name\n        raise TypeError(\"tzname() argument must be a datetime instance\"\n                        \" or None\")\n\n    def dst(self, dt):\n        if isinstance(dt, datetime) or dt is None:\n            return None\n        raise TypeError(\"dst() argument must be a datetime instance\"\n                        \" or None\")\n\n    def fromutc(self, dt):\n        if isinstance(dt, datetime):\n            if dt.tzinfo is not self:\n                raise ValueError(\"fromutc: dt.tzinfo \"\n                                 \"is not self\")\n            return dt + self._offset\n        raise TypeError(\"fromutc() argument must be a datetime instance\"\n                        \" or None\")\n\n    _maxoffset = timedelta(hours=24, microseconds=-1)\n    _minoffset = -_maxoffset\n\n    @staticmethod\n    def _name_from_offset(delta):\n        if not delta:\n            return 'UTC'\n        if delta < timedelta(0):\n            sign = '-'\n            delta = -delta\n        else:\n            sign = '+'\n        hours, rest = divmod(delta, timedelta(hours=1))\n        minutes, rest = divmod(rest, timedelta(minutes=1))\n        seconds = rest.seconds\n        microseconds = rest.microseconds\n        if microseconds:\n            return (f'UTC{sign}{hours:02d}:{minutes:02d}:{seconds:02d}'\n                    f'.{microseconds:06d}')\n        if seconds:\n            return f'UTC{sign}{hours:02d}:{minutes:02d}:{seconds:02d}'\n        return f'UTC{sign}{hours:02d}:{minutes:02d}'"
    ],
    [
        "STORE_NAME",
        "class timezone(tzinfo):\n    __slots__ = '_offset', '_name'\n\n    # Sentinel value to disallow None\n    _Omitted = object()\n    def __new__(cls, offset, name=_Omitted):\n        if not isinstance(offset, timedelta):\n            raise TypeError(\"offset must be a timedelta\")\n        if name is cls._Omitted:\n            if not offset:\n                return cls.utc\n            name = None\n        elif not isinstance(name, str):\n            raise TypeError(\"name must be a string\")\n        if not cls._minoffset <= offset <= cls._maxoffset:\n            raise ValueError(\"offset must be a timedelta \"\n                             \"strictly between -timedelta(hours=24) and \"\n                             \"timedelta(hours=24).\")\n        return cls._create(offset, name)\n\n    @classmethod\n    def _create(cls, offset, name=None):\n        self = tzinfo.__new__(cls)\n        self._offset = offset\n        self._name = name\n        return self\n\n    def __getinitargs__(self):\n        \"\"\"pickle support\"\"\"\n        if self._name is None:\n            return (self._offset,)\n        return (self._offset, self._name)\n\n    def __eq__(self, other):\n        if isinstance(other, timezone):\n            return self._offset == other._offset\n        return NotImplemented\n\n    def __hash__(self):\n        return hash(self._offset)\n\n    def __repr__(self):\n        \"\"\"Convert to formal string, for repr().\n\n        >>> tz = timezone.utc\n        >>> repr(tz)\n        'datetime.timezone.utc'\n        >>> tz = timezone(timedelta(hours=-5), 'EST')\n        >>> repr(tz)\n        \"datetime.timezone(datetime.timedelta(-1, 68400), 'EST')\"\n        \"\"\"\n        if self is self.utc:\n            return 'datetime.timezone.utc'\n        if self._name is None:\n            return \"%s.%s(%r)\" % (self.__class__.__module__,\n                                  self.__class__.__qualname__,\n                                  self._offset)\n        return \"%s.%s(%r, %r)\" % (self.__class__.__module__,\n                                  self.__class__.__qualname__,\n                                  self._offset, self._name)\n\n    def __str__(self):\n        return self.tzname(None)\n\n    def utcoffset(self, dt):\n        if isinstance(dt, datetime) or dt is None:\n            return self._offset\n        raise TypeError(\"utcoffset() argument must be a datetime instance\"\n                        \" or None\")\n\n    def tzname(self, dt):\n        if isinstance(dt, datetime) or dt is None:\n            if self._name is None:\n                return self._name_from_offset(self._offset)\n            return self._name\n        raise TypeError(\"tzname() argument must be a datetime instance\"\n                        \" or None\")\n\n    def dst(self, dt):\n        if isinstance(dt, datetime) or dt is None:\n            return None\n        raise TypeError(\"dst() argument must be a datetime instance\"\n                        \" or None\")\n\n    def fromutc(self, dt):\n        if isinstance(dt, datetime):\n            if dt.tzinfo is not self:\n                raise ValueError(\"fromutc: dt.tzinfo \"\n                                 \"is not self\")\n            return dt + self._offset\n        raise TypeError(\"fromutc() argument must be a datetime instance\"\n                        \" or None\")\n\n    _maxoffset = timedelta(hours=24, microseconds=-1)\n    _minoffset = -_maxoffset\n\n    @staticmethod\n    def _name_from_offset(delta):\n        if not delta:\n            return 'UTC'\n        if delta < timedelta(0):\n            sign = '-'\n            delta = -delta\n        else:\n            sign = '+'\n        hours, rest = divmod(delta, timedelta(hours=1))\n        minutes, rest = divmod(rest, timedelta(minutes=1))\n        seconds = rest.seconds\n        microseconds = rest.microseconds\n        if microseconds:\n            return (f'UTC{sign}{hours:02d}:{minutes:02d}:{seconds:02d}'\n                    f'.{microseconds:06d}')\n        if seconds:\n            return f'UTC{sign}{hours:02d}:{minutes:02d}:{seconds:02d}'\n        return f'UTC{sign}{hours:02d}:{minutes:02d}'"
    ],
    [
        "LOAD_NAME",
        "timezone"
    ],
    [
        "LOAD_ATTR",
        "timezone._create"
    ],
    [
        "LOAD_NAME",
        "timedelta"
    ],
    [
        "CALL",
        "timedelta(0)"
    ],
    [
        "CALL",
        "timezone._create(timedelta(0))"
    ],
    [
        "STORE_NAME",
        "UTC"
    ],
    [
        "LOAD_NAME",
        "timezone"
    ],
    [
        "STORE_ATTR",
        "timezone.utc"
    ],
    [
        "LOAD_NAME",
        "timezone"
    ],
    [
        "LOAD_ATTR",
        "timezone._create"
    ],
    [
        "LOAD_NAME",
        "timedelta"
    ],
    [
        "CALL",
        "timedelta(hours=23, minutes=59)"
    ],
    [
        "UNARY_NEGATIVE",
        "-timedelta(hours=23, minutes=59)"
    ],
    [
        "CALL",
        "timezone._create(-timedelta(hours=23, minutes=59))"
    ],
    [
        "LOAD_NAME",
        "timezone"
    ],
    [
        "STORE_ATTR",
        "timezone.min"
    ],
    [
        "LOAD_NAME",
        "timezone"
    ],
    [
        "LOAD_ATTR",
        "timezone._create"
    ],
    [
        "LOAD_NAME",
        "timedelta"
    ],
    [
        "CALL",
        "timedelta(hours=23, minutes=59)"
    ],
    [
        "CALL",
        "timezone._create(timedelta(hours=23, minutes=59))"
    ],
    [
        "LOAD_NAME",
        "timezone"
    ],
    [
        "STORE_ATTR",
        "timezone.max"
    ],
    [
        "LOAD_NAME",
        "datetime"
    ],
    [
        "LOAD_NAME",
        "timezone"
    ],
    [
        "LOAD_ATTR",
        "timezone.utc"
    ],
    [
        "CALL",
        "datetime(1970, 1, 1, tzinfo=timezone.utc)"
    ],
    [
        "STORE_NAME",
        "_EPOCH"
    ],
    [
        "CALL_INTRINSIC_1",
        "from _datetime import *"
    ],
    [
        "DELETE_NAME",
        "_DAYNAMES"
    ],
    [
        "DELETE_NAME",
        "_DAYS_BEFORE_MONTH"
    ],
    [
        "DELETE_NAME",
        "_DAYS_IN_MONTH"
    ],
    [
        "DELETE_NAME",
        "_DI100Y"
    ],
    [
        "DELETE_NAME",
        "_DI400Y"
    ],
    [
        "DELETE_NAME",
        "_DI4Y"
    ],
    [
        "DELETE_NAME",
        "_EPOCH"
    ],
    [
        "DELETE_NAME",
        "_MAXORDINAL"
    ],
    [
        "DELETE_NAME",
        "_MONTHNAMES"
    ],
    [
        "DELETE_NAME",
        "_build_struct_time"
    ],
    [
        "DELETE_NAME",
        "_check_date_fields"
    ],
    [
        "DELETE_NAME",
        "_check_time_fields"
    ],
    [
        "DELETE_NAME",
        "_check_tzinfo_arg"
    ],
    [
        "DELETE_NAME",
        "_check_tzname"
    ],
    [
        "DELETE_NAME",
        "_check_utc_offset"
    ],
    [
        "DELETE_NAME",
        "_cmp"
    ],
    [
        "DELETE_NAME",
        "_cmperror"
    ],
    [
        "DELETE_NAME",
        "_date_class"
    ],
    [
        "DELETE_NAME",
        "_days_before_month"
    ],
    [
        "DELETE_NAME",
        "_days_before_year"
    ],
    [
        "DELETE_NAME",
        "_days_in_month"
    ],
    [
        "DELETE_NAME",
        "_format_time"
    ],
    [
        "DELETE_NAME",
        "_format_offset"
    ],
    [
        "DELETE_NAME",
        "_index"
    ],
    [
        "DELETE_NAME",
        "_is_leap"
    ],
    [
        "DELETE_NAME",
        "_isoweek1monday"
    ],
    [
        "DELETE_NAME",
        "_math"
    ],
    [
        "DELETE_NAME",
        "_ord2ymd"
    ],
    [
        "DELETE_NAME",
        "_time"
    ],
    [
        "DELETE_NAME",
        "_time_class"
    ],
    [
        "DELETE_NAME",
        "_tzinfo_class"
    ],
    [
        "DELETE_NAME",
        "_wrap_strftime"
    ],
    [
        "DELETE_NAME",
        "_ymd2ord"
    ],
    [
        "DELETE_NAME",
        "_divide_and_round"
    ],
    [
        "DELETE_NAME",
        "_parse_isoformat_date"
    ],
    [
        "DELETE_NAME",
        "_parse_isoformat_time"
    ],
    [
        "DELETE_NAME",
        "_parse_hh_mm_ss_ff"
    ],
    [
        "DELETE_NAME",
        "_IsoCalendarDate"
    ],
    [
        "DELETE_NAME",
        "_isoweek_to_gregorian"
    ],
    [
        "DELETE_NAME",
        "_find_isoformat_datetime_separator"
    ],
    [
        "DELETE_NAME",
        "_FRACTION_CORRECTION"
    ],
    [
        "DELETE_NAME",
        "_is_ascii_digit"
    ],
    [
        "STORE_NAME",
        "from _datetime import __doc__"
    ],
    [
        "LOAD_NAME",
        "ImportError"
    ],
    [
        "LOAD_FAST",
        "x"
    ],
    [
        "LOAD_FAST",
        "y"
    ],
    [
        "COMPARE_OP",
        "x == y"
    ],
    [
        "LOAD_FAST",
        "x"
    ],
    [
        "LOAD_FAST",
        "y"
    ],
    [
        "COMPARE_OP",
        "x > y"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "BINARY_OP",
        "year % 4"
    ],
    [
        "COMPARE_OP",
        "year % 4 == 0"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "BINARY_OP",
        "year % 100"
    ],
    [
        "COMPARE_OP",
        "year % 100 != 0"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "BINARY_OP",
        "year % 400"
    ],
    [
        "COMPARE_OP",
        "year % 400 == 0"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "BINARY_OP",
        "year - 1"
    ],
    [
        "STORE_FAST",
        "y"
    ],
    [
        "LOAD_FAST",
        "y"
    ],
    [
        "BINARY_OP",
        "y*365"
    ],
    [
        "LOAD_FAST",
        "y"
    ],
    [
        "BINARY_OP",
        "y//4"
    ],
    [
        "BINARY_OP",
        "y*365 + y//4"
    ],
    [
        "LOAD_FAST",
        "y"
    ],
    [
        "BINARY_OP",
        "y//100"
    ],
    [
        "BINARY_OP",
        "y*365 + y//4 - y//100"
    ],
    [
        "LOAD_FAST",
        "y"
    ],
    [
        "BINARY_OP",
        "y//400"
    ],
    [
        "BINARY_OP",
        "y*365 + y//4 - y//100 + y//400"
    ],
    [
        "LOAD_FAST",
        "month"
    ],
    [
        "COMPARE_OP",
        "1 <= month <= 12"
    ],
    [
        "COMPARE_OP",
        "1 <= month <= 12"
    ],
    [
        "LOAD_FAST",
        "month"
    ],
    [
        "LOAD_FAST",
        "month"
    ],
    [
        "LOAD_FAST",
        "month"
    ],
    [
        "COMPARE_OP",
        "month == 2"
    ],
    [
        "LOAD_GLOBAL",
        "_is_leap"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "CALL",
        "_is_leap(year)"
    ],
    [
        "LOAD_GLOBAL",
        "_DAYS_IN_MONTH"
    ],
    [
        "LOAD_FAST",
        "month"
    ],
    [
        "BINARY_SUBSCR",
        "_DAYS_IN_MONTH[month]"
    ],
    [
        "LOAD_FAST",
        "month"
    ],
    [
        "COMPARE_OP",
        "1 <= month <= 12"
    ],
    [
        "COMPARE_OP",
        "1 <= month <= 12"
    ],
    [
        "LOAD_GLOBAL",
        "_DAYS_BEFORE_MONTH"
    ],
    [
        "LOAD_FAST",
        "month"
    ],
    [
        "BINARY_SUBSCR",
        "_DAYS_BEFORE_MONTH[month]"
    ],
    [
        "LOAD_FAST",
        "month"
    ],
    [
        "COMPARE_OP",
        "month > 2"
    ],
    [
        "LOAD_GLOBAL",
        "_is_leap"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "CALL",
        "_is_leap(year)"
    ],
    [
        "BINARY_OP",
        "_DAYS_BEFORE_MONTH[month] + (month > 2 and _is_leap(year))"
    ],
    [
        "LOAD_FAST",
        "month"
    ],
    [
        "COMPARE_OP",
        "1 <= month <= 12"
    ],
    [
        "COMPARE_OP",
        "1 <= month <= 12"
    ],
    [
        "LOAD_GLOBAL",
        "_days_in_month"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "LOAD_FAST",
        "month"
    ],
    [
        "CALL",
        "_days_in_month(year, month)"
    ],
    [
        "STORE_FAST",
        "dim"
    ],
    [
        "LOAD_FAST",
        "day"
    ],
    [
        "COMPARE_OP",
        "1 <= day <= dim"
    ],
    [
        "LOAD_FAST",
        "dim"
    ],
    [
        "COMPARE_OP",
        "1 <= day <= dim"
    ],
    [
        "LOAD_FAST",
        "dim"
    ],
    [
        "BINARY_OP",
        "'day must be in 1..%d' % dim"
    ],
    [
        "LOAD_GLOBAL",
        "_days_before_year"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "CALL",
        "_days_before_year(year)"
    ],
    [
        "LOAD_GLOBAL",
        "_days_before_month"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "LOAD_FAST",
        "month"
    ],
    [
        "CALL",
        "_days_before_month(year, month)"
    ],
    [
        "BINARY_OP",
        "_days_before_year(year) +\n            _days_before_month(year, month)"
    ],
    [
        "LOAD_FAST",
        "day"
    ],
    [
        "BINARY_OP",
        "_days_before_year(year) +\n            _days_before_month(year, month) +\n            day"
    ],
    [
        "LOAD_FAST",
        "n"
    ],
    [
        "BINARY_OP",
        "n -= 1"
    ],
    [
        "STORE_FAST",
        "n"
    ],
    [
        "LOAD_GLOBAL",
        "divmod"
    ],
    [
        "LOAD_FAST",
        "n"
    ],
    [
        "LOAD_GLOBAL",
        "_DI400Y"
    ],
    [
        "CALL",
        "divmod(n, _DI400Y)"
    ],
    [
        "STORE_FAST",
        "n400"
    ],
    [
        "STORE_FAST",
        "n"
    ],
    [
        "LOAD_FAST",
        "n400"
    ],
    [
        "BINARY_OP",
        "n400 * 400"
    ],
    [
        "BINARY_OP",
        "n400 * 400 + 1"
    ],
    [
        "STORE_FAST",
        "year"
    ],
    [
        "LOAD_GLOBAL",
        "divmod"
    ],
    [
        "LOAD_FAST",
        "n"
    ],
    [
        "LOAD_GLOBAL",
        "_DI100Y"
    ],
    [
        "CALL",
        "divmod(n, _DI100Y)"
    ],
    [
        "STORE_FAST",
        "n100"
    ],
    [
        "STORE_FAST",
        "n"
    ],
    [
        "LOAD_GLOBAL",
        "divmod"
    ],
    [
        "LOAD_FAST",
        "n"
    ],
    [
        "LOAD_GLOBAL",
        "_DI4Y"
    ],
    [
        "CALL",
        "divmod(n, _DI4Y)"
    ],
    [
        "STORE_FAST",
        "n4"
    ],
    [
        "STORE_FAST",
        "n"
    ],
    [
        "LOAD_GLOBAL",
        "divmod"
    ],
    [
        "LOAD_FAST",
        "n"
    ],
    [
        "CALL",
        "divmod(n, 365)"
    ],
    [
        "STORE_FAST",
        "n1"
    ],
    [
        "STORE_FAST",
        "n"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "LOAD_FAST",
        "n100"
    ],
    [
        "BINARY_OP",
        "n100 * 100"
    ],
    [
        "LOAD_FAST",
        "n4"
    ],
    [
        "BINARY_OP",
        "n4 * 4"
    ],
    [
        "BINARY_OP",
        "n100 * 100 + n4 * 4"
    ],
    [
        "LOAD_FAST",
        "n1"
    ],
    [
        "BINARY_OP",
        "n100 * 100 + n4 * 4 + n1"
    ],
    [
        "BINARY_OP",
        "year += n100 * 100 + n4 * 4 + n1"
    ],
    [
        "STORE_FAST",
        "year"
    ],
    [
        "LOAD_FAST",
        "n1"
    ],
    [
        "COMPARE_OP",
        "n1 == 4"
    ],
    [
        "LOAD_FAST",
        "n100"
    ],
    [
        "COMPARE_OP",
        "n100 == 4"
    ],
    [
        "LOAD_FAST",
        "n"
    ],
    [
        "COMPARE_OP",
        "n == 0"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "BINARY_OP",
        "year-1"
    ],
    [
        "LOAD_FAST",
        "n1"
    ],
    [
        "COMPARE_OP",
        "n1 == 3"
    ],
    [
        "LOAD_FAST",
        "n4"
    ],
    [
        "COMPARE_OP",
        "n4 != 24"
    ],
    [
        "LOAD_FAST",
        "n100"
    ],
    [
        "COMPARE_OP",
        "n100 == 3"
    ],
    [
        "STORE_FAST",
        "leapyear"
    ],
    [
        "LOAD_FAST",
        "leapyear"
    ],
    [
        "LOAD_GLOBAL",
        "_is_leap"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "CALL",
        "_is_leap(year)"
    ],
    [
        "COMPARE_OP",
        "leapyear == _is_leap(year)"
    ],
    [
        "LOAD_FAST",
        "n"
    ],
    [
        "BINARY_OP",
        "n + 50"
    ],
    [
        "BINARY_OP",
        "(n + 50) >> 5"
    ],
    [
        "STORE_FAST",
        "month"
    ],
    [
        "LOAD_GLOBAL",
        "_DAYS_BEFORE_MONTH"
    ],
    [
        "LOAD_FAST",
        "month"
    ],
    [
        "BINARY_SUBSCR",
        "_DAYS_BEFORE_MONTH[month]"
    ],
    [
        "LOAD_FAST",
        "month"
    ],
    [
        "COMPARE_OP",
        "month > 2"
    ],
    [
        "LOAD_FAST",
        "leapyear"
    ],
    [
        "BINARY_OP",
        "_DAYS_BEFORE_MONTH[month] + (month > 2 and leapyear)"
    ],
    [
        "STORE_FAST",
        "preceding"
    ],
    [
        "LOAD_FAST",
        "preceding"
    ],
    [
        "LOAD_FAST",
        "n"
    ],
    [
        "COMPARE_OP",
        "preceding > n"
    ],
    [
        "LOAD_FAST",
        "month"
    ],
    [
        "BINARY_OP",
        "month -= 1"
    ],
    [
        "STORE_FAST",
        "month"
    ],
    [
        "LOAD_FAST",
        "preceding"
    ],
    [
        "LOAD_GLOBAL",
        "_DAYS_IN_MONTH"
    ],
    [
        "LOAD_FAST",
        "month"
    ],
    [
        "BINARY_SUBSCR",
        "_DAYS_IN_MONTH[month]"
    ],
    [
        "LOAD_FAST",
        "month"
    ],
    [
        "COMPARE_OP",
        "month == 2"
    ],
    [
        "LOAD_FAST",
        "leapyear"
    ],
    [
        "BINARY_OP",
        "_DAYS_IN_MONTH[month] + (month == 2 and leapyear)"
    ],
    [
        "BINARY_OP",
        "preceding -= _DAYS_IN_MONTH[month] + (month == 2 and leapyear)"
    ],
    [
        "STORE_FAST",
        "preceding"
    ],
    [
        "LOAD_FAST",
        "n"
    ],
    [
        "LOAD_FAST",
        "preceding"
    ],
    [
        "BINARY_OP",
        "n -= preceding"
    ],
    [
        "STORE_FAST",
        "n"
    ],
    [
        "LOAD_FAST",
        "n"
    ],
    [
        "COMPARE_OP",
        "0 <= n < _days_in_month(year, month)"
    ],
    [
        "LOAD_GLOBAL",
        "_days_in_month"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "LOAD_FAST",
        "month"
    ],
    [
        "CALL",
        "_days_in_month(year, month)"
    ],
    [
        "COMPARE_OP",
        "0 <= n < _days_in_month(year, month)"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "LOAD_FAST",
        "month"
    ],
    [
        "LOAD_FAST",
        "n"
    ],
    [
        "BINARY_OP",
        "n+1"
    ],
    [
        "LOAD_GLOBAL",
        "_ymd2ord"
    ],
    [
        "LOAD_FAST",
        "y"
    ],
    [
        "LOAD_FAST",
        "m"
    ],
    [
        "LOAD_FAST",
        "d"
    ],
    [
        "CALL",
        "_ymd2ord(y, m, d)"
    ],
    [
        "BINARY_OP",
        "_ymd2ord(y, m, d) + 6"
    ],
    [
        "BINARY_OP",
        "(_ymd2ord(y, m, d) + 6) % 7"
    ],
    [
        "STORE_FAST",
        "wday"
    ],
    [
        "LOAD_GLOBAL",
        "_days_before_month"
    ],
    [
        "LOAD_FAST",
        "y"
    ],
    [
        "LOAD_FAST",
        "m"
    ],
    [
        "CALL",
        "_days_before_month(y, m)"
    ],
    [
        "LOAD_FAST",
        "d"
    ],
    [
        "BINARY_OP",
        "_days_before_month(y, m) + d"
    ],
    [
        "STORE_FAST",
        "dnum"
    ],
    [
        "LOAD_GLOBAL",
        "_time"
    ],
    [
        "LOAD_ATTR",
        "_time.struct_time"
    ],
    [
        "LOAD_FAST",
        "y"
    ],
    [
        "LOAD_FAST",
        "m"
    ],
    [
        "LOAD_FAST",
        "d"
    ],
    [
        "LOAD_FAST",
        "hh"
    ],
    [
        "LOAD_FAST",
        "mm"
    ],
    [
        "LOAD_FAST",
        "ss"
    ],
    [
        "LOAD_FAST",
        "wday"
    ],
    [
        "LOAD_FAST",
        "dnum"
    ],
    [
        "LOAD_FAST",
        "dstflag"
    ],
    [
        "CALL",
        "_time.struct_time((y, m, d, hh, mm, ss, wday, dnum, dstflag))"
    ],
    [
        "STORE_FAST",
        "specs"
    ],
    [
        "LOAD_FAST",
        "timespec"
    ],
    [
        "COMPARE_OP",
        "timespec == 'auto'"
    ],
    [
        "LOAD_FAST",
        "us"
    ],
    [
        "STORE_FAST",
        "timespec"
    ],
    [
        "LOAD_FAST",
        "timespec"
    ],
    [
        "COMPARE_OP",
        "timespec == 'milliseconds'"
    ],
    [
        "LOAD_FAST",
        "us"
    ],
    [
        "BINARY_OP",
        "us //= 1000"
    ],
    [
        "STORE_FAST",
        "us"
    ],
    [
        "LOAD_FAST",
        "specs"
    ],
    [
        "LOAD_FAST",
        "timespec"
    ],
    [
        "BINARY_SUBSCR",
        "specs[timespec]"
    ],
    [
        "STORE_FAST",
        "fmt"
    ],
    [
        "LOAD_FAST",
        "fmt"
    ],
    [
        "LOAD_ATTR",
        "fmt.format"
    ],
    [
        "LOAD_FAST",
        "hh"
    ],
    [
        "LOAD_FAST",
        "mm"
    ],
    [
        "LOAD_FAST",
        "ss"
    ],
    [
        "LOAD_FAST",
        "us"
    ],
    [
        "CALL",
        "fmt.format(hh, mm, ss, us)"
    ],
    [
        "LOAD_GLOBAL",
        "KeyError"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "CALL",
        "ValueError('Unknown timespec value')"
    ],
    [
        "STORE_FAST",
        "s"
    ],
    [
        "LOAD_FAST",
        "off"
    ],
    [
        "LOAD_FAST",
        "off"
    ],
    [
        "LOAD_ATTR",
        "off.days"
    ],
    [
        "COMPARE_OP",
        "off.days < 0"
    ],
    [
        "STORE_FAST",
        "sign"
    ],
    [
        "LOAD_FAST",
        "off"
    ],
    [
        "UNARY_NEGATIVE",
        "-off"
    ],
    [
        "STORE_FAST",
        "off"
    ],
    [
        "STORE_FAST",
        "sign"
    ],
    [
        "LOAD_GLOBAL",
        "divmod"
    ],
    [
        "LOAD_FAST",
        "off"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "CALL",
        "timedelta(hours=1)"
    ],
    [
        "CALL",
        "divmod(off, timedelta(hours=1))"
    ],
    [
        "STORE_FAST",
        "hh"
    ],
    [
        "STORE_FAST",
        "mm"
    ],
    [
        "LOAD_GLOBAL",
        "divmod"
    ],
    [
        "LOAD_FAST",
        "mm"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "CALL",
        "timedelta(minutes=1)"
    ],
    [
        "CALL",
        "divmod(mm, timedelta(minutes=1))"
    ],
    [
        "STORE_FAST",
        "mm"
    ],
    [
        "STORE_FAST",
        "ss"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "LOAD_FAST",
        "sign"
    ],
    [
        "LOAD_FAST",
        "hh"
    ],
    [
        "LOAD_FAST",
        "mm"
    ],
    [
        "BINARY_OP",
        "\"%s%02d:%02d\" % (sign, hh, mm)"
    ],
    [
        "BINARY_OP",
        "s += \"%s%02d:%02d\" % (sign, hh, mm)"
    ],
    [
        "STORE_FAST",
        "s"
    ],
    [
        "LOAD_FAST",
        "ss"
    ],
    [
        "LOAD_FAST",
        "ss"
    ],
    [
        "LOAD_ATTR",
        "ss.microseconds"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "LOAD_FAST",
        "ss"
    ],
    [
        "LOAD_ATTR",
        "ss.seconds"
    ],
    [
        "BINARY_OP",
        "\":%02d\" % ss.seconds"
    ],
    [
        "BINARY_OP",
        "s += \":%02d\" % ss.seconds"
    ],
    [
        "STORE_FAST",
        "s"
    ],
    [
        "LOAD_FAST",
        "ss"
    ],
    [
        "LOAD_ATTR",
        "ss.microseconds"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "LOAD_FAST",
        "ss"
    ],
    [
        "LOAD_ATTR",
        "ss.microseconds"
    ],
    [
        "BINARY_OP",
        "'.%06d' % ss.microseconds"
    ],
    [
        "BINARY_OP",
        "s += '.%06d' % ss.microseconds"
    ],
    [
        "STORE_FAST",
        "s"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "STORE_FAST",
        "freplace"
    ],
    [
        "STORE_FAST",
        "zreplace"
    ],
    [
        "STORE_FAST",
        "Zreplace"
    ],
    [
        "STORE_FAST",
        "newformat"
    ],
    [
        "LOAD_FAST",
        "newformat"
    ],
    [
        "LOAD_ATTR",
        "newformat.append"
    ],
    [
        "STORE_FAST",
        "push"
    ],
    [
        "LOAD_GLOBAL",
        "len"
    ],
    [
        "LOAD_FAST",
        "format"
    ],
    [
        "CALL",
        "len(format)"
    ],
    [
        "STORE_FAST",
        "n"
    ],
    [
        "STORE_FAST",
        "i"
    ],
    [
        "LOAD_FAST",
        "i"
    ],
    [
        "LOAD_FAST",
        "n"
    ],
    [
        "COMPARE_OP",
        "i < n"
    ],
    [
        "LOAD_FAST",
        "format"
    ],
    [
        "LOAD_FAST",
        "i"
    ],
    [
        "BINARY_SUBSCR",
        "format[i]"
    ],
    [
        "STORE_FAST",
        "ch"
    ],
    [
        "LOAD_FAST",
        "i"
    ],
    [
        "BINARY_OP",
        "i += 1"
    ],
    [
        "STORE_FAST",
        "i"
    ],
    [
        "LOAD_FAST",
        "ch"
    ],
    [
        "COMPARE_OP",
        "ch == '%'"
    ],
    [
        "LOAD_FAST",
        "i"
    ],
    [
        "LOAD_FAST",
        "n"
    ],
    [
        "COMPARE_OP",
        "i < n"
    ],
    [
        "LOAD_FAST",
        "format"
    ],
    [
        "LOAD_FAST",
        "i"
    ],
    [
        "BINARY_SUBSCR",
        "format[i]"
    ],
    [
        "STORE_FAST",
        "ch"
    ],
    [
        "LOAD_FAST",
        "i"
    ],
    [
        "BINARY_OP",
        "i += 1"
    ],
    [
        "STORE_FAST",
        "i"
    ],
    [
        "LOAD_FAST",
        "ch"
    ],
    [
        "COMPARE_OP",
        "ch == 'f'"
    ],
    [
        "LOAD_FAST",
        "freplace"
    ],
    [
        "LOAD_GLOBAL",
        "getattr"
    ],
    [
        "LOAD_FAST",
        "object"
    ],
    [
        "CALL",
        "getattr(object,\n                                                    'microsecond', 0)"
    ],
    [
        "BINARY_OP",
        "'%06d' % getattr(object,\n                                                    'microsecond', 0)"
    ],
    [
        "STORE_FAST",
        "freplace"
    ],
    [
        "LOAD_FAST",
        "newformat"
    ],
    [
        "LOAD_ATTR",
        "newformat.append"
    ],
    [
        "LOAD_FAST",
        "freplace"
    ],
    [
        "CALL",
        "newformat.append(freplace)"
    ],
    [
        "LOAD_FAST",
        "ch"
    ],
    [
        "COMPARE_OP",
        "ch == 'z'"
    ],
    [
        "LOAD_FAST",
        "zreplace"
    ],
    [
        "STORE_FAST",
        "zreplace"
    ],
    [
        "LOAD_GLOBAL",
        "hasattr"
    ],
    [
        "LOAD_FAST",
        "object"
    ],
    [
        "CALL",
        "hasattr(object, \"utcoffset\")"
    ],
    [
        "LOAD_FAST",
        "object"
    ],
    [
        "LOAD_ATTR",
        "object.utcoffset"
    ],
    [
        "CALL",
        "object.utcoffset()"
    ],
    [
        "STORE_FAST",
        "offset"
    ],
    [
        "LOAD_FAST",
        "offset"
    ],
    [
        "STORE_FAST",
        "sign"
    ],
    [
        "LOAD_FAST",
        "offset"
    ],
    [
        "LOAD_ATTR",
        "offset.days"
    ],
    [
        "COMPARE_OP",
        "offset.days < 0"
    ],
    [
        "LOAD_FAST",
        "offset"
    ],
    [
        "UNARY_NEGATIVE",
        "-offset"
    ],
    [
        "STORE_FAST",
        "offset"
    ],
    [
        "STORE_FAST",
        "sign"
    ],
    [
        "LOAD_GLOBAL",
        "divmod"
    ],
    [
        "LOAD_FAST",
        "offset"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "CALL",
        "timedelta(hours=1)"
    ],
    [
        "CALL",
        "divmod(offset, timedelta(hours=1))"
    ],
    [
        "STORE_FAST",
        "h"
    ],
    [
        "STORE_FAST",
        "rest"
    ],
    [
        "LOAD_GLOBAL",
        "divmod"
    ],
    [
        "LOAD_FAST",
        "rest"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "CALL",
        "timedelta(minutes=1)"
    ],
    [
        "CALL",
        "divmod(rest, timedelta(minutes=1))"
    ],
    [
        "STORE_FAST",
        "m"
    ],
    [
        "STORE_FAST",
        "rest"
    ],
    [
        "LOAD_FAST",
        "rest"
    ],
    [
        "LOAD_ATTR",
        "rest.seconds"
    ],
    [
        "STORE_FAST",
        "s"
    ],
    [
        "LOAD_FAST",
        "offset"
    ],
    [
        "LOAD_ATTR",
        "offset.microseconds"
    ],
    [
        "STORE_FAST",
        "u"
    ],
    [
        "LOAD_FAST",
        "u"
    ],
    [
        "LOAD_FAST",
        "sign"
    ],
    [
        "LOAD_FAST",
        "h"
    ],
    [
        "LOAD_FAST",
        "m"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "LOAD_FAST",
        "u"
    ],
    [
        "BINARY_OP",
        "'%c%02d%02d%02d.%06d' % (sign, h, m, s, u)"
    ],
    [
        "STORE_FAST",
        "zreplace"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "LOAD_FAST",
        "sign"
    ],
    [
        "LOAD_FAST",
        "h"
    ],
    [
        "LOAD_FAST",
        "m"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "BINARY_OP",
        "'%c%02d%02d%02d' % (sign, h, m, s)"
    ],
    [
        "STORE_FAST",
        "zreplace"
    ],
    [
        "LOAD_FAST",
        "sign"
    ],
    [
        "LOAD_FAST",
        "h"
    ],
    [
        "LOAD_FAST",
        "m"
    ],
    [
        "BINARY_OP",
        "'%c%02d%02d' % (sign, h, m)"
    ],
    [
        "STORE_FAST",
        "zreplace"
    ],
    [
        "LOAD_FAST",
        "zreplace"
    ],
    [
        "CONTAINS_OP",
        "'%' not in zreplace"
    ],
    [
        "LOAD_FAST",
        "newformat"
    ],
    [
        "LOAD_ATTR",
        "newformat.append"
    ],
    [
        "LOAD_FAST",
        "zreplace"
    ],
    [
        "CALL",
        "newformat.append(zreplace)"
    ],
    [
        "LOAD_FAST",
        "ch"
    ],
    [
        "COMPARE_OP",
        "ch == 'Z'"
    ],
    [
        "LOAD_FAST",
        "Zreplace"
    ],
    [
        "STORE_FAST",
        "Zreplace"
    ],
    [
        "LOAD_GLOBAL",
        "hasattr"
    ],
    [
        "LOAD_FAST",
        "object"
    ],
    [
        "CALL",
        "hasattr(object, \"tzname\")"
    ],
    [
        "LOAD_FAST",
        "object"
    ],
    [
        "LOAD_ATTR",
        "object.tzname"
    ],
    [
        "CALL",
        "object.tzname()"
    ],
    [
        "STORE_FAST",
        "s"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "LOAD_ATTR",
        "s.replace"
    ],
    [
        "CALL",
        "s.replace('%', '%%')"
    ],
    [
        "STORE_FAST",
        "Zreplace"
    ],
    [
        "LOAD_FAST",
        "newformat"
    ],
    [
        "LOAD_ATTR",
        "newformat.append"
    ],
    [
        "LOAD_FAST",
        "Zreplace"
    ],
    [
        "CALL",
        "newformat.append(Zreplace)"
    ],
    [
        "LOAD_FAST",
        "push"
    ],
    [
        "CALL",
        "push('%')"
    ],
    [
        "LOAD_FAST",
        "push"
    ],
    [
        "LOAD_FAST",
        "ch"
    ],
    [
        "CALL",
        "push(ch)"
    ],
    [
        "LOAD_FAST",
        "push"
    ],
    [
        "CALL",
        "push('%')"
    ],
    [
        "LOAD_FAST",
        "push"
    ],
    [
        "LOAD_FAST",
        "ch"
    ],
    [
        "CALL",
        "push(ch)"
    ],
    [
        "LOAD_FAST",
        "i"
    ],
    [
        "LOAD_FAST",
        "n"
    ],
    [
        "COMPARE_OP",
        "i < n"
    ],
    [
        "LOAD_ATTR",
        "\"\".join"
    ],
    [
        "LOAD_FAST",
        "newformat"
    ],
    [
        "CALL",
        "\"\".join(newformat)"
    ],
    [
        "STORE_FAST",
        "newformat"
    ],
    [
        "LOAD_GLOBAL",
        "_time"
    ],
    [
        "LOAD_ATTR",
        "_time.strftime"
    ],
    [
        "LOAD_FAST",
        "newformat"
    ],
    [
        "LOAD_FAST",
        "timetuple"
    ],
    [
        "CALL",
        "_time.strftime(newformat, timetuple)"
    ],
    [
        "LOAD_FAST",
        "c"
    ],
    [
        "CONTAINS_OP",
        "c in \"0123456789\""
    ],
    [
        "LOAD_GLOBAL",
        "len"
    ],
    [
        "LOAD_FAST",
        "dtstr"
    ],
    [
        "CALL",
        "len(dtstr)"
    ],
    [
        "STORE_FAST",
        "len_dtstr"
    ],
    [
        "LOAD_FAST",
        "len_dtstr"
    ],
    [
        "COMPARE_OP",
        "len_dtstr == 7"
    ],
    [
        "LOAD_FAST",
        "len_dtstr"
    ],
    [
        "COMPARE_OP",
        "len_dtstr > 7"
    ],
    [
        "STORE_FAST",
        "date_separator"
    ],
    [
        "STORE_FAST",
        "week_indicator"
    ],
    [
        "LOAD_FAST",
        "dtstr"
    ],
    [
        "BINARY_SUBSCR",
        "dtstr[4]"
    ],
    [
        "LOAD_FAST",
        "date_separator"
    ],
    [
        "COMPARE_OP",
        "dtstr[4] == date_separator"
    ],
    [
        "LOAD_FAST",
        "dtstr"
    ],
    [
        "BINARY_SUBSCR",
        "dtstr[5]"
    ],
    [
        "LOAD_FAST",
        "week_indicator"
    ],
    [
        "COMPARE_OP",
        "dtstr[5] == week_indicator"
    ],
    [
        "LOAD_FAST",
        "len_dtstr"
    ],
    [
        "COMPARE_OP",
        "len_dtstr < 8"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "CALL",
        "ValueError(\"Invalid ISO string\")"
    ],
    [
        "LOAD_FAST",
        "len_dtstr"
    ],
    [
        "COMPARE_OP",
        "len_dtstr > 8"
    ],
    [
        "LOAD_FAST",
        "dtstr"
    ],
    [
        "BINARY_SUBSCR",
        "dtstr[8]"
    ],
    [
        "LOAD_FAST",
        "date_separator"
    ],
    [
        "COMPARE_OP",
        "dtstr[8] == date_separator"
    ],
    [
        "LOAD_FAST",
        "len_dtstr"
    ],
    [
        "COMPARE_OP",
        "len_dtstr == 9"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "CALL",
        "ValueError(\"Invalid ISO string\")"
    ],
    [
        "LOAD_FAST",
        "len_dtstr"
    ],
    [
        "COMPARE_OP",
        "len_dtstr > 10"
    ],
    [
        "LOAD_GLOBAL",
        "_is_ascii_digit"
    ],
    [
        "LOAD_FAST",
        "dtstr"
    ],
    [
        "BINARY_SUBSCR",
        "dtstr[10]"
    ],
    [
        "CALL",
        "_is_ascii_digit(dtstr[10])"
    ],
    [
        "LOAD_FAST",
        "dtstr"
    ],
    [
        "BINARY_SUBSCR",
        "dtstr[4]"
    ],
    [
        "LOAD_FAST",
        "week_indicator"
    ],
    [
        "COMPARE_OP",
        "dtstr[4] == week_indicator"
    ],
    [
        "STORE_FAST",
        "idx"
    ],
    [
        "LOAD_FAST",
        "idx"
    ],
    [
        "LOAD_FAST",
        "len_dtstr"
    ],
    [
        "COMPARE_OP",
        "idx < len_dtstr"
    ],
    [
        "LOAD_GLOBAL",
        "_is_ascii_digit"
    ],
    [
        "LOAD_FAST",
        "dtstr"
    ],
    [
        "LOAD_FAST",
        "idx"
    ],
    [
        "BINARY_SUBSCR",
        "dtstr[idx]"
    ],
    [
        "CALL",
        "_is_ascii_digit(dtstr[idx])"
    ],
    [
        "LOAD_FAST",
        "idx"
    ],
    [
        "BINARY_OP",
        "idx += 1"
    ],
    [
        "STORE_FAST",
        "idx"
    ],
    [
        "LOAD_FAST",
        "idx"
    ],
    [
        "LOAD_FAST",
        "len_dtstr"
    ],
    [
        "COMPARE_OP",
        "idx < len_dtstr"
    ],
    [
        "LOAD_FAST",
        "idx"
    ],
    [
        "COMPARE_OP",
        "idx < 9"
    ],
    [
        "LOAD_FAST",
        "idx"
    ],
    [
        "LOAD_FAST",
        "idx"
    ],
    [
        "BINARY_OP",
        "idx % 2"
    ],
    [
        "COMPARE_OP",
        "idx % 2 == 0"
    ],
    [
        "LOAD_GLOBAL",
        "len"
    ],
    [
        "LOAD_FAST",
        "dtstr"
    ],
    [
        "CALL",
        "len(dtstr)"
    ],
    [
        "CONTAINS_OP",
        "len(dtstr) in (7, 8, 10)"
    ],
    [
        "LOAD_GLOBAL",
        "int"
    ],
    [
        "LOAD_FAST",
        "dtstr"
    ],
    [
        "BINARY_SLICE",
        "dtstr[0:4]"
    ],
    [
        "CALL",
        "int(dtstr[0:4])"
    ],
    [
        "STORE_FAST",
        "year"
    ],
    [
        "LOAD_FAST",
        "dtstr"
    ],
    [
        "BINARY_SUBSCR",
        "dtstr[4]"
    ],
    [
        "COMPARE_OP",
        "dtstr[4] == '-'"
    ],
    [
        "STORE_FAST",
        "has_sep"
    ],
    [
        "LOAD_FAST",
        "has_sep"
    ],
    [
        "BINARY_OP",
        "4 + has_sep"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "dtstr"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos + 1"
    ],
    [
        "BINARY_SLICE",
        "dtstr[pos:pos + 1]"
    ],
    [
        "COMPARE_OP",
        "dtstr[pos:pos + 1] == \"W\""
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos += 1"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "int"
    ],
    [
        "LOAD_FAST",
        "dtstr"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos + 2"
    ],
    [
        "BINARY_SLICE",
        "dtstr[pos:pos + 2]"
    ],
    [
        "CALL",
        "int(dtstr[pos:pos + 2])"
    ],
    [
        "STORE_FAST",
        "weekno"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos += 2"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "STORE_FAST",
        "dayno"
    ],
    [
        "LOAD_GLOBAL",
        "len"
    ],
    [
        "LOAD_FAST",
        "dtstr"
    ],
    [
        "CALL",
        "len(dtstr)"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "COMPARE_OP",
        "len(dtstr) > pos"
    ],
    [
        "LOAD_FAST",
        "dtstr"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos + 1"
    ],
    [
        "BINARY_SLICE",
        "dtstr[pos:pos + 1]"
    ],
    [
        "COMPARE_OP",
        "dtstr[pos:pos + 1] == '-'"
    ],
    [
        "LOAD_FAST",
        "has_sep"
    ],
    [
        "COMPARE_OP",
        "(dtstr[pos:pos + 1] == '-') != has_sep"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "CALL",
        "ValueError(\"Inconsistent use of dash separator\")"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "has_sep"
    ],
    [
        "BINARY_OP",
        "pos += has_sep"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "int"
    ],
    [
        "LOAD_FAST",
        "dtstr"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos + 1"
    ],
    [
        "BINARY_SLICE",
        "dtstr[pos:pos + 1]"
    ],
    [
        "CALL",
        "int(dtstr[pos:pos + 1])"
    ],
    [
        "STORE_FAST",
        "dayno"
    ],
    [
        "LOAD_GLOBAL",
        "list"
    ],
    [
        "LOAD_GLOBAL",
        "_isoweek_to_gregorian"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "LOAD_FAST",
        "weekno"
    ],
    [
        "LOAD_FAST",
        "dayno"
    ],
    [
        "CALL",
        "_isoweek_to_gregorian(year, weekno, dayno)"
    ],
    [
        "CALL",
        "list(_isoweek_to_gregorian(year, weekno, dayno))"
    ],
    [
        "LOAD_GLOBAL",
        "int"
    ],
    [
        "LOAD_FAST",
        "dtstr"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos + 2"
    ],
    [
        "BINARY_SLICE",
        "dtstr[pos:pos + 2]"
    ],
    [
        "CALL",
        "int(dtstr[pos:pos + 2])"
    ],
    [
        "STORE_FAST",
        "month"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos += 2"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "dtstr"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos + 1"
    ],
    [
        "BINARY_SLICE",
        "dtstr[pos:pos + 1]"
    ],
    [
        "COMPARE_OP",
        "dtstr[pos:pos + 1] == \"-\""
    ],
    [
        "LOAD_FAST",
        "has_sep"
    ],
    [
        "COMPARE_OP",
        "(dtstr[pos:pos + 1] == \"-\") != has_sep"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "CALL",
        "ValueError(\"Inconsistent use of dash separator\")"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "has_sep"
    ],
    [
        "BINARY_OP",
        "pos += has_sep"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "int"
    ],
    [
        "LOAD_FAST",
        "dtstr"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos + 2"
    ],
    [
        "BINARY_SLICE",
        "dtstr[pos:pos + 2]"
    ],
    [
        "CALL",
        "int(dtstr[pos:pos + 2])"
    ],
    [
        "STORE_FAST",
        "day"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "LOAD_FAST",
        "month"
    ],
    [
        "LOAD_FAST",
        "day"
    ],
    [
        "LOAD_GLOBAL",
        "len"
    ],
    [
        "LOAD_FAST",
        "tstr"
    ],
    [
        "CALL",
        "len(tstr)"
    ],
    [
        "STORE_FAST",
        "len_str"
    ],
    [
        "STORE_FAST",
        "time_comps"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_GLOBAL",
        "range"
    ],
    [
        "CALL",
        "range(0, 3)"
    ],
    [
        "STORE_FAST",
        "comp"
    ],
    [
        "LOAD_FAST",
        "len_str"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "len_str - pos"
    ],
    [
        "COMPARE_OP",
        "(len_str - pos) < 2"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "CALL",
        "ValueError(\"Incomplete time component\")"
    ],
    [
        "LOAD_GLOBAL",
        "int"
    ],
    [
        "LOAD_FAST",
        "tstr"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos+2"
    ],
    [
        "BINARY_SLICE",
        "tstr[pos:pos+2]"
    ],
    [
        "CALL",
        "int(tstr[pos:pos+2])"
    ],
    [
        "LOAD_FAST",
        "time_comps"
    ],
    [
        "LOAD_FAST",
        "comp"
    ],
    [
        "STORE_SUBSCR",
        "time_comps[comp]"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos += 2"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "tstr"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos+1"
    ],
    [
        "BINARY_SLICE",
        "tstr[pos:pos+1]"
    ],
    [
        "STORE_FAST",
        "next_char"
    ],
    [
        "LOAD_FAST",
        "comp"
    ],
    [
        "COMPARE_OP",
        "comp == 0"
    ],
    [
        "LOAD_FAST",
        "next_char"
    ],
    [
        "COMPARE_OP",
        "next_char == ':'"
    ],
    [
        "STORE_FAST",
        "has_sep"
    ],
    [
        "LOAD_FAST",
        "next_char"
    ],
    [
        "LOAD_FAST",
        "comp"
    ],
    [
        "COMPARE_OP",
        "comp >= 2"
    ],
    [
        "LOAD_FAST_CHECK",
        "has_sep"
    ],
    [
        "LOAD_FAST",
        "next_char"
    ],
    [
        "COMPARE_OP",
        "next_char != ':'"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "LOAD_FAST",
        "next_char"
    ],
    [
        "BINARY_OP",
        "\"Invalid time separator: %c\" % next_char"
    ],
    [
        "CALL",
        "ValueError(\"Invalid time separator: %c\" % next_char)"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "has_sep"
    ],
    [
        "BINARY_OP",
        "pos += has_sep"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "len_str"
    ],
    [
        "COMPARE_OP",
        "pos < len_str"
    ],
    [
        "LOAD_FAST",
        "tstr"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_SUBSCR",
        "tstr[pos]"
    ],
    [
        "CONTAINS_OP",
        "tstr[pos] not in '.,'"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "CALL",
        "ValueError(\"Invalid microsecond component\")"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "pos += 1"
    ],
    [
        "STORE_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "len_str"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "BINARY_OP",
        "len_str - pos"
    ],
    [
        "STORE_FAST",
        "len_remainder"
    ],
    [
        "LOAD_FAST",
        "len_remainder"
    ],
    [
        "COMPARE_OP",
        "len_remainder >= 6"
    ],
    [
        "STORE_FAST",
        "to_parse"
    ],
    [
        "LOAD_FAST",
        "len_remainder"
    ],
    [
        "STORE_FAST",
        "to_parse"
    ],
    [
        "LOAD_GLOBAL",
        "int"
    ],
    [
        "LOAD_FAST",
        "tstr"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "to_parse"
    ],
    [
        "BINARY_OP",
        "pos+to_parse"
    ],
    [
        "BINARY_SLICE",
        "tstr[pos:(pos+to_parse)]"
    ],
    [
        "CALL",
        "int(tstr[pos:(pos+to_parse)])"
    ],
    [
        "LOAD_FAST",
        "time_comps"
    ],
    [
        "STORE_SUBSCR",
        "time_comps[3]"
    ],
    [
        "LOAD_FAST",
        "to_parse"
    ],
    [
        "COMPARE_OP",
        "to_parse < 6"
    ],
    [
        "LOAD_FAST",
        "time_comps"
    ],
    [
        "BINARY_SUBSCR",
        "time_comps[3]"
    ],
    [
        "LOAD_GLOBAL",
        "_FRACTION_CORRECTION"
    ],
    [
        "LOAD_FAST",
        "to_parse"
    ],
    [
        "BINARY_OP",
        "to_parse-1"
    ],
    [
        "BINARY_SUBSCR",
        "_FRACTION_CORRECTION[to_parse-1]"
    ],
    [
        "BINARY_OP",
        "time_comps[3] *= _FRACTION_CORRECTION[to_parse-1]"
    ],
    [
        "STORE_SUBSCR",
        "time_comps[3]"
    ],
    [
        "LOAD_FAST",
        "len_remainder"
    ],
    [
        "LOAD_FAST",
        "to_parse"
    ],
    [
        "COMPARE_OP",
        "len_remainder > to_parse"
    ],
    [
        "LOAD_GLOBAL",
        "all"
    ],
    [
        "LOAD_GLOBAL",
        "map"
    ],
    [
        "LOAD_GLOBAL",
        "_is_ascii_digit"
    ],
    [
        "LOAD_FAST",
        "tstr"
    ],
    [
        "LOAD_FAST",
        "pos"
    ],
    [
        "LOAD_FAST",
        "to_parse"
    ],
    [
        "BINARY_OP",
        "pos+to_parse"
    ],
    [
        "BINARY_SLICE",
        "tstr[(pos+to_parse):]"
    ],
    [
        "CALL",
        "map(_is_ascii_digit, tstr[(pos+to_parse):])"
    ],
    [
        "CALL",
        "all(map(_is_ascii_digit, tstr[(pos+to_parse):]))"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "CALL",
        "ValueError(\"Non-digit values in unparsed fraction\")"
    ],
    [
        "LOAD_FAST",
        "time_comps"
    ],
    [
        "LOAD_GLOBAL",
        "len"
    ],
    [
        "LOAD_FAST",
        "tstr"
    ],
    [
        "CALL",
        "len(tstr)"
    ],
    [
        "STORE_FAST",
        "len_str"
    ],
    [
        "LOAD_FAST",
        "len_str"
    ],
    [
        "COMPARE_OP",
        "len_str < 2"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "CALL",
        "ValueError(\"Isoformat time too short\")"
    ],
    [
        "LOAD_FAST",
        "tstr"
    ],
    [
        "LOAD_ATTR",
        "tstr.find"
    ],
    [
        "CALL",
        "tstr.find('-')"
    ],
    [
        "BINARY_OP",
        "tstr.find('-') + 1"
    ],
    [
        "LOAD_FAST",
        "tstr"
    ],
    [
        "LOAD_ATTR",
        "tstr.find"
    ],
    [
        "CALL",
        "tstr.find('+')"
    ],
    [
        "BINARY_OP",
        "tstr.find('+') + 1"
    ],
    [
        "LOAD_FAST",
        "tstr"
    ],
    [
        "LOAD_ATTR",
        "tstr.find"
    ],
    [
        "CALL",
        "tstr.find('Z')"
    ],
    [
        "BINARY_OP",
        "tstr.find('Z') + 1"
    ],
    [
        "STORE_FAST",
        "tz_pos"
    ],
    [
        "LOAD_FAST",
        "tz_pos"
    ],
    [
        "COMPARE_OP",
        "tz_pos > 0"
    ],
    [
        "LOAD_FAST",
        "tstr"
    ],
    [
        "LOAD_FAST",
        "tz_pos"
    ],
    [
        "BINARY_OP",
        "tz_pos-1"
    ],
    [
        "BINARY_SLICE",
        "tstr[:tz_pos-1]"
    ],
    [
        "LOAD_FAST",
        "tstr"
    ],
    [
        "STORE_FAST",
        "timestr"
    ],
    [
        "LOAD_GLOBAL",
        "_parse_hh_mm_ss_ff"
    ],
    [
        "LOAD_FAST",
        "timestr"
    ],
    [
        "CALL",
        "_parse_hh_mm_ss_ff(timestr)"
    ],
    [
        "STORE_FAST",
        "time_comps"
    ],
    [
        "STORE_FAST",
        "tzi"
    ],
    [
        "LOAD_FAST",
        "tz_pos"
    ],
    [
        "LOAD_FAST",
        "len_str"
    ],
    [
        "COMPARE_OP",
        "tz_pos == len_str"
    ],
    [
        "LOAD_FAST",
        "tstr"
    ],
    [
        "BINARY_SUBSCR",
        "tstr[-1]"
    ],
    [
        "COMPARE_OP",
        "tstr[-1] == 'Z'"
    ],
    [
        "LOAD_GLOBAL",
        "timezone"
    ],
    [
        "LOAD_ATTR",
        "timezone.utc"
    ],
    [
        "STORE_FAST",
        "tzi"
    ],
    [
        "LOAD_FAST",
        "tz_pos"
    ],
    [
        "COMPARE_OP",
        "tz_pos > 0"
    ],
    [
        "LOAD_FAST",
        "tstr"
    ],
    [
        "LOAD_FAST",
        "tz_pos"
    ],
    [
        "BINARY_SLICE",
        "tstr[tz_pos:]"
    ],
    [
        "STORE_FAST",
        "tzstr"
    ],
    [
        "LOAD_GLOBAL",
        "len"
    ],
    [
        "LOAD_FAST",
        "tzstr"
    ],
    [
        "CALL",
        "len(tzstr)"
    ],
    [
        "CONTAINS_OP",
        "len(tzstr) in (0, 1, 3)"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "CALL",
        "ValueError(\"Malformed time zone string\")"
    ],
    [
        "LOAD_GLOBAL",
        "_parse_hh_mm_ss_ff"
    ],
    [
        "LOAD_FAST",
        "tzstr"
    ],
    [
        "CALL",
        "_parse_hh_mm_ss_ff(tzstr)"
    ],
    [
        "STORE_FAST",
        "tz_comps"
    ],
    [
        "LOAD_GLOBAL",
        "all"
    ],
    [
        "LOAD_FAST",
        "tz_comps"
    ],
    [
        "CALL",
        "(x == 0 for x in tz_comps)"
    ],
    [
        "CALL",
        "all(x == 0 for x in tz_comps)"
    ],
    [
        "LOAD_GLOBAL",
        "timezone"
    ],
    [
        "LOAD_ATTR",
        "timezone.utc"
    ],
    [
        "STORE_FAST",
        "tzi"
    ],
    [
        "LOAD_FAST",
        "tstr"
    ],
    [
        "LOAD_FAST",
        "tz_pos"
    ],
    [
        "BINARY_OP",
        "tz_pos - 1"
    ],
    [
        "BINARY_SUBSCR",
        "tstr[tz_pos - 1]"
    ],
    [
        "COMPARE_OP",
        "tstr[tz_pos - 1] == '-'"
    ],
    [
        "STORE_FAST",
        "tzsign"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "LOAD_FAST",
        "tz_comps"
    ],
    [
        "BINARY_SUBSCR",
        "tz_comps[0]"
    ],
    [
        "LOAD_FAST",
        "tz_comps"
    ],
    [
        "BINARY_SUBSCR",
        "tz_comps[1]"
    ],
    [
        "LOAD_FAST",
        "tz_comps"
    ],
    [
        "BINARY_SUBSCR",
        "tz_comps[2]"
    ],
    [
        "LOAD_FAST",
        "tz_comps"
    ],
    [
        "BINARY_SUBSCR",
        "tz_comps[3]"
    ],
    [
        "CALL",
        "timedelta(hours=tz_comps[0], minutes=tz_comps[1],\n                           seconds=tz_comps[2], microseconds=tz_comps[3])"
    ],
    [
        "STORE_FAST",
        "td"
    ],
    [
        "LOAD_GLOBAL",
        "timezone"
    ],
    [
        "LOAD_FAST",
        "tzsign"
    ],
    [
        "LOAD_FAST",
        "td"
    ],
    [
        "BINARY_OP",
        "tzsign * td"
    ],
    [
        "CALL",
        "timezone(tzsign * td)"
    ],
    [
        "STORE_FAST",
        "tzi"
    ],
    [
        "LOAD_FAST",
        "time_comps"
    ],
    [
        "LOAD_ATTR",
        "time_comps.append"
    ],
    [
        "LOAD_FAST",
        "tzi"
    ],
    [
        "CALL",
        "time_comps.append(tzi)"
    ],
    [
        "LOAD_FAST",
        "time_comps"
    ],
    [
        "LOAD_FAST",
        "(x == 0 for x in tz_comps)"
    ],
    [
        "STORE_FAST",
        "x"
    ],
    [
        "LOAD_FAST",
        "x"
    ],
    [
        "COMPARE_OP",
        "x == 0"
    ],
    [
        "LOAD_GLOBAL",
        "MINYEAR"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "COMPARE_OP",
        "MINYEAR <= year <= MAXYEAR"
    ],
    [
        "LOAD_GLOBAL",
        "MAXYEAR"
    ],
    [
        "COMPARE_OP",
        "MINYEAR <= year <= MAXYEAR"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "BUILD_STRING",
        "f\"Year is out of range: {year}\""
    ],
    [
        "CALL",
        "ValueError(f\"Year is out of range: {year}\")"
    ],
    [
        "LOAD_FAST",
        "week"
    ],
    [
        "COMPARE_OP",
        "0 < week < 53"
    ],
    [
        "COMPARE_OP",
        "0 < week < 53"
    ],
    [
        "STORE_FAST",
        "out_of_range"
    ],
    [
        "LOAD_FAST",
        "week"
    ],
    [
        "COMPARE_OP",
        "week == 53"
    ],
    [
        "LOAD_GLOBAL",
        "_ymd2ord"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "CALL",
        "_ymd2ord(year, 1, 1)"
    ],
    [
        "BINARY_OP",
        "_ymd2ord(year, 1, 1) % 7"
    ],
    [
        "STORE_FAST",
        "first_weekday"
    ],
    [
        "LOAD_FAST",
        "first_weekday"
    ],
    [
        "COMPARE_OP",
        "first_weekday == 4"
    ],
    [
        "LOAD_FAST",
        "first_weekday"
    ],
    [
        "COMPARE_OP",
        "first_weekday == 3"
    ],
    [
        "LOAD_GLOBAL",
        "_is_leap"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "CALL",
        "_is_leap(year)"
    ],
    [
        "STORE_FAST",
        "out_of_range"
    ],
    [
        "LOAD_FAST",
        "out_of_range"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "LOAD_FAST",
        "week"
    ],
    [
        "BUILD_STRING",
        "f\"Invalid week: {week}\""
    ],
    [
        "CALL",
        "ValueError(f\"Invalid week: {week}\")"
    ],
    [
        "LOAD_FAST",
        "day"
    ],
    [
        "COMPARE_OP",
        "0 < day < 8"
    ],
    [
        "COMPARE_OP",
        "0 < day < 8"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "LOAD_FAST",
        "day"
    ],
    [
        "BUILD_STRING",
        "f\"Invalid weekday: {day} (range is [1, 7])\""
    ],
    [
        "CALL",
        "ValueError(f\"Invalid weekday: {day} (range is [1, 7])\")"
    ],
    [
        "LOAD_FAST",
        "week"
    ],
    [
        "BINARY_OP",
        "week - 1"
    ],
    [
        "BINARY_OP",
        "(week - 1) * 7"
    ],
    [
        "LOAD_FAST",
        "day"
    ],
    [
        "BINARY_OP",
        "day - 1"
    ],
    [
        "BINARY_OP",
        "(week - 1) * 7 + (day - 1)"
    ],
    [
        "STORE_FAST",
        "day_offset"
    ],
    [
        "LOAD_GLOBAL",
        "_isoweek1monday"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "CALL",
        "_isoweek1monday(year)"
    ],
    [
        "STORE_FAST",
        "day_1"
    ],
    [
        "LOAD_FAST",
        "day_1"
    ],
    [
        "LOAD_FAST",
        "day_offset"
    ],
    [
        "BINARY_OP",
        "day_1 + day_offset"
    ],
    [
        "STORE_FAST",
        "ord_day"
    ],
    [
        "LOAD_GLOBAL",
        "_ord2ymd"
    ],
    [
        "LOAD_FAST",
        "ord_day"
    ],
    [
        "CALL",
        "_ord2ymd(ord_day)"
    ],
    [
        "LOAD_FAST",
        "name"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "name"
    ],
    [
        "LOAD_GLOBAL",
        "str"
    ],
    [
        "CALL",
        "isinstance(name, str)"
    ],
    [
        "LOAD_GLOBAL",
        "TypeError"
    ],
    [
        "LOAD_GLOBAL",
        "type"
    ],
    [
        "LOAD_FAST",
        "name"
    ],
    [
        "CALL",
        "type(name)"
    ],
    [
        "BINARY_OP",
        "\"tzinfo.tzname() must return None or string, \"\n                        \"not '%s'\" % type(name)"
    ],
    [
        "CALL",
        "TypeError(\"tzinfo.tzname() must return None or string, \"\n                        \"not '%s'\" % type(name))"
    ],
    [
        "LOAD_FAST",
        "name"
    ],
    [
        "CONTAINS_OP",
        "name in (\"utcoffset\", \"dst\")"
    ],
    [
        "LOAD_FAST",
        "offset"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "offset"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "CALL",
        "isinstance(offset, timedelta)"
    ],
    [
        "LOAD_GLOBAL",
        "TypeError"
    ],
    [
        "LOAD_FAST",
        "name"
    ],
    [
        "LOAD_GLOBAL",
        "type"
    ],
    [
        "LOAD_FAST",
        "offset"
    ],
    [
        "CALL",
        "type(offset)"
    ],
    [
        "BUILD_STRING",
        "\"tzinfo.%s() must return None \"\n                        \"or timedelta, not '%s'\" % (name, type(offset))"
    ],
    [
        "CALL",
        "TypeError(\"tzinfo.%s() must return None \"\n                        \"or timedelta, not '%s'\" % (name, type(offset)))"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "CALL",
        "timedelta(1)"
    ],
    [
        "UNARY_NEGATIVE",
        "-timedelta(1)"
    ],
    [
        "LOAD_FAST",
        "offset"
    ],
    [
        "COMPARE_OP",
        "-timedelta(1) < offset < timedelta(1)"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "CALL",
        "timedelta(1)"
    ],
    [
        "COMPARE_OP",
        "-timedelta(1) < offset < timedelta(1)"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "LOAD_FAST",
        "name"
    ],
    [
        "LOAD_FAST",
        "offset"
    ],
    [
        "BUILD_STRING",
        "\"%s()=%s, must be strictly between \"\n                         \"-timedelta(hours=24) and timedelta(hours=24)\" %\n                         (name, offset)"
    ],
    [
        "CALL",
        "ValueError(\"%s()=%s, must be strictly between \"\n                         \"-timedelta(hours=24) and timedelta(hours=24)\" %\n                         (name, offset))"
    ],
    [
        "LOAD_GLOBAL",
        "_index"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "CALL",
        "_index(year)"
    ],
    [
        "STORE_FAST",
        "year"
    ],
    [
        "LOAD_GLOBAL",
        "_index"
    ],
    [
        "LOAD_FAST",
        "month"
    ],
    [
        "CALL",
        "_index(month)"
    ],
    [
        "STORE_FAST",
        "month"
    ],
    [
        "LOAD_GLOBAL",
        "_index"
    ],
    [
        "LOAD_FAST",
        "day"
    ],
    [
        "CALL",
        "_index(day)"
    ],
    [
        "STORE_FAST",
        "day"
    ],
    [
        "LOAD_GLOBAL",
        "MINYEAR"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "COMPARE_OP",
        "MINYEAR <= year <= MAXYEAR"
    ],
    [
        "LOAD_GLOBAL",
        "MAXYEAR"
    ],
    [
        "COMPARE_OP",
        "MINYEAR <= year <= MAXYEAR"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "LOAD_GLOBAL",
        "MINYEAR"
    ],
    [
        "LOAD_GLOBAL",
        "MAXYEAR"
    ],
    [
        "BINARY_OP",
        "'year must be in %d..%d' % (MINYEAR, MAXYEAR)"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "CALL",
        "ValueError('year must be in %d..%d' % (MINYEAR, MAXYEAR), year)"
    ],
    [
        "LOAD_FAST",
        "month"
    ],
    [
        "COMPARE_OP",
        "1 <= month <= 12"
    ],
    [
        "COMPARE_OP",
        "1 <= month <= 12"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "LOAD_FAST",
        "month"
    ],
    [
        "CALL",
        "ValueError('month must be in 1..12', month)"
    ],
    [
        "LOAD_GLOBAL",
        "_days_in_month"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "LOAD_FAST",
        "month"
    ],
    [
        "CALL",
        "_days_in_month(year, month)"
    ],
    [
        "STORE_FAST",
        "dim"
    ],
    [
        "LOAD_FAST",
        "day"
    ],
    [
        "COMPARE_OP",
        "1 <= day <= dim"
    ],
    [
        "LOAD_FAST",
        "dim"
    ],
    [
        "COMPARE_OP",
        "1 <= day <= dim"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "LOAD_FAST",
        "dim"
    ],
    [
        "BINARY_OP",
        "'day must be in 1..%d' % dim"
    ],
    [
        "LOAD_FAST",
        "day"
    ],
    [
        "CALL",
        "ValueError('day must be in 1..%d' % dim, day)"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "LOAD_FAST",
        "month"
    ],
    [
        "LOAD_FAST",
        "day"
    ],
    [
        "LOAD_GLOBAL",
        "_index"
    ],
    [
        "LOAD_FAST",
        "hour"
    ],
    [
        "CALL",
        "_index(hour)"
    ],
    [
        "STORE_FAST",
        "hour"
    ],
    [
        "LOAD_GLOBAL",
        "_index"
    ],
    [
        "LOAD_FAST",
        "minute"
    ],
    [
        "CALL",
        "_index(minute)"
    ],
    [
        "STORE_FAST",
        "minute"
    ],
    [
        "LOAD_GLOBAL",
        "_index"
    ],
    [
        "LOAD_FAST",
        "second"
    ],
    [
        "CALL",
        "_index(second)"
    ],
    [
        "STORE_FAST",
        "second"
    ],
    [
        "LOAD_GLOBAL",
        "_index"
    ],
    [
        "LOAD_FAST",
        "microsecond"
    ],
    [
        "CALL",
        "_index(microsecond)"
    ],
    [
        "STORE_FAST",
        "microsecond"
    ],
    [
        "LOAD_FAST",
        "hour"
    ],
    [
        "COMPARE_OP",
        "0 <= hour <= 23"
    ],
    [
        "COMPARE_OP",
        "0 <= hour <= 23"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "LOAD_FAST",
        "hour"
    ],
    [
        "CALL",
        "ValueError('hour must be in 0..23', hour)"
    ],
    [
        "LOAD_FAST",
        "minute"
    ],
    [
        "COMPARE_OP",
        "0 <= minute <= 59"
    ],
    [
        "COMPARE_OP",
        "0 <= minute <= 59"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "LOAD_FAST",
        "minute"
    ],
    [
        "CALL",
        "ValueError('minute must be in 0..59', minute)"
    ],
    [
        "LOAD_FAST",
        "second"
    ],
    [
        "COMPARE_OP",
        "0 <= second <= 59"
    ],
    [
        "COMPARE_OP",
        "0 <= second <= 59"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "LOAD_FAST",
        "second"
    ],
    [
        "CALL",
        "ValueError('second must be in 0..59', second)"
    ],
    [
        "LOAD_FAST",
        "microsecond"
    ],
    [
        "COMPARE_OP",
        "0 <= microsecond <= 999999"
    ],
    [
        "COMPARE_OP",
        "0 <= microsecond <= 999999"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "LOAD_FAST",
        "microsecond"
    ],
    [
        "CALL",
        "ValueError('microsecond must be in 0..999999', microsecond)"
    ],
    [
        "LOAD_FAST",
        "fold"
    ],
    [
        "CONTAINS_OP",
        "fold not in (0, 1)"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "LOAD_FAST",
        "fold"
    ],
    [
        "CALL",
        "ValueError('fold must be either 0 or 1', fold)"
    ],
    [
        "LOAD_FAST",
        "hour"
    ],
    [
        "LOAD_FAST",
        "minute"
    ],
    [
        "LOAD_FAST",
        "second"
    ],
    [
        "LOAD_FAST",
        "microsecond"
    ],
    [
        "LOAD_FAST",
        "fold"
    ],
    [
        "LOAD_FAST",
        "tz"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "tz"
    ],
    [
        "LOAD_GLOBAL",
        "tzinfo"
    ],
    [
        "CALL",
        "isinstance(tz, tzinfo)"
    ],
    [
        "LOAD_GLOBAL",
        "TypeError"
    ],
    [
        "CALL",
        "TypeError(\"tzinfo argument must be None or of a tzinfo subclass\")"
    ],
    [
        "LOAD_GLOBAL",
        "TypeError"
    ],
    [
        "LOAD_GLOBAL",
        "type"
    ],
    [
        "LOAD_FAST",
        "x"
    ],
    [
        "CALL",
        "type(x)"
    ],
    [
        "LOAD_ATTR",
        "type(x).__name__"
    ],
    [
        "LOAD_GLOBAL",
        "type"
    ],
    [
        "LOAD_FAST",
        "y"
    ],
    [
        "CALL",
        "type(y)"
    ],
    [
        "LOAD_ATTR",
        "type(y).__name__"
    ],
    [
        "BUILD_STRING",
        "\"can't compare '%s' to '%s'\" % (\n                    type(x).__name__, type(y).__name__)"
    ],
    [
        "CALL",
        "TypeError(\"can't compare '%s' to '%s'\" % (\n                    type(x).__name__, type(y).__name__))"
    ],
    [
        "LOAD_GLOBAL",
        "divmod"
    ],
    [
        "LOAD_FAST",
        "a"
    ],
    [
        "LOAD_FAST",
        "b"
    ],
    [
        "CALL",
        "divmod(a, b)"
    ],
    [
        "STORE_FAST",
        "q"
    ],
    [
        "STORE_FAST",
        "r"
    ],
    [
        "LOAD_FAST",
        "r"
    ],
    [
        "BINARY_OP",
        "r *= 2"
    ],
    [
        "STORE_FAST",
        "r"
    ],
    [
        "LOAD_FAST",
        "b"
    ],
    [
        "COMPARE_OP",
        "b > 0"
    ],
    [
        "LOAD_FAST",
        "r"
    ],
    [
        "LOAD_FAST",
        "b"
    ],
    [
        "COMPARE_OP",
        "r > b"
    ],
    [
        "LOAD_FAST",
        "r"
    ],
    [
        "LOAD_FAST",
        "b"
    ],
    [
        "COMPARE_OP",
        "r < b"
    ],
    [
        "STORE_FAST",
        "greater_than_half"
    ],
    [
        "LOAD_FAST",
        "greater_than_half"
    ],
    [
        "LOAD_FAST",
        "r"
    ],
    [
        "LOAD_FAST",
        "b"
    ],
    [
        "COMPARE_OP",
        "r == b"
    ],
    [
        "LOAD_FAST",
        "q"
    ],
    [
        "BINARY_OP",
        "q % 2"
    ],
    [
        "COMPARE_OP",
        "q % 2 == 1"
    ],
    [
        "LOAD_FAST",
        "q"
    ],
    [
        "BINARY_OP",
        "q += 1"
    ],
    [
        "STORE_FAST",
        "q"
    ],
    [
        "LOAD_FAST",
        "q"
    ],
    [
        "STORE_NAME",
        "\"\"\"Represent the difference between two datetime objects.\n\n    Supported operators:\n\n    - add, subtract timedelta\n    - unary plus, minus, abs\n    - compare to timedelta\n    - multiply, divide by int\n\n    In addition, datetime supports subtraction of two datetime objects\n    returning a timedelta, and addition or subtraction of a datetime\n    and a timedelta giving a datetime.\n\n    Representation: (days, seconds, microseconds).  Why?  Because I\n    felt like it.\n    \"\"\""
    ],
    [
        "STORE_NAME",
        "__slots__"
    ],
    [
        "STORE_NAME",
        "    def __new__(cls, days=0, seconds=0, microseconds=0,\n                milliseconds=0, minutes=0, hours=0, weeks=0):\n        # Doing this efficiently and accurately in C is going to be difficult\n        # and error-prone, due to ubiquitous overflow possibilities, and that\n        # C double doesn't have enough bits of precision to represent\n        # microseconds over 10K years faithfully.  The code here tries to make\n        # explicit where go-fast assumptions can be relied on, in order to\n        # guide the C implementation; it's way more convoluted than speed-\n        # ignoring auto-overflow-to-long idiomatic Python could be.\n\n        # XXX Check that all inputs are ints or floats.\n\n        # Final values, all integer.\n        # s and us fit in 32-bit signed ints; d isn't bounded.\n        d = s = us = 0\n\n        # Normalize everything to days, seconds, microseconds.\n        days += weeks*7\n        seconds += minutes*60 + hours*3600\n        microseconds += milliseconds*1000\n\n        # Get rid of all fractions, and normalize s and us.\n        # Take a deep breath <wink>.\n        if isinstance(days, float):\n            dayfrac, days = _math.modf(days)\n            daysecondsfrac, daysecondswhole = _math.modf(dayfrac * (24.*3600.))\n            assert daysecondswhole == int(daysecondswhole)  # can't overflow\n            s = int(daysecondswhole)\n            assert days == int(days)\n            d = int(days)\n        else:\n            daysecondsfrac = 0.0\n            d = days\n        assert isinstance(daysecondsfrac, float)\n        assert abs(daysecondsfrac) <= 1.0\n        assert isinstance(d, int)\n        assert abs(s) <= 24 * 3600\n        # days isn't referenced again before redefinition\n\n        if isinstance(seconds, float):\n            secondsfrac, seconds = _math.modf(seconds)\n            assert seconds == int(seconds)\n            seconds = int(seconds)\n            secondsfrac += daysecondsfrac\n            assert abs(secondsfrac) <= 2.0\n        else:\n            secondsfrac = daysecondsfrac\n        # daysecondsfrac isn't referenced again\n        assert isinstance(secondsfrac, float)\n        assert abs(secondsfrac) <= 2.0\n\n        assert isinstance(seconds, int)\n        days, seconds = divmod(seconds, 24*3600)\n        d += days\n        s += int(seconds)    # can't overflow\n        assert isinstance(s, int)\n        assert abs(s) <= 2 * 24 * 3600\n        # seconds isn't referenced again before redefinition\n\n        usdouble = secondsfrac * 1e6\n        assert abs(usdouble) < 2.1e6    # exact value not critical\n        # secondsfrac isn't referenced again\n\n        if isinstance(microseconds, float):\n            microseconds = round(microseconds + usdouble)\n            seconds, microseconds = divmod(microseconds, 1000000)\n            days, seconds = divmod(seconds, 24*3600)\n            d += days\n            s += seconds\n        else:\n            microseconds = int(microseconds)\n            seconds, microseconds = divmod(microseconds, 1000000)\n            days, seconds = divmod(seconds, 24*3600)\n            d += days\n            s += seconds\n            microseconds = round(microseconds + usdouble)\n        assert isinstance(s, int)\n        assert isinstance(microseconds, int)\n        assert abs(s) <= 3 * 24 * 3600\n        assert abs(microseconds) < 3.1e6\n\n        # Just a little bit of carrying possible for microseconds and seconds.\n        seconds, us = divmod(microseconds, 1000000)\n        s += seconds\n        days, s = divmod(s, 24*3600)\n        d += days\n\n        assert isinstance(d, int)\n        assert isinstance(s, int) and 0 <= s < 24*3600\n        assert isinstance(us, int) and 0 <= us < 1000000\n\n        if abs(d) > 999999999:\n            raise OverflowError(\"timedelta # of days is too large: %d\" % d)\n\n        self = object.__new__(cls)\n        self._days = d\n        self._seconds = s\n        self._microseconds = us\n        self._hashcode = -1\n        return self"
    ],
    [
        "STORE_NAME",
        "    def __repr__(self):\n        args = []\n        if self._days:\n            args.append(\"days=%d\" % self._days)\n        if self._seconds:\n            args.append(\"seconds=%d\" % self._seconds)\n        if self._microseconds:\n            args.append(\"microseconds=%d\" % self._microseconds)\n        if not args:\n            args.append('0')\n        return \"%s.%s(%s)\" % (self.__class__.__module__,\n                              self.__class__.__qualname__,\n                              ', '.join(args))"
    ],
    [
        "STORE_NAME",
        "    def __str__(self):\n        mm, ss = divmod(self._seconds, 60)\n        hh, mm = divmod(mm, 60)\n        s = \"%d:%02d:%02d\" % (hh, mm, ss)\n        if self._days:\n            def plural(n):\n                return n, abs(n) != 1 and \"s\" or \"\"\n            s = (\"%d day%s, \" % plural(self._days)) + s\n        if self._microseconds:\n            s = s + \".%06d\" % self._microseconds\n        return s"
    ],
    [
        "STORE_NAME",
        "    def total_seconds(self):\n        \"\"\"Total seconds in the duration.\"\"\"\n        return ((self.days * 86400 + self.seconds) * 10**6 +\n                self.microseconds) / 10**6"
    ],
    [
        "LOAD_NAME",
        "property"
    ],
    [
        "CALL",
        "property"
    ],
    [
        "STORE_NAME",
        "    @property\n    def days(self):\n        \"\"\"days\"\"\"\n        return self._days"
    ],
    [
        "LOAD_NAME",
        "property"
    ],
    [
        "CALL",
        "property"
    ],
    [
        "STORE_NAME",
        "    @property\n    def seconds(self):\n        \"\"\"seconds\"\"\"\n        return self._seconds"
    ],
    [
        "LOAD_NAME",
        "property"
    ],
    [
        "CALL",
        "property"
    ],
    [
        "STORE_NAME",
        "    @property\n    def microseconds(self):\n        \"\"\"microseconds\"\"\"\n        return self._microseconds"
    ],
    [
        "STORE_NAME",
        "    def __add__(self, other):\n        if isinstance(other, timedelta):\n            # for CPython compatibility, we cannot use\n            # our __class__ here, but need a real timedelta\n            return timedelta(self._days + other._days,\n                             self._seconds + other._seconds,\n                             self._microseconds + other._microseconds)\n        return NotImplemented"
    ],
    [
        "LOAD_NAME",
        "__add__"
    ],
    [
        "STORE_NAME",
        "__radd__"
    ],
    [
        "STORE_NAME",
        "    def __sub__(self, other):\n        if isinstance(other, timedelta):\n            # for CPython compatibility, we cannot use\n            # our __class__ here, but need a real timedelta\n            return timedelta(self._days - other._days,\n                             self._seconds - other._seconds,\n                             self._microseconds - other._microseconds)\n        return NotImplemented"
    ],
    [
        "STORE_NAME",
        "    def __rsub__(self, other):\n        if isinstance(other, timedelta):\n            return -self + other\n        return NotImplemented"
    ],
    [
        "STORE_NAME",
        "    def __neg__(self):\n        # for CPython compatibility, we cannot use\n        # our __class__ here, but need a real timedelta\n        return timedelta(-self._days,\n                         -self._seconds,\n                         -self._microseconds)"
    ],
    [
        "STORE_NAME",
        "    def __pos__(self):\n        return self"
    ],
    [
        "STORE_NAME",
        "    def __abs__(self):\n        if self._days < 0:\n            return -self\n        else:\n            return self"
    ],
    [
        "STORE_NAME",
        "    def __mul__(self, other):\n        if isinstance(other, int):\n            # for CPython compatibility, we cannot use\n            # our __class__ here, but need a real timedelta\n            return timedelta(self._days * other,\n                             self._seconds * other,\n                             self._microseconds * other)\n        if isinstance(other, float):\n            usec = self._to_microseconds()\n            a, b = other.as_integer_ratio()\n            return timedelta(0, 0, _divide_and_round(usec * a, b))\n        return NotImplemented"
    ],
    [
        "LOAD_NAME",
        "__mul__"
    ],
    [
        "STORE_NAME",
        "__rmul__"
    ],
    [
        "STORE_NAME",
        "    def _to_microseconds(self):\n        return ((self._days * (24*3600) + self._seconds) * 1000000 +\n                self._microseconds)"
    ],
    [
        "STORE_NAME",
        "    def __floordiv__(self, other):\n        if not isinstance(other, (int, timedelta)):\n            return NotImplemented\n        usec = self._to_microseconds()\n        if isinstance(other, timedelta):\n            return usec // other._to_microseconds()\n        if isinstance(other, int):\n            return timedelta(0, 0, usec // other)"
    ],
    [
        "STORE_NAME",
        "    def __truediv__(self, other):\n        if not isinstance(other, (int, float, timedelta)):\n            return NotImplemented\n        usec = self._to_microseconds()\n        if isinstance(other, timedelta):\n            return usec / other._to_microseconds()\n        if isinstance(other, int):\n            return timedelta(0, 0, _divide_and_round(usec, other))\n        if isinstance(other, float):\n            a, b = other.as_integer_ratio()\n            return timedelta(0, 0, _divide_and_round(b * usec, a))"
    ],
    [
        "STORE_NAME",
        "    def __mod__(self, other):\n        if isinstance(other, timedelta):\n            r = self._to_microseconds() % other._to_microseconds()\n            return timedelta(0, 0, r)\n        return NotImplemented"
    ],
    [
        "STORE_NAME",
        "    def __divmod__(self, other):\n        if isinstance(other, timedelta):\n            q, r = divmod(self._to_microseconds(),\n                          other._to_microseconds())\n            return q, timedelta(0, 0, r)\n        return NotImplemented"
    ],
    [
        "STORE_NAME",
        "    def __eq__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) == 0\n        else:\n            return NotImplemented"
    ],
    [
        "STORE_NAME",
        "    def __le__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) <= 0\n        else:\n            return NotImplemented"
    ],
    [
        "STORE_NAME",
        "    def __lt__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) < 0\n        else:\n            return NotImplemented"
    ],
    [
        "STORE_NAME",
        "    def __ge__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) >= 0\n        else:\n            return NotImplemented"
    ],
    [
        "STORE_NAME",
        "    def __gt__(self, other):\n        if isinstance(other, timedelta):\n            return self._cmp(other) > 0\n        else:\n            return NotImplemented"
    ],
    [
        "STORE_NAME",
        "    def _cmp(self, other):\n        assert isinstance(other, timedelta)\n        return _cmp(self._getstate(), other._getstate())"
    ],
    [
        "STORE_NAME",
        "    def __hash__(self):\n        if self._hashcode == -1:\n            self._hashcode = hash(self._getstate())\n        return self._hashcode"
    ],
    [
        "STORE_NAME",
        "    def __bool__(self):\n        return (self._days != 0 or\n                self._seconds != 0 or\n                self._microseconds != 0)"
    ],
    [
        "STORE_NAME",
        "    def _getstate(self):\n        return (self._days, self._seconds, self._microseconds)"
    ],
    [
        "STORE_NAME",
        "    def __reduce__(self):\n        return (self.__class__, self._getstate())"
    ],
    [
        "STORE_FAST",
        "d"
    ],
    [
        "STORE_FAST",
        "s"
    ],
    [
        "STORE_FAST",
        "us"
    ],
    [
        "LOAD_FAST",
        "days"
    ],
    [
        "LOAD_FAST",
        "weeks"
    ],
    [
        "BINARY_OP",
        "weeks*7"
    ],
    [
        "BINARY_OP",
        "days += weeks*7"
    ],
    [
        "STORE_FAST",
        "days"
    ],
    [
        "LOAD_FAST",
        "seconds"
    ],
    [
        "LOAD_FAST",
        "minutes"
    ],
    [
        "BINARY_OP",
        "minutes*60"
    ],
    [
        "LOAD_FAST",
        "hours"
    ],
    [
        "BINARY_OP",
        "hours*3600"
    ],
    [
        "BINARY_OP",
        "minutes*60 + hours*3600"
    ],
    [
        "BINARY_OP",
        "seconds += minutes*60 + hours*3600"
    ],
    [
        "STORE_FAST",
        "seconds"
    ],
    [
        "LOAD_FAST",
        "microseconds"
    ],
    [
        "LOAD_FAST",
        "milliseconds"
    ],
    [
        "BINARY_OP",
        "milliseconds*1000"
    ],
    [
        "BINARY_OP",
        "microseconds += milliseconds*1000"
    ],
    [
        "STORE_FAST",
        "microseconds"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "days"
    ],
    [
        "LOAD_GLOBAL",
        "float"
    ],
    [
        "CALL",
        "isinstance(days, float)"
    ],
    [
        "LOAD_GLOBAL",
        "_math"
    ],
    [
        "LOAD_ATTR",
        "_math.modf"
    ],
    [
        "LOAD_FAST",
        "days"
    ],
    [
        "CALL",
        "_math.modf(days)"
    ],
    [
        "STORE_FAST",
        "dayfrac"
    ],
    [
        "STORE_FAST",
        "days"
    ],
    [
        "LOAD_GLOBAL",
        "_math"
    ],
    [
        "LOAD_ATTR",
        "_math.modf"
    ],
    [
        "LOAD_FAST",
        "dayfrac"
    ],
    [
        "BINARY_OP",
        "dayfrac * (24.*3600.)"
    ],
    [
        "CALL",
        "_math.modf(dayfrac * (24.*3600.))"
    ],
    [
        "STORE_FAST",
        "daysecondsfrac"
    ],
    [
        "STORE_FAST",
        "daysecondswhole"
    ],
    [
        "LOAD_FAST",
        "daysecondswhole"
    ],
    [
        "LOAD_GLOBAL",
        "int"
    ],
    [
        "LOAD_FAST",
        "daysecondswhole"
    ],
    [
        "CALL",
        "int(daysecondswhole)"
    ],
    [
        "COMPARE_OP",
        "daysecondswhole == int(daysecondswhole)"
    ],
    [
        "LOAD_GLOBAL",
        "int"
    ],
    [
        "LOAD_FAST",
        "daysecondswhole"
    ],
    [
        "CALL",
        "int(daysecondswhole)"
    ],
    [
        "STORE_FAST",
        "s"
    ],
    [
        "LOAD_FAST",
        "days"
    ],
    [
        "LOAD_GLOBAL",
        "int"
    ],
    [
        "LOAD_FAST",
        "days"
    ],
    [
        "CALL",
        "int(days)"
    ],
    [
        "COMPARE_OP",
        "days == int(days)"
    ],
    [
        "LOAD_GLOBAL",
        "int"
    ],
    [
        "LOAD_FAST",
        "days"
    ],
    [
        "CALL",
        "int(days)"
    ],
    [
        "STORE_FAST",
        "d"
    ],
    [
        "STORE_FAST",
        "daysecondsfrac"
    ],
    [
        "LOAD_FAST",
        "days"
    ],
    [
        "STORE_FAST",
        "d"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "daysecondsfrac"
    ],
    [
        "LOAD_GLOBAL",
        "float"
    ],
    [
        "CALL",
        "isinstance(daysecondsfrac, float)"
    ],
    [
        "LOAD_GLOBAL",
        "abs"
    ],
    [
        "LOAD_FAST",
        "daysecondsfrac"
    ],
    [
        "CALL",
        "abs(daysecondsfrac)"
    ],
    [
        "COMPARE_OP",
        "abs(daysecondsfrac) <= 1.0"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "d"
    ],
    [
        "LOAD_GLOBAL",
        "int"
    ],
    [
        "CALL",
        "isinstance(d, int)"
    ],
    [
        "LOAD_GLOBAL",
        "abs"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "CALL",
        "abs(s)"
    ],
    [
        "COMPARE_OP",
        "abs(s) <= 24 * 3600"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "seconds"
    ],
    [
        "LOAD_GLOBAL",
        "float"
    ],
    [
        "CALL",
        "isinstance(seconds, float)"
    ],
    [
        "LOAD_GLOBAL",
        "_math"
    ],
    [
        "LOAD_ATTR",
        "_math.modf"
    ],
    [
        "LOAD_FAST",
        "seconds"
    ],
    [
        "CALL",
        "_math.modf(seconds)"
    ],
    [
        "STORE_FAST",
        "secondsfrac"
    ],
    [
        "STORE_FAST",
        "seconds"
    ],
    [
        "LOAD_FAST",
        "seconds"
    ],
    [
        "LOAD_GLOBAL",
        "int"
    ],
    [
        "LOAD_FAST",
        "seconds"
    ],
    [
        "CALL",
        "int(seconds)"
    ],
    [
        "COMPARE_OP",
        "seconds == int(seconds)"
    ],
    [
        "LOAD_GLOBAL",
        "int"
    ],
    [
        "LOAD_FAST",
        "seconds"
    ],
    [
        "CALL",
        "int(seconds)"
    ],
    [
        "STORE_FAST",
        "seconds"
    ],
    [
        "LOAD_FAST",
        "secondsfrac"
    ],
    [
        "LOAD_FAST",
        "daysecondsfrac"
    ],
    [
        "BINARY_OP",
        "secondsfrac += daysecondsfrac"
    ],
    [
        "STORE_FAST",
        "secondsfrac"
    ],
    [
        "LOAD_GLOBAL",
        "abs"
    ],
    [
        "LOAD_FAST",
        "secondsfrac"
    ],
    [
        "CALL",
        "abs(secondsfrac)"
    ],
    [
        "COMPARE_OP",
        "abs(secondsfrac) <= 2.0"
    ],
    [
        "LOAD_FAST",
        "daysecondsfrac"
    ],
    [
        "STORE_FAST",
        "secondsfrac"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "secondsfrac"
    ],
    [
        "LOAD_GLOBAL",
        "float"
    ],
    [
        "CALL",
        "isinstance(secondsfrac, float)"
    ],
    [
        "LOAD_GLOBAL",
        "abs"
    ],
    [
        "LOAD_FAST",
        "secondsfrac"
    ],
    [
        "CALL",
        "abs(secondsfrac)"
    ],
    [
        "COMPARE_OP",
        "abs(secondsfrac) <= 2.0"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "seconds"
    ],
    [
        "LOAD_GLOBAL",
        "int"
    ],
    [
        "CALL",
        "isinstance(seconds, int)"
    ],
    [
        "LOAD_GLOBAL",
        "divmod"
    ],
    [
        "LOAD_FAST",
        "seconds"
    ],
    [
        "CALL",
        "divmod(seconds, 24*3600)"
    ],
    [
        "STORE_FAST",
        "days"
    ],
    [
        "STORE_FAST",
        "seconds"
    ],
    [
        "LOAD_FAST",
        "d"
    ],
    [
        "LOAD_FAST",
        "days"
    ],
    [
        "BINARY_OP",
        "d += days"
    ],
    [
        "STORE_FAST",
        "d"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "LOAD_GLOBAL",
        "int"
    ],
    [
        "LOAD_FAST",
        "seconds"
    ],
    [
        "CALL",
        "int(seconds)"
    ],
    [
        "BINARY_OP",
        "s += int(seconds)"
    ],
    [
        "STORE_FAST",
        "s"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "LOAD_GLOBAL",
        "int"
    ],
    [
        "CALL",
        "isinstance(s, int)"
    ],
    [
        "LOAD_GLOBAL",
        "abs"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "CALL",
        "abs(s)"
    ],
    [
        "COMPARE_OP",
        "abs(s) <= 2 * 24 * 3600"
    ],
    [
        "LOAD_FAST",
        "secondsfrac"
    ],
    [
        "BINARY_OP",
        "secondsfrac * 1e6"
    ],
    [
        "STORE_FAST",
        "usdouble"
    ],
    [
        "LOAD_GLOBAL",
        "abs"
    ],
    [
        "LOAD_FAST",
        "usdouble"
    ],
    [
        "CALL",
        "abs(usdouble)"
    ],
    [
        "COMPARE_OP",
        "abs(usdouble) < 2.1e6"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "microseconds"
    ],
    [
        "LOAD_GLOBAL",
        "float"
    ],
    [
        "CALL",
        "isinstance(microseconds, float)"
    ],
    [
        "LOAD_GLOBAL",
        "round"
    ],
    [
        "LOAD_FAST",
        "microseconds"
    ],
    [
        "LOAD_FAST",
        "usdouble"
    ],
    [
        "BINARY_OP",
        "microseconds + usdouble"
    ],
    [
        "CALL",
        "round(microseconds + usdouble)"
    ],
    [
        "STORE_FAST",
        "microseconds"
    ],
    [
        "LOAD_GLOBAL",
        "divmod"
    ],
    [
        "LOAD_FAST",
        "microseconds"
    ],
    [
        "CALL",
        "divmod(microseconds, 1000000)"
    ],
    [
        "STORE_FAST",
        "seconds"
    ],
    [
        "STORE_FAST",
        "microseconds"
    ],
    [
        "LOAD_GLOBAL",
        "divmod"
    ],
    [
        "LOAD_FAST",
        "seconds"
    ],
    [
        "CALL",
        "divmod(seconds, 24*3600)"
    ],
    [
        "STORE_FAST",
        "days"
    ],
    [
        "STORE_FAST",
        "seconds"
    ],
    [
        "LOAD_FAST",
        "d"
    ],
    [
        "LOAD_FAST",
        "days"
    ],
    [
        "BINARY_OP",
        "d += days"
    ],
    [
        "STORE_FAST",
        "d"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "LOAD_FAST",
        "seconds"
    ],
    [
        "BINARY_OP",
        "s += seconds"
    ],
    [
        "STORE_FAST",
        "s"
    ],
    [
        "LOAD_GLOBAL",
        "int"
    ],
    [
        "LOAD_FAST",
        "microseconds"
    ],
    [
        "CALL",
        "int(microseconds)"
    ],
    [
        "STORE_FAST",
        "microseconds"
    ],
    [
        "LOAD_GLOBAL",
        "divmod"
    ],
    [
        "LOAD_FAST",
        "microseconds"
    ],
    [
        "CALL",
        "divmod(microseconds, 1000000)"
    ],
    [
        "STORE_FAST",
        "seconds"
    ],
    [
        "STORE_FAST",
        "microseconds"
    ],
    [
        "LOAD_GLOBAL",
        "divmod"
    ],
    [
        "LOAD_FAST",
        "seconds"
    ],
    [
        "CALL",
        "divmod(seconds, 24*3600)"
    ],
    [
        "STORE_FAST",
        "days"
    ],
    [
        "STORE_FAST",
        "seconds"
    ],
    [
        "LOAD_FAST",
        "d"
    ],
    [
        "LOAD_FAST",
        "days"
    ],
    [
        "BINARY_OP",
        "d += days"
    ],
    [
        "STORE_FAST",
        "d"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "LOAD_FAST",
        "seconds"
    ],
    [
        "BINARY_OP",
        "s += seconds"
    ],
    [
        "STORE_FAST",
        "s"
    ],
    [
        "LOAD_GLOBAL",
        "round"
    ],
    [
        "LOAD_FAST",
        "microseconds"
    ],
    [
        "LOAD_FAST",
        "usdouble"
    ],
    [
        "BINARY_OP",
        "microseconds + usdouble"
    ],
    [
        "CALL",
        "round(microseconds + usdouble)"
    ],
    [
        "STORE_FAST",
        "microseconds"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "LOAD_GLOBAL",
        "int"
    ],
    [
        "CALL",
        "isinstance(s, int)"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "microseconds"
    ],
    [
        "LOAD_GLOBAL",
        "int"
    ],
    [
        "CALL",
        "isinstance(microseconds, int)"
    ],
    [
        "LOAD_GLOBAL",
        "abs"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "CALL",
        "abs(s)"
    ],
    [
        "COMPARE_OP",
        "abs(s) <= 3 * 24 * 3600"
    ],
    [
        "LOAD_GLOBAL",
        "abs"
    ],
    [
        "LOAD_FAST",
        "microseconds"
    ],
    [
        "CALL",
        "abs(microseconds)"
    ],
    [
        "COMPARE_OP",
        "abs(microseconds) < 3.1e6"
    ],
    [
        "LOAD_GLOBAL",
        "divmod"
    ],
    [
        "LOAD_FAST",
        "microseconds"
    ],
    [
        "CALL",
        "divmod(microseconds, 1000000)"
    ],
    [
        "STORE_FAST",
        "seconds"
    ],
    [
        "STORE_FAST",
        "us"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "LOAD_FAST",
        "seconds"
    ],
    [
        "BINARY_OP",
        "s += seconds"
    ],
    [
        "STORE_FAST",
        "s"
    ],
    [
        "LOAD_GLOBAL",
        "divmod"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "CALL",
        "divmod(s, 24*3600)"
    ],
    [
        "STORE_FAST",
        "days"
    ],
    [
        "STORE_FAST",
        "s"
    ],
    [
        "LOAD_FAST",
        "d"
    ],
    [
        "LOAD_FAST",
        "days"
    ],
    [
        "BINARY_OP",
        "d += days"
    ],
    [
        "STORE_FAST",
        "d"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "d"
    ],
    [
        "LOAD_GLOBAL",
        "int"
    ],
    [
        "CALL",
        "isinstance(d, int)"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "LOAD_GLOBAL",
        "int"
    ],
    [
        "CALL",
        "isinstance(s, int)"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "COMPARE_OP",
        "0 <= s < 24*3600"
    ],
    [
        "COMPARE_OP",
        "0 <= s < 24*3600"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "us"
    ],
    [
        "LOAD_GLOBAL",
        "int"
    ],
    [
        "CALL",
        "isinstance(us, int)"
    ],
    [
        "LOAD_FAST",
        "us"
    ],
    [
        "COMPARE_OP",
        "0 <= us < 1000000"
    ],
    [
        "COMPARE_OP",
        "0 <= us < 1000000"
    ],
    [
        "LOAD_GLOBAL",
        "abs"
    ],
    [
        "LOAD_FAST",
        "d"
    ],
    [
        "CALL",
        "abs(d)"
    ],
    [
        "COMPARE_OP",
        "abs(d) > 999999999"
    ],
    [
        "LOAD_GLOBAL",
        "OverflowError"
    ],
    [
        "LOAD_FAST",
        "d"
    ],
    [
        "BINARY_OP",
        "\"timedelta # of days is too large: %d\" % d"
    ],
    [
        "CALL",
        "OverflowError(\"timedelta # of days is too large: %d\" % d)"
    ],
    [
        "LOAD_GLOBAL",
        "object"
    ],
    [
        "LOAD_ATTR",
        "object.__new__"
    ],
    [
        "LOAD_FAST",
        "cls"
    ],
    [
        "CALL",
        "object.__new__(cls)"
    ],
    [
        "STORE_FAST",
        "self"
    ],
    [
        "LOAD_FAST",
        "d"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._days"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._seconds"
    ],
    [
        "LOAD_FAST",
        "us"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._microseconds"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._hashcode"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_FAST",
        "args"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._days"
    ],
    [
        "LOAD_FAST",
        "args"
    ],
    [
        "LOAD_ATTR",
        "args.append"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._days"
    ],
    [
        "BINARY_OP",
        "\"days=%d\" % self._days"
    ],
    [
        "CALL",
        "args.append(\"days=%d\" % self._days)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._seconds"
    ],
    [
        "LOAD_FAST",
        "args"
    ],
    [
        "LOAD_ATTR",
        "args.append"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._seconds"
    ],
    [
        "BINARY_OP",
        "\"seconds=%d\" % self._seconds"
    ],
    [
        "CALL",
        "args.append(\"seconds=%d\" % self._seconds)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._microseconds"
    ],
    [
        "LOAD_FAST",
        "args"
    ],
    [
        "LOAD_ATTR",
        "args.append"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._microseconds"
    ],
    [
        "BINARY_OP",
        "\"microseconds=%d\" % self._microseconds"
    ],
    [
        "CALL",
        "args.append(\"microseconds=%d\" % self._microseconds)"
    ],
    [
        "LOAD_FAST",
        "args"
    ],
    [
        "LOAD_FAST",
        "args"
    ],
    [
        "LOAD_ATTR",
        "args.append"
    ],
    [
        "CALL",
        "args.append('0')"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.__class__"
    ],
    [
        "LOAD_ATTR",
        "self.__class__.__module__"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.__class__"
    ],
    [
        "LOAD_ATTR",
        "self.__class__.__qualname__"
    ],
    [
        "LOAD_ATTR",
        "', '.join"
    ],
    [
        "LOAD_FAST",
        "args"
    ],
    [
        "CALL",
        "', '.join(args)"
    ],
    [
        "BUILD_STRING",
        "\"%s.%s(%s)\" % (self.__class__.__module__,\n                              self.__class__.__qualname__,\n                              ', '.join(args))"
    ],
    [
        "LOAD_GLOBAL",
        "divmod"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._seconds"
    ],
    [
        "CALL",
        "divmod(self._seconds, 60)"
    ],
    [
        "STORE_FAST",
        "mm"
    ],
    [
        "STORE_FAST",
        "ss"
    ],
    [
        "LOAD_GLOBAL",
        "divmod"
    ],
    [
        "LOAD_FAST",
        "mm"
    ],
    [
        "CALL",
        "divmod(mm, 60)"
    ],
    [
        "STORE_FAST",
        "hh"
    ],
    [
        "STORE_FAST",
        "mm"
    ],
    [
        "LOAD_FAST",
        "hh"
    ],
    [
        "LOAD_FAST",
        "mm"
    ],
    [
        "LOAD_FAST",
        "ss"
    ],
    [
        "BINARY_OP",
        "\"%d:%02d:%02d\" % (hh, mm, ss)"
    ],
    [
        "STORE_FAST",
        "s"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._days"
    ],
    [
        "STORE_FAST",
        "            def plural(n):\n                return n, abs(n) != 1 and \"s\" or \"\""
    ],
    [
        "LOAD_FAST",
        "plural"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._days"
    ],
    [
        "CALL",
        "plural(self._days)"
    ],
    [
        "BINARY_OP",
        "\"%d day%s, \" % plural(self._days)"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "BINARY_OP",
        "(\"%d day%s, \" % plural(self._days)) + s"
    ],
    [
        "STORE_FAST",
        "s"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._microseconds"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._microseconds"
    ],
    [
        "BINARY_OP",
        "\".%06d\" % self._microseconds"
    ],
    [
        "BINARY_OP",
        "s + \".%06d\" % self._microseconds"
    ],
    [
        "STORE_FAST",
        "s"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "LOAD_FAST",
        "n"
    ],
    [
        "LOAD_GLOBAL",
        "abs"
    ],
    [
        "LOAD_FAST",
        "n"
    ],
    [
        "CALL",
        "abs(n)"
    ],
    [
        "COMPARE_OP",
        "abs(n) != 1"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.days"
    ],
    [
        "BINARY_OP",
        "self.days * 86400"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.seconds"
    ],
    [
        "BINARY_OP",
        "self.days * 86400 + self.seconds"
    ],
    [
        "BINARY_OP",
        "(self.days * 86400 + self.seconds) * 10**6"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.microseconds"
    ],
    [
        "BINARY_OP",
        "(self.days * 86400 + self.seconds) * 10**6 +\n                self.microseconds"
    ],
    [
        "BINARY_OP",
        "((self.days * 86400 + self.seconds) * 10**6 +\n                self.microseconds) / 10**6"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._days"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._seconds"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._microseconds"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "CALL",
        "isinstance(other, timedelta)"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._days"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other._days"
    ],
    [
        "BINARY_OP",
        "self._days + other._days"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._seconds"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other._seconds"
    ],
    [
        "BINARY_OP",
        "self._seconds + other._seconds"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._microseconds"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other._microseconds"
    ],
    [
        "BINARY_OP",
        "self._microseconds + other._microseconds"
    ],
    [
        "CALL",
        "timedelta(self._days + other._days,\n                             self._seconds + other._seconds,\n                             self._microseconds + other._microseconds)"
    ],
    [
        "LOAD_GLOBAL",
        "NotImplemented"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "CALL",
        "isinstance(other, timedelta)"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._days"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other._days"
    ],
    [
        "BINARY_OP",
        "self._days - other._days"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._seconds"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other._seconds"
    ],
    [
        "BINARY_OP",
        "self._seconds - other._seconds"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._microseconds"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other._microseconds"
    ],
    [
        "BINARY_OP",
        "self._microseconds - other._microseconds"
    ],
    [
        "CALL",
        "timedelta(self._days - other._days,\n                             self._seconds - other._seconds,\n                             self._microseconds - other._microseconds)"
    ],
    [
        "LOAD_GLOBAL",
        "NotImplemented"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "CALL",
        "isinstance(other, timedelta)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "UNARY_NEGATIVE",
        "-self"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "BINARY_OP",
        "-self + other"
    ],
    [
        "LOAD_GLOBAL",
        "NotImplemented"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._days"
    ],
    [
        "UNARY_NEGATIVE",
        "-self._days"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._seconds"
    ],
    [
        "UNARY_NEGATIVE",
        "-self._seconds"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._microseconds"
    ],
    [
        "UNARY_NEGATIVE",
        "-self._microseconds"
    ],
    [
        "CALL",
        "timedelta(-self._days,\n                         -self._seconds,\n                         -self._microseconds)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._days"
    ],
    [
        "COMPARE_OP",
        "self._days < 0"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "UNARY_NEGATIVE",
        "-self"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "int"
    ],
    [
        "CALL",
        "isinstance(other, int)"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._days"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "BINARY_OP",
        "self._days * other"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._seconds"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "BINARY_OP",
        "self._seconds * other"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._microseconds"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "BINARY_OP",
        "self._microseconds * other"
    ],
    [
        "CALL",
        "timedelta(self._days * other,\n                             self._seconds * other,\n                             self._microseconds * other)"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "float"
    ],
    [
        "CALL",
        "isinstance(other, float)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._to_microseconds"
    ],
    [
        "CALL",
        "self._to_microseconds()"
    ],
    [
        "STORE_FAST",
        "usec"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other.as_integer_ratio"
    ],
    [
        "CALL",
        "other.as_integer_ratio()"
    ],
    [
        "STORE_FAST",
        "a"
    ],
    [
        "STORE_FAST",
        "b"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "LOAD_GLOBAL",
        "_divide_and_round"
    ],
    [
        "LOAD_FAST",
        "usec"
    ],
    [
        "LOAD_FAST",
        "a"
    ],
    [
        "BINARY_OP",
        "usec * a"
    ],
    [
        "LOAD_FAST",
        "b"
    ],
    [
        "CALL",
        "_divide_and_round(usec * a, b)"
    ],
    [
        "CALL",
        "timedelta(0, 0, _divide_and_round(usec * a, b))"
    ],
    [
        "LOAD_GLOBAL",
        "NotImplemented"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._days"
    ],
    [
        "BINARY_OP",
        "self._days * (24*3600)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._seconds"
    ],
    [
        "BINARY_OP",
        "self._days * (24*3600) + self._seconds"
    ],
    [
        "BINARY_OP",
        "(self._days * (24*3600) + self._seconds) * 1000000"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._microseconds"
    ],
    [
        "BINARY_OP",
        "(self._days * (24*3600) + self._seconds) * 1000000 +\n                self._microseconds"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "int"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "CALL",
        "isinstance(other, (int, timedelta))"
    ],
    [
        "LOAD_GLOBAL",
        "NotImplemented"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._to_microseconds"
    ],
    [
        "CALL",
        "self._to_microseconds()"
    ],
    [
        "STORE_FAST",
        "usec"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "CALL",
        "isinstance(other, timedelta)"
    ],
    [
        "LOAD_FAST",
        "usec"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other._to_microseconds"
    ],
    [
        "CALL",
        "other._to_microseconds()"
    ],
    [
        "BINARY_OP",
        "usec // other._to_microseconds()"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "int"
    ],
    [
        "CALL",
        "isinstance(other, int)"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "LOAD_FAST",
        "usec"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "BINARY_OP",
        "usec // other"
    ],
    [
        "CALL",
        "timedelta(0, 0, usec // other)"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "int"
    ],
    [
        "LOAD_GLOBAL",
        "float"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "CALL",
        "isinstance(other, (int, float, timedelta))"
    ],
    [
        "LOAD_GLOBAL",
        "NotImplemented"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._to_microseconds"
    ],
    [
        "CALL",
        "self._to_microseconds()"
    ],
    [
        "STORE_FAST",
        "usec"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "CALL",
        "isinstance(other, timedelta)"
    ],
    [
        "LOAD_FAST",
        "usec"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other._to_microseconds"
    ],
    [
        "CALL",
        "other._to_microseconds()"
    ],
    [
        "BINARY_OP",
        "usec / other._to_microseconds()"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "int"
    ],
    [
        "CALL",
        "isinstance(other, int)"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "LOAD_GLOBAL",
        "_divide_and_round"
    ],
    [
        "LOAD_FAST",
        "usec"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "CALL",
        "_divide_and_round(usec, other)"
    ],
    [
        "CALL",
        "timedelta(0, 0, _divide_and_round(usec, other))"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "float"
    ],
    [
        "CALL",
        "isinstance(other, float)"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other.as_integer_ratio"
    ],
    [
        "CALL",
        "other.as_integer_ratio()"
    ],
    [
        "STORE_FAST",
        "a"
    ],
    [
        "STORE_FAST",
        "b"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "LOAD_GLOBAL",
        "_divide_and_round"
    ],
    [
        "LOAD_FAST",
        "b"
    ],
    [
        "LOAD_FAST",
        "usec"
    ],
    [
        "BINARY_OP",
        "b * usec"
    ],
    [
        "LOAD_FAST",
        "a"
    ],
    [
        "CALL",
        "_divide_and_round(b * usec, a)"
    ],
    [
        "CALL",
        "timedelta(0, 0, _divide_and_round(b * usec, a))"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "CALL",
        "isinstance(other, timedelta)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._to_microseconds"
    ],
    [
        "CALL",
        "self._to_microseconds()"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other._to_microseconds"
    ],
    [
        "CALL",
        "other._to_microseconds()"
    ],
    [
        "BINARY_OP",
        "self._to_microseconds() % other._to_microseconds()"
    ],
    [
        "STORE_FAST",
        "r"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "LOAD_FAST",
        "r"
    ],
    [
        "CALL",
        "timedelta(0, 0, r)"
    ],
    [
        "LOAD_GLOBAL",
        "NotImplemented"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "CALL",
        "isinstance(other, timedelta)"
    ],
    [
        "LOAD_GLOBAL",
        "divmod"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._to_microseconds"
    ],
    [
        "CALL",
        "self._to_microseconds()"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other._to_microseconds"
    ],
    [
        "CALL",
        "other._to_microseconds()"
    ],
    [
        "CALL",
        "divmod(self._to_microseconds(),\n                          other._to_microseconds())"
    ],
    [
        "STORE_FAST",
        "q"
    ],
    [
        "STORE_FAST",
        "r"
    ],
    [
        "LOAD_FAST",
        "q"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "LOAD_FAST",
        "r"
    ],
    [
        "CALL",
        "timedelta(0, 0, r)"
    ],
    [
        "LOAD_GLOBAL",
        "NotImplemented"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "CALL",
        "isinstance(other, timedelta)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._cmp"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "CALL",
        "self._cmp(other)"
    ],
    [
        "COMPARE_OP",
        "self._cmp(other) == 0"
    ],
    [
        "LOAD_GLOBAL",
        "NotImplemented"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "CALL",
        "isinstance(other, timedelta)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._cmp"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "CALL",
        "self._cmp(other)"
    ],
    [
        "COMPARE_OP",
        "self._cmp(other) <= 0"
    ],
    [
        "LOAD_GLOBAL",
        "NotImplemented"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "CALL",
        "isinstance(other, timedelta)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._cmp"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "CALL",
        "self._cmp(other)"
    ],
    [
        "COMPARE_OP",
        "self._cmp(other) < 0"
    ],
    [
        "LOAD_GLOBAL",
        "NotImplemented"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "CALL",
        "isinstance(other, timedelta)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._cmp"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "CALL",
        "self._cmp(other)"
    ],
    [
        "COMPARE_OP",
        "self._cmp(other) >= 0"
    ],
    [
        "LOAD_GLOBAL",
        "NotImplemented"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "CALL",
        "isinstance(other, timedelta)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._cmp"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "CALL",
        "self._cmp(other)"
    ],
    [
        "COMPARE_OP",
        "self._cmp(other) > 0"
    ],
    [
        "LOAD_GLOBAL",
        "NotImplemented"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "CALL",
        "isinstance(other, timedelta)"
    ],
    [
        "LOAD_GLOBAL",
        "_cmp"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._getstate"
    ],
    [
        "CALL",
        "self._getstate()"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other._getstate"
    ],
    [
        "CALL",
        "other._getstate()"
    ],
    [
        "CALL",
        "_cmp(self._getstate(), other._getstate())"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._hashcode"
    ],
    [
        "COMPARE_OP",
        "self._hashcode == -1"
    ],
    [
        "LOAD_GLOBAL",
        "hash"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._getstate"
    ],
    [
        "CALL",
        "self._getstate()"
    ],
    [
        "CALL",
        "hash(self._getstate())"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._hashcode"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._hashcode"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._days"
    ],
    [
        "COMPARE_OP",
        "self._days != 0"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._seconds"
    ],
    [
        "COMPARE_OP",
        "self._seconds != 0"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._microseconds"
    ],
    [
        "COMPARE_OP",
        "self._microseconds != 0"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._days"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._seconds"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._microseconds"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.__class__"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._getstate"
    ],
    [
        "CALL",
        "self._getstate()"
    ],
    [
        "STORE_NAME",
        "\"\"\"Concrete date type.\n\n    Constructors:\n\n    __new__()\n    fromtimestamp()\n    today()\n    fromordinal()\n\n    Operators:\n\n    __repr__, __str__\n    __eq__, __le__, __lt__, __ge__, __gt__, __hash__\n    __add__, __radd__, __sub__ (add/radd only with timedelta arg)\n\n    Methods:\n\n    timetuple()\n    toordinal()\n    weekday()\n    isoweekday(), isocalendar(), isoformat()\n    ctime()\n    strftime()\n\n    Properties (readonly):\n    year, month, day\n    \"\"\""
    ],
    [
        "STORE_NAME",
        "__slots__"
    ],
    [
        "STORE_NAME",
        "    def __new__(cls, year, month=None, day=None):\n        \"\"\"Constructor.\n\n        Arguments:\n\n        year, month, day (required, base 1)\n        \"\"\"\n        if (month is None and\n            isinstance(year, (bytes, str)) and len(year) == 4 and\n            1 <= ord(year[2:3]) <= 12):\n            # Pickle support\n            if isinstance(year, str):\n                try:\n                    year = year.encode('latin1')\n                except UnicodeEncodeError:\n                    # More informative error message.\n                    raise ValueError(\n                        \"Failed to encode latin1 string when unpickling \"\n                        \"a date object. \"\n                        \"pickle.load(data, encoding='latin1') is assumed.\")\n            self = object.__new__(cls)\n            self.__setstate(year)\n            self._hashcode = -1\n            return self\n        year, month, day = _check_date_fields(year, month, day)\n        self = object.__new__(cls)\n        self._year = year\n        self._month = month\n        self._day = day\n        self._hashcode = -1\n        return self"
    ],
    [
        "LOAD_NAME",
        "classmethod"
    ],
    [
        "CALL",
        "classmethod"
    ],
    [
        "STORE_NAME",
        "    @classmethod\n    def fromtimestamp(cls, t):\n        \"Construct a date from a POSIX timestamp (like time.time()).\"\n        y, m, d, hh, mm, ss, weekday, jday, dst = _time.localtime(t)\n        return cls(y, m, d)"
    ],
    [
        "LOAD_NAME",
        "classmethod"
    ],
    [
        "CALL",
        "classmethod"
    ],
    [
        "STORE_NAME",
        "    @classmethod\n    def today(cls):\n        \"Construct a date from time.time().\"\n        t = _time.time()\n        return cls.fromtimestamp(t)"
    ],
    [
        "LOAD_NAME",
        "classmethod"
    ],
    [
        "CALL",
        "classmethod"
    ],
    [
        "STORE_NAME",
        "    @classmethod\n    def fromordinal(cls, n):\n        \"\"\"Construct a date from a proleptic Gregorian ordinal.\n\n        January 1 of year 1 is day 1.  Only the year, month and day are\n        non-zero in the result.\n        \"\"\"\n        y, m, d = _ord2ymd(n)\n        return cls(y, m, d)"
    ],
    [
        "LOAD_NAME",
        "classmethod"
    ],
    [
        "CALL",
        "classmethod"
    ],
    [
        "STORE_NAME",
        "    @classmethod\n    def fromisoformat(cls, date_string):\n        \"\"\"Construct a date from a string in ISO 8601 format.\"\"\"\n        if not isinstance(date_string, str):\n            raise TypeError('fromisoformat: argument must be str')\n\n        if len(date_string) not in (7, 8, 10):\n            raise ValueError(f'Invalid isoformat string: {date_string!r}')\n\n        try:\n            return cls(*_parse_isoformat_date(date_string))\n        except Exception:\n            raise ValueError(f'Invalid isoformat string: {date_string!r}')"
    ],
    [
        "LOAD_NAME",
        "classmethod"
    ],
    [
        "CALL",
        "classmethod"
    ],
    [
        "STORE_NAME",
        "    @classmethod\n    def fromisocalendar(cls, year, week, day):\n        \"\"\"Construct a date from the ISO year, week number and weekday.\n\n        This is the inverse of the date.isocalendar() function\"\"\"\n        return cls(*_isoweek_to_gregorian(year, week, day))"
    ],
    [
        "STORE_NAME",
        "    def __repr__(self):\n        \"\"\"Convert to formal string, for repr().\n\n        >>> dt = datetime(2010, 1, 1)\n        >>> repr(dt)\n        'datetime.datetime(2010, 1, 1, 0, 0)'\n\n        >>> dt = datetime(2010, 1, 1, tzinfo=timezone.utc)\n        >>> repr(dt)\n        'datetime.datetime(2010, 1, 1, 0, 0, tzinfo=datetime.timezone.utc)'\n        \"\"\"\n        return \"%s.%s(%d, %d, %d)\" % (self.__class__.__module__,\n                                      self.__class__.__qualname__,\n                                      self._year,\n                                      self._month,\n                                      self._day)"
    ],
    [
        "STORE_NAME",
        "    def ctime(self):\n        \"Return ctime() style string.\"\n        weekday = self.toordinal() % 7 or 7\n        return \"%s %s %2d 00:00:00 %04d\" % (\n            _DAYNAMES[weekday],\n            _MONTHNAMES[self._month],\n            self._day, self._year)"
    ],
    [
        "STORE_NAME",
        "    def strftime(self, fmt):\n        \"Format using strftime().\"\n        return _wrap_strftime(self, fmt, self.timetuple())"
    ],
    [
        "STORE_NAME",
        "    def __format__(self, fmt):\n        if not isinstance(fmt, str):\n            raise TypeError(\"must be str, not %s\" % type(fmt).__name__)\n        if len(fmt) != 0:\n            return self.strftime(fmt)\n        return str(self)"
    ],
    [
        "STORE_NAME",
        "    def isoformat(self):\n        \"\"\"Return the date formatted according to ISO.\n\n        This is 'YYYY-MM-DD'.\n\n        References:\n        - http://www.w3.org/TR/NOTE-datetime\n        - http://www.cl.cam.ac.uk/~mgk25/iso-time.html\n        \"\"\"\n        return \"%04d-%02d-%02d\" % (self._year, self._month, self._day)"
    ],
    [
        "LOAD_NAME",
        "isoformat"
    ],
    [
        "STORE_NAME",
        "__str__"
    ],
    [
        "LOAD_NAME",
        "property"
    ],
    [
        "CALL",
        "property"
    ],
    [
        "STORE_NAME",
        "    @property\n    def year(self):\n        \"\"\"year (1-9999)\"\"\"\n        return self._year"
    ],
    [
        "LOAD_NAME",
        "property"
    ],
    [
        "CALL",
        "property"
    ],
    [
        "STORE_NAME",
        "    @property\n    def month(self):\n        \"\"\"month (1-12)\"\"\"\n        return self._month"
    ],
    [
        "LOAD_NAME",
        "property"
    ],
    [
        "CALL",
        "property"
    ],
    [
        "STORE_NAME",
        "    @property\n    def day(self):\n        \"\"\"day (1-31)\"\"\"\n        return self._day"
    ],
    [
        "STORE_NAME",
        "    def timetuple(self):\n        \"Return local time tuple compatible with time.localtime().\"\n        return _build_struct_time(self._year, self._month, self._day,\n                                  0, 0, 0, -1)"
    ],
    [
        "STORE_NAME",
        "    def toordinal(self):\n        \"\"\"Return proleptic Gregorian ordinal for the year, month and day.\n\n        January 1 of year 1 is day 1.  Only the year, month and day values\n        contribute to the result.\n        \"\"\"\n        return _ymd2ord(self._year, self._month, self._day)"
    ],
    [
        "STORE_NAME",
        "    def replace(self, year=None, month=None, day=None):\n        \"\"\"Return a new date with new values for the specified fields.\"\"\"\n        if year is None:\n            year = self._year\n        if month is None:\n            month = self._month\n        if day is None:\n            day = self._day\n        return type(self)(year, month, day)"
    ],
    [
        "STORE_NAME",
        "    def __eq__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) == 0\n        return NotImplemented"
    ],
    [
        "STORE_NAME",
        "    def __le__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) <= 0\n        return NotImplemented"
    ],
    [
        "STORE_NAME",
        "    def __lt__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) < 0\n        return NotImplemented"
    ],
    [
        "STORE_NAME",
        "    def __ge__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) >= 0\n        return NotImplemented"
    ],
    [
        "STORE_NAME",
        "    def __gt__(self, other):\n        if isinstance(other, date):\n            return self._cmp(other) > 0\n        return NotImplemented"
    ],
    [
        "STORE_NAME",
        "    def _cmp(self, other):\n        assert isinstance(other, date)\n        y, m, d = self._year, self._month, self._day\n        y2, m2, d2 = other._year, other._month, other._day\n        return _cmp((y, m, d), (y2, m2, d2))"
    ],
    [
        "STORE_NAME",
        "    def __hash__(self):\n        \"Hash.\"\n        if self._hashcode == -1:\n            self._hashcode = hash(self._getstate())\n        return self._hashcode"
    ],
    [
        "STORE_NAME",
        "    def __add__(self, other):\n        \"Add a date to a timedelta.\"\n        if isinstance(other, timedelta):\n            o = self.toordinal() + other.days\n            if 0 < o <= _MAXORDINAL:\n                return type(self).fromordinal(o)\n            raise OverflowError(\"result out of range\")\n        return NotImplemented"
    ],
    [
        "LOAD_NAME",
        "__add__"
    ],
    [
        "STORE_NAME",
        "__radd__"
    ],
    [
        "STORE_NAME",
        "    def __sub__(self, other):\n        \"\"\"Subtract two dates, or a date and a timedelta.\"\"\"\n        if isinstance(other, timedelta):\n            return self + timedelta(-other.days)\n        if isinstance(other, date):\n            days1 = self.toordinal()\n            days2 = other.toordinal()\n            return timedelta(days1 - days2)\n        return NotImplemented"
    ],
    [
        "STORE_NAME",
        "    def weekday(self):\n        \"Return day of the week, where Monday == 0 ... Sunday == 6.\"\n        return (self.toordinal() + 6) % 7"
    ],
    [
        "STORE_NAME",
        "    def isoweekday(self):\n        \"Return day of the week, where Monday == 1 ... Sunday == 7.\"\n        # 1-Jan-0001 is a Monday\n        return self.toordinal() % 7 or 7"
    ],
    [
        "STORE_NAME",
        "    def isocalendar(self):\n        \"\"\"Return a named tuple containing ISO year, week number, and weekday.\n\n        The first ISO week of the year is the (Mon-Sun) week\n        containing the year's first Thursday; everything else derives\n        from that.\n\n        The first week is 1; Monday is 1 ... Sunday is 7.\n\n        ISO calendar algorithm taken from\n        http://www.phys.uu.nl/~vgent/calendar/isocalendar.htm\n        (used with permission)\n        \"\"\"\n        year = self._year\n        week1monday = _isoweek1monday(year)\n        today = _ymd2ord(self._year, self._month, self._day)\n        # Internally, week and day have origin 0\n        week, day = divmod(today - week1monday, 7)\n        if week < 0:\n            year -= 1\n            week1monday = _isoweek1monday(year)\n            week, day = divmod(today - week1monday, 7)\n        elif week >= 52:\n            if today >= _isoweek1monday(year+1):\n                year += 1\n                week = 0\n        return _IsoCalendarDate(year, week+1, day+1)"
    ],
    [
        "STORE_NAME",
        "    def _getstate(self):\n        yhi, ylo = divmod(self._year, 256)\n        return bytes([yhi, ylo, self._month, self._day]),"
    ],
    [
        "STORE_NAME",
        "    def __setstate(self, string):\n        yhi, ylo, self._month, self._day = string\n        self._year = yhi * 256 + ylo"
    ],
    [
        "STORE_NAME",
        "    def __reduce__(self):\n        return (self.__class__, self._getstate())"
    ],
    [
        "LOAD_FAST",
        "month"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "LOAD_GLOBAL",
        "bytes"
    ],
    [
        "LOAD_GLOBAL",
        "str"
    ],
    [
        "CALL",
        "isinstance(year, (bytes, str))"
    ],
    [
        "LOAD_GLOBAL",
        "len"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "CALL",
        "len(year)"
    ],
    [
        "COMPARE_OP",
        "len(year) == 4"
    ],
    [
        "LOAD_GLOBAL",
        "ord"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "BINARY_SLICE",
        "year[2:3]"
    ],
    [
        "CALL",
        "ord(year[2:3])"
    ],
    [
        "COMPARE_OP",
        "1 <= ord(year[2:3]) <= 12"
    ],
    [
        "COMPARE_OP",
        "1 <= ord(year[2:3]) <= 12"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "LOAD_GLOBAL",
        "str"
    ],
    [
        "CALL",
        "isinstance(year, str)"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "LOAD_ATTR",
        "year.encode"
    ],
    [
        "CALL",
        "year.encode('latin1')"
    ],
    [
        "STORE_FAST",
        "year"
    ],
    [
        "LOAD_GLOBAL",
        "object"
    ],
    [
        "LOAD_ATTR",
        "object.__new__"
    ],
    [
        "LOAD_FAST",
        "cls"
    ],
    [
        "CALL",
        "object.__new__(cls)"
    ],
    [
        "STORE_FAST",
        "self"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.__setstate"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "CALL",
        "self.__setstate(year)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._hashcode"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_GLOBAL",
        "_check_date_fields"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "LOAD_FAST",
        "month"
    ],
    [
        "LOAD_FAST",
        "day"
    ],
    [
        "CALL",
        "_check_date_fields(year, month, day)"
    ],
    [
        "STORE_FAST",
        "year"
    ],
    [
        "STORE_FAST",
        "month"
    ],
    [
        "STORE_FAST",
        "day"
    ],
    [
        "LOAD_GLOBAL",
        "object"
    ],
    [
        "LOAD_ATTR",
        "object.__new__"
    ],
    [
        "LOAD_FAST",
        "cls"
    ],
    [
        "CALL",
        "object.__new__(cls)"
    ],
    [
        "STORE_FAST",
        "self"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._year"
    ],
    [
        "LOAD_FAST",
        "month"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._month"
    ],
    [
        "LOAD_FAST",
        "day"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._day"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._hashcode"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_GLOBAL",
        "UnicodeEncodeError"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "CALL",
        "ValueError(\n                        \"Failed to encode latin1 string when unpickling \"\n                        \"a date object. \"\n                        \"pickle.load(data, encoding='latin1') is assumed.\")"
    ],
    [
        "LOAD_GLOBAL",
        "_time"
    ],
    [
        "LOAD_ATTR",
        "_time.localtime"
    ],
    [
        "LOAD_FAST",
        "t"
    ],
    [
        "CALL",
        "_time.localtime(t)"
    ],
    [
        "STORE_FAST",
        "y"
    ],
    [
        "STORE_FAST",
        "m"
    ],
    [
        "STORE_FAST",
        "d"
    ],
    [
        "STORE_FAST",
        "hh"
    ],
    [
        "STORE_FAST",
        "mm"
    ],
    [
        "STORE_FAST",
        "ss"
    ],
    [
        "STORE_FAST",
        "weekday"
    ],
    [
        "STORE_FAST",
        "jday"
    ],
    [
        "STORE_FAST",
        "dst"
    ],
    [
        "LOAD_FAST",
        "cls"
    ],
    [
        "LOAD_FAST",
        "y"
    ],
    [
        "LOAD_FAST",
        "m"
    ],
    [
        "LOAD_FAST",
        "d"
    ],
    [
        "CALL",
        "cls(y, m, d)"
    ],
    [
        "LOAD_GLOBAL",
        "_time"
    ],
    [
        "LOAD_ATTR",
        "_time.time"
    ],
    [
        "CALL",
        "_time.time()"
    ],
    [
        "STORE_FAST",
        "t"
    ],
    [
        "LOAD_FAST",
        "cls"
    ],
    [
        "LOAD_ATTR",
        "cls.fromtimestamp"
    ],
    [
        "LOAD_FAST",
        "t"
    ],
    [
        "CALL",
        "cls.fromtimestamp(t)"
    ],
    [
        "LOAD_GLOBAL",
        "_ord2ymd"
    ],
    [
        "LOAD_FAST",
        "n"
    ],
    [
        "CALL",
        "_ord2ymd(n)"
    ],
    [
        "STORE_FAST",
        "y"
    ],
    [
        "STORE_FAST",
        "m"
    ],
    [
        "STORE_FAST",
        "d"
    ],
    [
        "LOAD_FAST",
        "cls"
    ],
    [
        "LOAD_FAST",
        "y"
    ],
    [
        "LOAD_FAST",
        "m"
    ],
    [
        "LOAD_FAST",
        "d"
    ],
    [
        "CALL",
        "cls(y, m, d)"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "date_string"
    ],
    [
        "LOAD_GLOBAL",
        "str"
    ],
    [
        "CALL",
        "isinstance(date_string, str)"
    ],
    [
        "LOAD_GLOBAL",
        "TypeError"
    ],
    [
        "CALL",
        "TypeError('fromisoformat: argument must be str')"
    ],
    [
        "LOAD_GLOBAL",
        "len"
    ],
    [
        "LOAD_FAST",
        "date_string"
    ],
    [
        "CALL",
        "len(date_string)"
    ],
    [
        "CONTAINS_OP",
        "len(date_string) not in (7, 8, 10)"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "LOAD_FAST",
        "date_string"
    ],
    [
        "BUILD_STRING",
        "f'Invalid isoformat string: {date_string!r}'"
    ],
    [
        "CALL",
        "ValueError(f'Invalid isoformat string: {date_string!r}')"
    ],
    [
        "LOAD_FAST",
        "cls"
    ],
    [
        "LOAD_GLOBAL",
        "_parse_isoformat_date"
    ],
    [
        "LOAD_FAST",
        "date_string"
    ],
    [
        "CALL",
        "_parse_isoformat_date(date_string)"
    ],
    [
        "CALL_FUNCTION_EX",
        "cls(*_parse_isoformat_date(date_string))"
    ],
    [
        "LOAD_GLOBAL",
        "Exception"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "LOAD_FAST",
        "date_string"
    ],
    [
        "BUILD_STRING",
        "f'Invalid isoformat string: {date_string!r}'"
    ],
    [
        "CALL",
        "ValueError(f'Invalid isoformat string: {date_string!r}')"
    ],
    [
        "LOAD_FAST",
        "cls"
    ],
    [
        "LOAD_GLOBAL",
        "_isoweek_to_gregorian"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "LOAD_FAST",
        "week"
    ],
    [
        "LOAD_FAST",
        "day"
    ],
    [
        "CALL",
        "_isoweek_to_gregorian(year, week, day)"
    ],
    [
        "CALL_FUNCTION_EX",
        "cls(*_isoweek_to_gregorian(year, week, day))"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.__class__"
    ],
    [
        "LOAD_ATTR",
        "self.__class__.__module__"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.__class__"
    ],
    [
        "LOAD_ATTR",
        "self.__class__.__qualname__"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._year"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._month"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._day"
    ],
    [
        "BINARY_OP",
        "\"%s.%s(%d, %d, %d)\" % (self.__class__.__module__,\n                                      self.__class__.__qualname__,\n                                      self._year,\n                                      self._month,\n                                      self._day)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.toordinal"
    ],
    [
        "CALL",
        "self.toordinal()"
    ],
    [
        "BINARY_OP",
        "self.toordinal() % 7"
    ],
    [
        "STORE_FAST",
        "weekday"
    ],
    [
        "LOAD_GLOBAL",
        "_DAYNAMES"
    ],
    [
        "LOAD_FAST",
        "weekday"
    ],
    [
        "BINARY_SUBSCR",
        "_DAYNAMES[weekday]"
    ],
    [
        "LOAD_GLOBAL",
        "_MONTHNAMES"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._month"
    ],
    [
        "BINARY_SUBSCR",
        "_MONTHNAMES[self._month]"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._day"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._year"
    ],
    [
        "BINARY_OP",
        "\"%s %s %2d 00:00:00 %04d\" % (\n            _DAYNAMES[weekday],\n            _MONTHNAMES[self._month],\n            self._day, self._year)"
    ],
    [
        "LOAD_GLOBAL",
        "_wrap_strftime"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_FAST",
        "fmt"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.timetuple"
    ],
    [
        "CALL",
        "self.timetuple()"
    ],
    [
        "CALL",
        "_wrap_strftime(self, fmt, self.timetuple())"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "fmt"
    ],
    [
        "LOAD_GLOBAL",
        "str"
    ],
    [
        "CALL",
        "isinstance(fmt, str)"
    ],
    [
        "LOAD_GLOBAL",
        "TypeError"
    ],
    [
        "LOAD_GLOBAL",
        "type"
    ],
    [
        "LOAD_FAST",
        "fmt"
    ],
    [
        "CALL",
        "type(fmt)"
    ],
    [
        "LOAD_ATTR",
        "type(fmt).__name__"
    ],
    [
        "BINARY_OP",
        "\"must be str, not %s\" % type(fmt).__name__"
    ],
    [
        "CALL",
        "TypeError(\"must be str, not %s\" % type(fmt).__name__)"
    ],
    [
        "LOAD_GLOBAL",
        "len"
    ],
    [
        "LOAD_FAST",
        "fmt"
    ],
    [
        "CALL",
        "len(fmt)"
    ],
    [
        "COMPARE_OP",
        "len(fmt) != 0"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.strftime"
    ],
    [
        "LOAD_FAST",
        "fmt"
    ],
    [
        "CALL",
        "self.strftime(fmt)"
    ],
    [
        "LOAD_GLOBAL",
        "str"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "CALL",
        "str(self)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._year"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._month"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._day"
    ],
    [
        "BINARY_OP",
        "\"%04d-%02d-%02d\" % (self._year, self._month, self._day)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._year"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._month"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._day"
    ],
    [
        "LOAD_GLOBAL",
        "_build_struct_time"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._year"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._month"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._day"
    ],
    [
        "CALL",
        "_build_struct_time(self._year, self._month, self._day,\n                                  0, 0, 0, -1)"
    ],
    [
        "LOAD_GLOBAL",
        "_ymd2ord"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._year"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._month"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._day"
    ],
    [
        "CALL",
        "_ymd2ord(self._year, self._month, self._day)"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._year"
    ],
    [
        "STORE_FAST",
        "year"
    ],
    [
        "LOAD_FAST",
        "month"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._month"
    ],
    [
        "STORE_FAST",
        "month"
    ],
    [
        "LOAD_FAST",
        "day"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._day"
    ],
    [
        "STORE_FAST",
        "day"
    ],
    [
        "LOAD_GLOBAL",
        "type"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "CALL",
        "type(self)"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "LOAD_FAST",
        "month"
    ],
    [
        "LOAD_FAST",
        "day"
    ],
    [
        "CALL",
        "type(self)(year, month, day)"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "date"
    ],
    [
        "CALL",
        "isinstance(other, date)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._cmp"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "CALL",
        "self._cmp(other)"
    ],
    [
        "COMPARE_OP",
        "self._cmp(other) == 0"
    ],
    [
        "LOAD_GLOBAL",
        "NotImplemented"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "date"
    ],
    [
        "CALL",
        "isinstance(other, date)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._cmp"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "CALL",
        "self._cmp(other)"
    ],
    [
        "COMPARE_OP",
        "self._cmp(other) <= 0"
    ],
    [
        "LOAD_GLOBAL",
        "NotImplemented"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "date"
    ],
    [
        "CALL",
        "isinstance(other, date)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._cmp"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "CALL",
        "self._cmp(other)"
    ],
    [
        "COMPARE_OP",
        "self._cmp(other) < 0"
    ],
    [
        "LOAD_GLOBAL",
        "NotImplemented"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "date"
    ],
    [
        "CALL",
        "isinstance(other, date)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._cmp"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "CALL",
        "self._cmp(other)"
    ],
    [
        "COMPARE_OP",
        "self._cmp(other) >= 0"
    ],
    [
        "LOAD_GLOBAL",
        "NotImplemented"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "date"
    ],
    [
        "CALL",
        "isinstance(other, date)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._cmp"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "CALL",
        "self._cmp(other)"
    ],
    [
        "COMPARE_OP",
        "self._cmp(other) > 0"
    ],
    [
        "LOAD_GLOBAL",
        "NotImplemented"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "date"
    ],
    [
        "CALL",
        "isinstance(other, date)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._year"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._month"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._day"
    ],
    [
        "STORE_FAST",
        "d"
    ],
    [
        "STORE_FAST",
        "m"
    ],
    [
        "STORE_FAST",
        "y"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other._year"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other._month"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other._day"
    ],
    [
        "STORE_FAST",
        "d2"
    ],
    [
        "STORE_FAST",
        "m2"
    ],
    [
        "STORE_FAST",
        "y2"
    ],
    [
        "LOAD_GLOBAL",
        "_cmp"
    ],
    [
        "LOAD_FAST",
        "y"
    ],
    [
        "LOAD_FAST",
        "m"
    ],
    [
        "LOAD_FAST",
        "d"
    ],
    [
        "LOAD_FAST",
        "y2"
    ],
    [
        "LOAD_FAST",
        "m2"
    ],
    [
        "LOAD_FAST",
        "d2"
    ],
    [
        "CALL",
        "_cmp((y, m, d), (y2, m2, d2))"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._hashcode"
    ],
    [
        "COMPARE_OP",
        "self._hashcode == -1"
    ],
    [
        "LOAD_GLOBAL",
        "hash"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._getstate"
    ],
    [
        "CALL",
        "self._getstate()"
    ],
    [
        "CALL",
        "hash(self._getstate())"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._hashcode"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._hashcode"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "CALL",
        "isinstance(other, timedelta)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.toordinal"
    ],
    [
        "CALL",
        "self.toordinal()"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other.days"
    ],
    [
        "BINARY_OP",
        "self.toordinal() + other.days"
    ],
    [
        "STORE_FAST",
        "o"
    ],
    [
        "LOAD_FAST",
        "o"
    ],
    [
        "COMPARE_OP",
        "0 < o <= _MAXORDINAL"
    ],
    [
        "LOAD_GLOBAL",
        "_MAXORDINAL"
    ],
    [
        "COMPARE_OP",
        "0 < o <= _MAXORDINAL"
    ],
    [
        "LOAD_GLOBAL",
        "OverflowError"
    ],
    [
        "CALL",
        "OverflowError(\"result out of range\")"
    ],
    [
        "LOAD_GLOBAL",
        "type"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "CALL",
        "type(self)"
    ],
    [
        "LOAD_ATTR",
        "type(self).fromordinal"
    ],
    [
        "LOAD_FAST",
        "o"
    ],
    [
        "CALL",
        "type(self).fromordinal(o)"
    ],
    [
        "LOAD_GLOBAL",
        "OverflowError"
    ],
    [
        "CALL",
        "OverflowError(\"result out of range\")"
    ],
    [
        "LOAD_GLOBAL",
        "NotImplemented"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "CALL",
        "isinstance(other, timedelta)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other.days"
    ],
    [
        "UNARY_NEGATIVE",
        "-other.days"
    ],
    [
        "CALL",
        "timedelta(-other.days)"
    ],
    [
        "BINARY_OP",
        "self + timedelta(-other.days)"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "date"
    ],
    [
        "CALL",
        "isinstance(other, date)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.toordinal"
    ],
    [
        "CALL",
        "self.toordinal()"
    ],
    [
        "STORE_FAST",
        "days1"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other.toordinal"
    ],
    [
        "CALL",
        "other.toordinal()"
    ],
    [
        "STORE_FAST",
        "days2"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "LOAD_FAST",
        "days1"
    ],
    [
        "LOAD_FAST",
        "days2"
    ],
    [
        "BINARY_OP",
        "days1 - days2"
    ],
    [
        "CALL",
        "timedelta(days1 - days2)"
    ],
    [
        "LOAD_GLOBAL",
        "NotImplemented"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.toordinal"
    ],
    [
        "CALL",
        "self.toordinal()"
    ],
    [
        "BINARY_OP",
        "self.toordinal() + 6"
    ],
    [
        "BINARY_OP",
        "(self.toordinal() + 6) % 7"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.toordinal"
    ],
    [
        "CALL",
        "self.toordinal()"
    ],
    [
        "BINARY_OP",
        "self.toordinal() % 7"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._year"
    ],
    [
        "STORE_FAST",
        "year"
    ],
    [
        "LOAD_GLOBAL",
        "_isoweek1monday"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "CALL",
        "_isoweek1monday(year)"
    ],
    [
        "STORE_FAST",
        "week1monday"
    ],
    [
        "LOAD_GLOBAL",
        "_ymd2ord"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._year"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._month"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._day"
    ],
    [
        "CALL",
        "_ymd2ord(self._year, self._month, self._day)"
    ],
    [
        "STORE_FAST",
        "today"
    ],
    [
        "LOAD_GLOBAL",
        "divmod"
    ],
    [
        "LOAD_FAST",
        "today"
    ],
    [
        "LOAD_FAST",
        "week1monday"
    ],
    [
        "BINARY_OP",
        "today - week1monday"
    ],
    [
        "CALL",
        "divmod(today - week1monday, 7)"
    ],
    [
        "STORE_FAST",
        "week"
    ],
    [
        "STORE_FAST",
        "day"
    ],
    [
        "LOAD_FAST",
        "week"
    ],
    [
        "COMPARE_OP",
        "week < 0"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "BINARY_OP",
        "year -= 1"
    ],
    [
        "STORE_FAST",
        "year"
    ],
    [
        "LOAD_GLOBAL",
        "_isoweek1monday"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "CALL",
        "_isoweek1monday(year)"
    ],
    [
        "STORE_FAST",
        "week1monday"
    ],
    [
        "LOAD_GLOBAL",
        "divmod"
    ],
    [
        "LOAD_FAST",
        "today"
    ],
    [
        "LOAD_FAST",
        "week1monday"
    ],
    [
        "BINARY_OP",
        "today - week1monday"
    ],
    [
        "CALL",
        "divmod(today - week1monday, 7)"
    ],
    [
        "STORE_FAST",
        "week"
    ],
    [
        "STORE_FAST",
        "day"
    ],
    [
        "LOAD_FAST",
        "week"
    ],
    [
        "COMPARE_OP",
        "week >= 52"
    ],
    [
        "LOAD_FAST",
        "today"
    ],
    [
        "LOAD_GLOBAL",
        "_isoweek1monday"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "BINARY_OP",
        "year+1"
    ],
    [
        "CALL",
        "_isoweek1monday(year+1)"
    ],
    [
        "COMPARE_OP",
        "today >= _isoweek1monday(year+1)"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "BINARY_OP",
        "year += 1"
    ],
    [
        "STORE_FAST",
        "year"
    ],
    [
        "STORE_FAST",
        "week"
    ],
    [
        "LOAD_GLOBAL",
        "_IsoCalendarDate"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "LOAD_FAST",
        "week"
    ],
    [
        "BINARY_OP",
        "week+1"
    ],
    [
        "LOAD_FAST",
        "day"
    ],
    [
        "BINARY_OP",
        "day+1"
    ],
    [
        "CALL",
        "_IsoCalendarDate(year, week+1, day+1)"
    ],
    [
        "LOAD_GLOBAL",
        "divmod"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._year"
    ],
    [
        "CALL",
        "divmod(self._year, 256)"
    ],
    [
        "STORE_FAST",
        "yhi"
    ],
    [
        "STORE_FAST",
        "ylo"
    ],
    [
        "LOAD_GLOBAL",
        "bytes"
    ],
    [
        "LOAD_FAST",
        "yhi"
    ],
    [
        "LOAD_FAST",
        "ylo"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._month"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._day"
    ],
    [
        "CALL",
        "bytes([yhi, ylo, self._month, self._day])"
    ],
    [
        "LOAD_FAST",
        "string"
    ],
    [
        "STORE_FAST",
        "yhi"
    ],
    [
        "STORE_FAST",
        "ylo"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._month"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._day"
    ],
    [
        "LOAD_FAST",
        "yhi"
    ],
    [
        "BINARY_OP",
        "yhi * 256"
    ],
    [
        "LOAD_FAST",
        "ylo"
    ],
    [
        "BINARY_OP",
        "yhi * 256 + ylo"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._year"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.__class__"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._getstate"
    ],
    [
        "CALL",
        "self._getstate()"
    ],
    [
        "STORE_NAME",
        "\"\"\"Abstract base class for time zone info classes.\n\n    Subclasses must override the name(), utcoffset() and dst() methods.\n    \"\"\""
    ],
    [
        "STORE_NAME",
        "__slots__"
    ],
    [
        "STORE_NAME",
        "    def tzname(self, dt):\n        \"datetime -> string name of time zone.\"\n        raise NotImplementedError(\"tzinfo subclass must override tzname()\")"
    ],
    [
        "STORE_NAME",
        "    def utcoffset(self, dt):\n        \"datetime -> timedelta, positive for east of UTC, negative for west of UTC\"\n        raise NotImplementedError(\"tzinfo subclass must override utcoffset()\")"
    ],
    [
        "STORE_NAME",
        "    def dst(self, dt):\n        \"\"\"datetime -> DST offset as timedelta, positive for east of UTC.\n\n        Return 0 if DST not in effect.  utcoffset() must include the DST\n        offset.\n        \"\"\"\n        raise NotImplementedError(\"tzinfo subclass must override dst()\")"
    ],
    [
        "STORE_NAME",
        "    def fromutc(self, dt):\n        \"datetime in UTC -> datetime in local time.\"\n\n        if not isinstance(dt, datetime):\n            raise TypeError(\"fromutc() requires a datetime argument\")\n        if dt.tzinfo is not self:\n            raise ValueError(\"dt.tzinfo is not self\")\n\n        dtoff = dt.utcoffset()\n        if dtoff is None:\n            raise ValueError(\"fromutc() requires a non-None utcoffset() \"\n                             \"result\")\n\n        # See the long comment block at the end of this file for an\n        # explanation of this algorithm.\n        dtdst = dt.dst()\n        if dtdst is None:\n            raise ValueError(\"fromutc() requires a non-None dst() result\")\n        delta = dtoff - dtdst\n        if delta:\n            dt += delta\n            dtdst = dt.dst()\n            if dtdst is None:\n                raise ValueError(\"fromutc(): dt.dst gave inconsistent \"\n                                 \"results; cannot convert\")\n        return dt + dtdst"
    ],
    [
        "STORE_NAME",
        "    def __reduce__(self):\n        getinitargs = getattr(self, \"__getinitargs__\", None)\n        if getinitargs:\n            args = getinitargs()\n        else:\n            args = ()\n        return (self.__class__, args, self.__getstate__())"
    ],
    [
        "LOAD_GLOBAL",
        "NotImplementedError"
    ],
    [
        "CALL",
        "NotImplementedError(\"tzinfo subclass must override tzname()\")"
    ],
    [
        "LOAD_GLOBAL",
        "NotImplementedError"
    ],
    [
        "CALL",
        "NotImplementedError(\"tzinfo subclass must override utcoffset()\")"
    ],
    [
        "LOAD_GLOBAL",
        "NotImplementedError"
    ],
    [
        "CALL",
        "NotImplementedError(\"tzinfo subclass must override dst()\")"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "dt"
    ],
    [
        "LOAD_GLOBAL",
        "datetime"
    ],
    [
        "CALL",
        "isinstance(dt, datetime)"
    ],
    [
        "LOAD_GLOBAL",
        "TypeError"
    ],
    [
        "CALL",
        "TypeError(\"fromutc() requires a datetime argument\")"
    ],
    [
        "LOAD_FAST",
        "dt"
    ],
    [
        "LOAD_ATTR",
        "dt.tzinfo"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "IS_OP",
        "dt.tzinfo is not self"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "CALL",
        "ValueError(\"dt.tzinfo is not self\")"
    ],
    [
        "LOAD_FAST",
        "dt"
    ],
    [
        "LOAD_ATTR",
        "dt.utcoffset"
    ],
    [
        "CALL",
        "dt.utcoffset()"
    ],
    [
        "STORE_FAST",
        "dtoff"
    ],
    [
        "LOAD_FAST",
        "dtoff"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "CALL",
        "ValueError(\"fromutc() requires a non-None utcoffset() \"\n                             \"result\")"
    ],
    [
        "LOAD_FAST",
        "dt"
    ],
    [
        "LOAD_ATTR",
        "dt.dst"
    ],
    [
        "CALL",
        "dt.dst()"
    ],
    [
        "STORE_FAST",
        "dtdst"
    ],
    [
        "LOAD_FAST",
        "dtdst"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "CALL",
        "ValueError(\"fromutc() requires a non-None dst() result\")"
    ],
    [
        "LOAD_FAST",
        "dtoff"
    ],
    [
        "LOAD_FAST",
        "dtdst"
    ],
    [
        "BINARY_OP",
        "dtoff - dtdst"
    ],
    [
        "STORE_FAST",
        "delta"
    ],
    [
        "LOAD_FAST",
        "delta"
    ],
    [
        "LOAD_FAST",
        "dt"
    ],
    [
        "LOAD_FAST",
        "delta"
    ],
    [
        "BINARY_OP",
        "dt += delta"
    ],
    [
        "STORE_FAST",
        "dt"
    ],
    [
        "LOAD_FAST",
        "dt"
    ],
    [
        "LOAD_ATTR",
        "dt.dst"
    ],
    [
        "CALL",
        "dt.dst()"
    ],
    [
        "STORE_FAST",
        "dtdst"
    ],
    [
        "LOAD_FAST",
        "dtdst"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "CALL",
        "ValueError(\"fromutc(): dt.dst gave inconsistent \"\n                                 \"results; cannot convert\")"
    ],
    [
        "LOAD_FAST",
        "dt"
    ],
    [
        "LOAD_FAST",
        "dtdst"
    ],
    [
        "BINARY_OP",
        "dt + dtdst"
    ],
    [
        "LOAD_GLOBAL",
        "getattr"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "CALL",
        "getattr(self, \"__getinitargs__\", None)"
    ],
    [
        "STORE_FAST",
        "getinitargs"
    ],
    [
        "LOAD_FAST",
        "getinitargs"
    ],
    [
        "LOAD_FAST",
        "getinitargs"
    ],
    [
        "CALL",
        "getinitargs()"
    ],
    [
        "STORE_FAST",
        "args"
    ],
    [
        "STORE_FAST",
        "args"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.__class__"
    ],
    [
        "LOAD_FAST",
        "args"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.__getstate__"
    ],
    [
        "CALL",
        "self.__getstate__()"
    ],
    [
        "STORE_NAME",
        "    def __new__(cls, year, week, weekday, /):\n        return super().__new__(cls, (year, week, weekday))"
    ],
    [
        "LOAD_NAME",
        "property"
    ],
    [
        "CALL",
        "property"
    ],
    [
        "STORE_NAME",
        "    @property\n    def year(self):\n        return self[0]"
    ],
    [
        "LOAD_NAME",
        "property"
    ],
    [
        "CALL",
        "property"
    ],
    [
        "STORE_NAME",
        "    @property\n    def week(self):\n        return self[1]"
    ],
    [
        "LOAD_NAME",
        "property"
    ],
    [
        "CALL",
        "property"
    ],
    [
        "STORE_NAME",
        "    @property\n    def weekday(self):\n        return self[2]"
    ],
    [
        "STORE_NAME",
        "    def __reduce__(self):\n        # This code is intended to pickle the object without making the\n        # class public. See https://bugs.python.org/msg352381\n        return (tuple, (tuple(self),))"
    ],
    [
        "STORE_NAME",
        "    def __repr__(self):\n        return (f'{self.__class__.__name__}'\n                f'(year={self[0]}, week={self[1]}, weekday={self[2]})')"
    ],
    [
        "LOAD_GLOBAL",
        "super"
    ],
    [
        "LOAD_SUPER_ATTR",
        "super().__new__"
    ],
    [
        "LOAD_FAST",
        "cls"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "LOAD_FAST",
        "week"
    ],
    [
        "LOAD_FAST",
        "weekday"
    ],
    [
        "CALL",
        "super().__new__(cls, (year, week, weekday))"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "BINARY_SUBSCR",
        "self[0]"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "BINARY_SUBSCR",
        "self[1]"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "BINARY_SUBSCR",
        "self[2]"
    ],
    [
        "LOAD_GLOBAL",
        "tuple"
    ],
    [
        "LOAD_GLOBAL",
        "tuple"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "CALL",
        "tuple(self)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.__class__"
    ],
    [
        "LOAD_ATTR",
        "self.__class__.__name__"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "BINARY_SUBSCR",
        "self[0]"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "BINARY_SUBSCR",
        "self[1]"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "BINARY_SUBSCR",
        "self[2]"
    ],
    [
        "BUILD_STRING",
        "f'{self.__class__.__name__}'\n                f'(year={self[0]}, week={self[1]}, weekday={self[2]})'"
    ],
    [
        "STORE_NAME",
        "\"\"\"Time with time zone.\n\n    Constructors:\n\n    __new__()\n\n    Operators:\n\n    __repr__, __str__\n    __eq__, __le__, __lt__, __ge__, __gt__, __hash__\n\n    Methods:\n\n    strftime()\n    isoformat()\n    utcoffset()\n    tzname()\n    dst()\n\n    Properties (readonly):\n    hour, minute, second, microsecond, tzinfo, fold\n    \"\"\""
    ],
    [
        "STORE_NAME",
        "__slots__"
    ],
    [
        "STORE_NAME",
        "    def __new__(cls, hour=0, minute=0, second=0, microsecond=0, tzinfo=None, *, fold=0):\n        \"\"\"Constructor.\n\n        Arguments:\n\n        hour, minute (required)\n        second, microsecond (default to zero)\n        tzinfo (default to None)\n        fold (keyword only, default to zero)\n        \"\"\"\n        if (isinstance(hour, (bytes, str)) and len(hour) == 6 and\n            ord(hour[0:1])&0x7F < 24):\n            # Pickle support\n            if isinstance(hour, str):\n                try:\n                    hour = hour.encode('latin1')\n                except UnicodeEncodeError:\n                    # More informative error message.\n                    raise ValueError(\n                        \"Failed to encode latin1 string when unpickling \"\n                        \"a time object. \"\n                        \"pickle.load(data, encoding='latin1') is assumed.\")\n            self = object.__new__(cls)\n            self.__setstate(hour, minute or None)\n            self._hashcode = -1\n            return self\n        hour, minute, second, microsecond, fold = _check_time_fields(\n            hour, minute, second, microsecond, fold)\n        _check_tzinfo_arg(tzinfo)\n        self = object.__new__(cls)\n        self._hour = hour\n        self._minute = minute\n        self._second = second\n        self._microsecond = microsecond\n        self._tzinfo = tzinfo\n        self._hashcode = -1\n        self._fold = fold\n        return self"
    ],
    [
        "LOAD_NAME",
        "property"
    ],
    [
        "CALL",
        "property"
    ],
    [
        "STORE_NAME",
        "    @property\n    def hour(self):\n        \"\"\"hour (0-23)\"\"\"\n        return self._hour"
    ],
    [
        "LOAD_NAME",
        "property"
    ],
    [
        "CALL",
        "property"
    ],
    [
        "STORE_NAME",
        "    @property\n    def minute(self):\n        \"\"\"minute (0-59)\"\"\"\n        return self._minute"
    ],
    [
        "LOAD_NAME",
        "property"
    ],
    [
        "CALL",
        "property"
    ],
    [
        "STORE_NAME",
        "    @property\n    def second(self):\n        \"\"\"second (0-59)\"\"\"\n        return self._second"
    ],
    [
        "LOAD_NAME",
        "property"
    ],
    [
        "CALL",
        "property"
    ],
    [
        "STORE_NAME",
        "    @property\n    def microsecond(self):\n        \"\"\"microsecond (0-999999)\"\"\"\n        return self._microsecond"
    ],
    [
        "LOAD_NAME",
        "property"
    ],
    [
        "CALL",
        "property"
    ],
    [
        "STORE_NAME",
        "    @property\n    def tzinfo(self):\n        \"\"\"timezone info object\"\"\"\n        return self._tzinfo"
    ],
    [
        "LOAD_NAME",
        "property"
    ],
    [
        "CALL",
        "property"
    ],
    [
        "STORE_NAME",
        "    @property\n    def fold(self):\n        return self._fold"
    ],
    [
        "STORE_NAME",
        "    def __eq__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other, allow_mixed=True) == 0\n        else:\n            return NotImplemented"
    ],
    [
        "STORE_NAME",
        "    def __le__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) <= 0\n        else:\n            return NotImplemented"
    ],
    [
        "STORE_NAME",
        "    def __lt__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) < 0\n        else:\n            return NotImplemented"
    ],
    [
        "STORE_NAME",
        "    def __ge__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) >= 0\n        else:\n            return NotImplemented"
    ],
    [
        "STORE_NAME",
        "    def __gt__(self, other):\n        if isinstance(other, time):\n            return self._cmp(other) > 0\n        else:\n            return NotImplemented"
    ],
    [
        "STORE_NAME",
        "    def _cmp(self, other, allow_mixed=False):\n        assert isinstance(other, time)\n        mytz = self._tzinfo\n        ottz = other._tzinfo\n        myoff = otoff = None\n\n        if mytz is ottz:\n            base_compare = True\n        else:\n            myoff = self.utcoffset()\n            otoff = other.utcoffset()\n            base_compare = myoff == otoff\n\n        if base_compare:\n            return _cmp((self._hour, self._minute, self._second,\n                         self._microsecond),\n                        (other._hour, other._minute, other._second,\n                         other._microsecond))\n        if myoff is None or otoff is None:\n            if allow_mixed:\n                return 2 # arbitrary non-zero value\n            else:\n                raise TypeError(\"cannot compare naive and aware times\")\n        myhhmm = self._hour * 60 + self._minute - myoff//timedelta(minutes=1)\n        othhmm = other._hour * 60 + other._minute - otoff//timedelta(minutes=1)\n        return _cmp((myhhmm, self._second, self._microsecond),\n                    (othhmm, other._second, other._microsecond))"
    ],
    [
        "STORE_NAME",
        "    def __hash__(self):\n        \"\"\"Hash.\"\"\"\n        if self._hashcode == -1:\n            if self.fold:\n                t = self.replace(fold=0)\n            else:\n                t = self\n            tzoff = t.utcoffset()\n            if not tzoff:  # zero or None\n                self._hashcode = hash(t._getstate()[0])\n            else:\n                h, m = divmod(timedelta(hours=self.hour, minutes=self.minute) - tzoff,\n                              timedelta(hours=1))\n                assert not m % timedelta(minutes=1), \"whole minute\"\n                m //= timedelta(minutes=1)\n                if 0 <= h < 24:\n                    self._hashcode = hash(time(h, m, self.second, self.microsecond))\n                else:\n                    self._hashcode = hash((h, m, self.second, self.microsecond))\n        return self._hashcode"
    ],
    [
        "STORE_NAME",
        "    def _tzstr(self):\n        \"\"\"Return formatted timezone offset (+xx:xx) or an empty string.\"\"\"\n        off = self.utcoffset()\n        return _format_offset(off)"
    ],
    [
        "STORE_NAME",
        "    def __repr__(self):\n        \"\"\"Convert to formal string, for repr().\"\"\"\n        if self._microsecond != 0:\n            s = \", %d, %d\" % (self._second, self._microsecond)\n        elif self._second != 0:\n            s = \", %d\" % self._second\n        else:\n            s = \"\"\n        s= \"%s.%s(%d, %d%s)\" % (self.__class__.__module__,\n                                self.__class__.__qualname__,\n                                self._hour, self._minute, s)\n        if self._tzinfo is not None:\n            assert s[-1:] == \")\"\n            s = s[:-1] + \", tzinfo=%r\" % self._tzinfo + \")\"\n        if self._fold:\n            assert s[-1:] == \")\"\n            s = s[:-1] + \", fold=1)\"\n        return s"
    ],
    [
        "STORE_NAME",
        "    def isoformat(self, timespec='auto'):\n        \"\"\"Return the time formatted according to ISO.\n\n        The full format is 'HH:MM:SS.mmmmmm+zz:zz'. By default, the fractional\n        part is omitted if self.microsecond == 0.\n\n        The optional argument timespec specifies the number of additional\n        terms of the time to include. Valid options are 'auto', 'hours',\n        'minutes', 'seconds', 'milliseconds' and 'microseconds'.\n        \"\"\"\n        s = _format_time(self._hour, self._minute, self._second,\n                          self._microsecond, timespec)\n        tz = self._tzstr()\n        if tz:\n            s += tz\n        return s"
    ],
    [
        "LOAD_NAME",
        "isoformat"
    ],
    [
        "STORE_NAME",
        "__str__"
    ],
    [
        "LOAD_NAME",
        "classmethod"
    ],
    [
        "CALL",
        "classmethod"
    ],
    [
        "STORE_NAME",
        "    @classmethod\n    def fromisoformat(cls, time_string):\n        \"\"\"Construct a time from a string in one of the ISO 8601 formats.\"\"\"\n        if not isinstance(time_string, str):\n            raise TypeError('fromisoformat: argument must be str')\n\n        # The spec actually requires that time-only ISO 8601 strings start with\n        # T, but the extended format allows this to be omitted as long as there\n        # is no ambiguity with date strings.\n        time_string = time_string.removeprefix('T')\n\n        try:\n            return cls(*_parse_isoformat_time(time_string))\n        except Exception:\n            raise ValueError(f'Invalid isoformat string: {time_string!r}')"
    ],
    [
        "STORE_NAME",
        "    def strftime(self, fmt):\n        \"\"\"Format using strftime().  The date part of the timestamp passed\n        to underlying strftime should not be used.\n        \"\"\"\n        # The year must be >= 1000 else Python's strftime implementation\n        # can raise a bogus exception.\n        timetuple = (1900, 1, 1,\n                     self._hour, self._minute, self._second,\n                     0, 1, -1)\n        return _wrap_strftime(self, fmt, timetuple)"
    ],
    [
        "STORE_NAME",
        "    def __format__(self, fmt):\n        if not isinstance(fmt, str):\n            raise TypeError(\"must be str, not %s\" % type(fmt).__name__)\n        if len(fmt) != 0:\n            return self.strftime(fmt)\n        return str(self)"
    ],
    [
        "STORE_NAME",
        "    def utcoffset(self):\n        \"\"\"Return the timezone offset as timedelta, positive east of UTC\n         (negative west of UTC).\"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.utcoffset(None)\n        _check_utc_offset(\"utcoffset\", offset)\n        return offset"
    ],
    [
        "STORE_NAME",
        "    def tzname(self):\n        \"\"\"Return the timezone name.\n\n        Note that the name is 100% informational -- there's no requirement that\n        it mean anything in particular. For example, \"GMT\", \"UTC\", \"-500\",\n        \"-5:00\", \"EDT\", \"US/Eastern\", \"America/New York\" are all valid replies.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        name = self._tzinfo.tzname(None)\n        _check_tzname(name)\n        return name"
    ],
    [
        "STORE_NAME",
        "    def dst(self):\n        \"\"\"Return 0 if DST is not in effect, or the DST offset (as timedelta\n        positive eastward) if DST is in effect.\n\n        This is purely informational; the DST offset has already been added to\n        the UTC offset returned by utcoffset() if applicable, so there's no\n        need to consult dst() unless you're interested in displaying the DST\n        info.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.dst(None)\n        _check_utc_offset(\"dst\", offset)\n        return offset"
    ],
    [
        "STORE_NAME",
        "    def replace(self, hour=None, minute=None, second=None, microsecond=None,\n                tzinfo=True, *, fold=None):\n        \"\"\"Return a new time with new values for the specified fields.\"\"\"\n        if hour is None:\n            hour = self.hour\n        if minute is None:\n            minute = self.minute\n        if second is None:\n            second = self.second\n        if microsecond is None:\n            microsecond = self.microsecond\n        if tzinfo is True:\n            tzinfo = self.tzinfo\n        if fold is None:\n            fold = self._fold\n        return type(self)(hour, minute, second, microsecond, tzinfo, fold=fold)"
    ],
    [
        "STORE_NAME",
        "    def _getstate(self, protocol=3):\n        us2, us3 = divmod(self._microsecond, 256)\n        us1, us2 = divmod(us2, 256)\n        h = self._hour\n        if self._fold and protocol > 3:\n            h += 128\n        basestate = bytes([h, self._minute, self._second,\n                           us1, us2, us3])\n        if self._tzinfo is None:\n            return (basestate,)\n        else:\n            return (basestate, self._tzinfo)"
    ],
    [
        "STORE_NAME",
        "    def __setstate(self, string, tzinfo):\n        if tzinfo is not None and not isinstance(tzinfo, _tzinfo_class):\n            raise TypeError(\"bad tzinfo state arg\")\n        h, self._minute, self._second, us1, us2, us3 = string\n        if h > 127:\n            self._fold = 1\n            self._hour = h - 128\n        else:\n            self._fold = 0\n            self._hour = h\n        self._microsecond = (((us1 << 8) | us2) << 8) | us3\n        self._tzinfo = tzinfo"
    ],
    [
        "STORE_NAME",
        "    def __reduce_ex__(self, protocol):\n        return (self.__class__, self._getstate(protocol))"
    ],
    [
        "STORE_NAME",
        "    def __reduce__(self):\n        return self.__reduce_ex__(2)"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "hour"
    ],
    [
        "LOAD_GLOBAL",
        "bytes"
    ],
    [
        "LOAD_GLOBAL",
        "str"
    ],
    [
        "CALL",
        "isinstance(hour, (bytes, str))"
    ],
    [
        "LOAD_GLOBAL",
        "len"
    ],
    [
        "LOAD_FAST",
        "hour"
    ],
    [
        "CALL",
        "len(hour)"
    ],
    [
        "COMPARE_OP",
        "len(hour) == 6"
    ],
    [
        "LOAD_GLOBAL",
        "ord"
    ],
    [
        "LOAD_FAST",
        "hour"
    ],
    [
        "BINARY_SLICE",
        "hour[0:1]"
    ],
    [
        "CALL",
        "ord(hour[0:1])"
    ],
    [
        "BINARY_OP",
        "ord(hour[0:1])&0x7F"
    ],
    [
        "COMPARE_OP",
        "ord(hour[0:1])&0x7F < 24"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "hour"
    ],
    [
        "LOAD_GLOBAL",
        "str"
    ],
    [
        "CALL",
        "isinstance(hour, str)"
    ],
    [
        "LOAD_FAST",
        "hour"
    ],
    [
        "LOAD_ATTR",
        "hour.encode"
    ],
    [
        "CALL",
        "hour.encode('latin1')"
    ],
    [
        "STORE_FAST",
        "hour"
    ],
    [
        "LOAD_GLOBAL",
        "object"
    ],
    [
        "LOAD_ATTR",
        "object.__new__"
    ],
    [
        "LOAD_FAST",
        "cls"
    ],
    [
        "CALL",
        "object.__new__(cls)"
    ],
    [
        "STORE_FAST",
        "self"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.__setstate"
    ],
    [
        "LOAD_FAST",
        "hour"
    ],
    [
        "LOAD_FAST",
        "minute"
    ],
    [
        "CALL",
        "self.__setstate(hour, minute or None)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._hashcode"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_GLOBAL",
        "_check_time_fields"
    ],
    [
        "LOAD_FAST",
        "hour"
    ],
    [
        "LOAD_FAST",
        "minute"
    ],
    [
        "LOAD_FAST",
        "second"
    ],
    [
        "LOAD_FAST",
        "microsecond"
    ],
    [
        "LOAD_FAST",
        "fold"
    ],
    [
        "CALL",
        "_check_time_fields(\n            hour, minute, second, microsecond, fold)"
    ],
    [
        "STORE_FAST",
        "hour"
    ],
    [
        "STORE_FAST",
        "minute"
    ],
    [
        "STORE_FAST",
        "second"
    ],
    [
        "STORE_FAST",
        "microsecond"
    ],
    [
        "STORE_FAST",
        "fold"
    ],
    [
        "LOAD_GLOBAL",
        "_check_tzinfo_arg"
    ],
    [
        "LOAD_FAST",
        "tzinfo"
    ],
    [
        "CALL",
        "_check_tzinfo_arg(tzinfo)"
    ],
    [
        "LOAD_GLOBAL",
        "object"
    ],
    [
        "LOAD_ATTR",
        "object.__new__"
    ],
    [
        "LOAD_FAST",
        "cls"
    ],
    [
        "CALL",
        "object.__new__(cls)"
    ],
    [
        "STORE_FAST",
        "self"
    ],
    [
        "LOAD_FAST",
        "hour"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._hour"
    ],
    [
        "LOAD_FAST",
        "minute"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._minute"
    ],
    [
        "LOAD_FAST",
        "second"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._second"
    ],
    [
        "LOAD_FAST",
        "microsecond"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._microsecond"
    ],
    [
        "LOAD_FAST",
        "tzinfo"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._tzinfo"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._hashcode"
    ],
    [
        "LOAD_FAST",
        "fold"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._fold"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_GLOBAL",
        "UnicodeEncodeError"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "CALL",
        "ValueError(\n                        \"Failed to encode latin1 string when unpickling \"\n                        \"a time object. \"\n                        \"pickle.load(data, encoding='latin1') is assumed.\")"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._hour"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._minute"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._second"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._microsecond"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._tzinfo"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._fold"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "time"
    ],
    [
        "CALL",
        "isinstance(other, time)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._cmp"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "CALL",
        "self._cmp(other, allow_mixed=True)"
    ],
    [
        "COMPARE_OP",
        "self._cmp(other, allow_mixed=True) == 0"
    ],
    [
        "LOAD_GLOBAL",
        "NotImplemented"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "time"
    ],
    [
        "CALL",
        "isinstance(other, time)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._cmp"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "CALL",
        "self._cmp(other)"
    ],
    [
        "COMPARE_OP",
        "self._cmp(other) <= 0"
    ],
    [
        "LOAD_GLOBAL",
        "NotImplemented"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "time"
    ],
    [
        "CALL",
        "isinstance(other, time)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._cmp"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "CALL",
        "self._cmp(other)"
    ],
    [
        "COMPARE_OP",
        "self._cmp(other) < 0"
    ],
    [
        "LOAD_GLOBAL",
        "NotImplemented"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "time"
    ],
    [
        "CALL",
        "isinstance(other, time)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._cmp"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "CALL",
        "self._cmp(other)"
    ],
    [
        "COMPARE_OP",
        "self._cmp(other) >= 0"
    ],
    [
        "LOAD_GLOBAL",
        "NotImplemented"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "time"
    ],
    [
        "CALL",
        "isinstance(other, time)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._cmp"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "CALL",
        "self._cmp(other)"
    ],
    [
        "COMPARE_OP",
        "self._cmp(other) > 0"
    ],
    [
        "LOAD_GLOBAL",
        "NotImplemented"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "time"
    ],
    [
        "CALL",
        "isinstance(other, time)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._tzinfo"
    ],
    [
        "STORE_FAST",
        "mytz"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other._tzinfo"
    ],
    [
        "STORE_FAST",
        "ottz"
    ],
    [
        "STORE_FAST",
        "myoff"
    ],
    [
        "STORE_FAST",
        "otoff"
    ],
    [
        "LOAD_FAST",
        "mytz"
    ],
    [
        "LOAD_FAST",
        "ottz"
    ],
    [
        "IS_OP",
        "mytz is ottz"
    ],
    [
        "STORE_FAST",
        "base_compare"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.utcoffset"
    ],
    [
        "CALL",
        "self.utcoffset()"
    ],
    [
        "STORE_FAST",
        "myoff"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other.utcoffset"
    ],
    [
        "CALL",
        "other.utcoffset()"
    ],
    [
        "STORE_FAST",
        "otoff"
    ],
    [
        "LOAD_FAST",
        "myoff"
    ],
    [
        "LOAD_FAST",
        "otoff"
    ],
    [
        "COMPARE_OP",
        "myoff == otoff"
    ],
    [
        "STORE_FAST",
        "base_compare"
    ],
    [
        "LOAD_FAST",
        "base_compare"
    ],
    [
        "LOAD_GLOBAL",
        "_cmp"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._hour"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._minute"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._second"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._microsecond"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other._hour"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other._minute"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other._second"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other._microsecond"
    ],
    [
        "CALL",
        "_cmp((self._hour, self._minute, self._second,\n                         self._microsecond),\n                        (other._hour, other._minute, other._second,\n                         other._microsecond))"
    ],
    [
        "LOAD_FAST",
        "myoff"
    ],
    [
        "LOAD_FAST",
        "otoff"
    ],
    [
        "LOAD_FAST",
        "allow_mixed"
    ],
    [
        "LOAD_GLOBAL",
        "TypeError"
    ],
    [
        "CALL",
        "TypeError(\"cannot compare naive and aware times\")"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._hour"
    ],
    [
        "BINARY_OP",
        "self._hour * 60"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._minute"
    ],
    [
        "BINARY_OP",
        "self._hour * 60 + self._minute"
    ],
    [
        "LOAD_FAST",
        "myoff"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "CALL",
        "timedelta(minutes=1)"
    ],
    [
        "BINARY_OP",
        "myoff//timedelta(minutes=1)"
    ],
    [
        "BINARY_OP",
        "self._hour * 60 + self._minute - myoff//timedelta(minutes=1)"
    ],
    [
        "STORE_FAST",
        "myhhmm"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other._hour"
    ],
    [
        "BINARY_OP",
        "other._hour * 60"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other._minute"
    ],
    [
        "BINARY_OP",
        "other._hour * 60 + other._minute"
    ],
    [
        "LOAD_FAST",
        "otoff"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "CALL",
        "timedelta(minutes=1)"
    ],
    [
        "BINARY_OP",
        "otoff//timedelta(minutes=1)"
    ],
    [
        "BINARY_OP",
        "other._hour * 60 + other._minute - otoff//timedelta(minutes=1)"
    ],
    [
        "STORE_FAST",
        "othhmm"
    ],
    [
        "LOAD_GLOBAL",
        "_cmp"
    ],
    [
        "LOAD_FAST",
        "myhhmm"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._second"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._microsecond"
    ],
    [
        "LOAD_FAST",
        "othhmm"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other._second"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other._microsecond"
    ],
    [
        "CALL",
        "_cmp((myhhmm, self._second, self._microsecond),\n                    (othhmm, other._second, other._microsecond))"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._hashcode"
    ],
    [
        "COMPARE_OP",
        "self._hashcode == -1"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.fold"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.replace"
    ],
    [
        "CALL",
        "self.replace(fold=0)"
    ],
    [
        "STORE_FAST",
        "t"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_FAST",
        "t"
    ],
    [
        "LOAD_FAST",
        "t"
    ],
    [
        "LOAD_ATTR",
        "t.utcoffset"
    ],
    [
        "CALL",
        "t.utcoffset()"
    ],
    [
        "STORE_FAST",
        "tzoff"
    ],
    [
        "LOAD_FAST",
        "tzoff"
    ],
    [
        "LOAD_GLOBAL",
        "hash"
    ],
    [
        "LOAD_FAST",
        "t"
    ],
    [
        "LOAD_ATTR",
        "t._getstate"
    ],
    [
        "CALL",
        "t._getstate()"
    ],
    [
        "BINARY_SUBSCR",
        "t._getstate()[0]"
    ],
    [
        "CALL",
        "hash(t._getstate()[0])"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._hashcode"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._hashcode"
    ],
    [
        "LOAD_GLOBAL",
        "divmod"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.hour"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.minute"
    ],
    [
        "CALL",
        "timedelta(hours=self.hour, minutes=self.minute)"
    ],
    [
        "LOAD_FAST",
        "tzoff"
    ],
    [
        "BINARY_OP",
        "timedelta(hours=self.hour, minutes=self.minute) - tzoff"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "CALL",
        "timedelta(hours=1)"
    ],
    [
        "CALL",
        "divmod(timedelta(hours=self.hour, minutes=self.minute) - tzoff,\n                              timedelta(hours=1))"
    ],
    [
        "STORE_FAST",
        "h"
    ],
    [
        "STORE_FAST",
        "m"
    ],
    [
        "LOAD_FAST",
        "m"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "CALL",
        "timedelta(minutes=1)"
    ],
    [
        "BINARY_OP",
        "m % timedelta(minutes=1)"
    ],
    [
        "LOAD_FAST",
        "m"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "CALL",
        "timedelta(minutes=1)"
    ],
    [
        "BINARY_OP",
        "m //= timedelta(minutes=1)"
    ],
    [
        "STORE_FAST",
        "m"
    ],
    [
        "LOAD_FAST",
        "h"
    ],
    [
        "COMPARE_OP",
        "0 <= h < 24"
    ],
    [
        "COMPARE_OP",
        "0 <= h < 24"
    ],
    [
        "LOAD_GLOBAL",
        "hash"
    ],
    [
        "LOAD_GLOBAL",
        "time"
    ],
    [
        "LOAD_FAST",
        "h"
    ],
    [
        "LOAD_FAST",
        "m"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.second"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.microsecond"
    ],
    [
        "CALL",
        "time(h, m, self.second, self.microsecond)"
    ],
    [
        "CALL",
        "hash(time(h, m, self.second, self.microsecond))"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._hashcode"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._hashcode"
    ],
    [
        "LOAD_GLOBAL",
        "hash"
    ],
    [
        "LOAD_FAST",
        "h"
    ],
    [
        "LOAD_FAST",
        "m"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.second"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.microsecond"
    ],
    [
        "CALL",
        "hash((h, m, self.second, self.microsecond))"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._hashcode"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._hashcode"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.utcoffset"
    ],
    [
        "CALL",
        "self.utcoffset()"
    ],
    [
        "STORE_FAST",
        "off"
    ],
    [
        "LOAD_GLOBAL",
        "_format_offset"
    ],
    [
        "LOAD_FAST",
        "off"
    ],
    [
        "CALL",
        "_format_offset(off)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._microsecond"
    ],
    [
        "COMPARE_OP",
        "self._microsecond != 0"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._second"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._microsecond"
    ],
    [
        "BINARY_OP",
        "\", %d, %d\" % (self._second, self._microsecond)"
    ],
    [
        "STORE_FAST",
        "s"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._second"
    ],
    [
        "COMPARE_OP",
        "self._second != 0"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._second"
    ],
    [
        "BINARY_OP",
        "\", %d\" % self._second"
    ],
    [
        "STORE_FAST",
        "s"
    ],
    [
        "STORE_FAST",
        "s"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.__class__"
    ],
    [
        "LOAD_ATTR",
        "self.__class__.__module__"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.__class__"
    ],
    [
        "LOAD_ATTR",
        "self.__class__.__qualname__"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._hour"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._minute"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "BINARY_OP",
        "\"%s.%s(%d, %d%s)\" % (self.__class__.__module__,\n                                self.__class__.__qualname__,\n                                self._hour, self._minute, s)"
    ],
    [
        "STORE_FAST",
        "s"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._tzinfo"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "BINARY_SLICE",
        "s[-1:]"
    ],
    [
        "COMPARE_OP",
        "s[-1:] == \")\""
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "BINARY_SLICE",
        "s[:-1]"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._tzinfo"
    ],
    [
        "BINARY_OP",
        "\", tzinfo=%r\" % self._tzinfo"
    ],
    [
        "BINARY_OP",
        "s[:-1] + \", tzinfo=%r\" % self._tzinfo"
    ],
    [
        "BINARY_OP",
        "s[:-1] + \", tzinfo=%r\" % self._tzinfo + \")\""
    ],
    [
        "STORE_FAST",
        "s"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._fold"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "BINARY_SLICE",
        "s[-1:]"
    ],
    [
        "COMPARE_OP",
        "s[-1:] == \")\""
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "BINARY_SLICE",
        "s[:-1]"
    ],
    [
        "BINARY_OP",
        "s[:-1] + \", fold=1)\""
    ],
    [
        "STORE_FAST",
        "s"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "LOAD_GLOBAL",
        "_format_time"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._hour"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._minute"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._second"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._microsecond"
    ],
    [
        "LOAD_FAST",
        "timespec"
    ],
    [
        "CALL",
        "_format_time(self._hour, self._minute, self._second,\n                          self._microsecond, timespec)"
    ],
    [
        "STORE_FAST",
        "s"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._tzstr"
    ],
    [
        "CALL",
        "self._tzstr()"
    ],
    [
        "STORE_FAST",
        "tz"
    ],
    [
        "LOAD_FAST",
        "tz"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "LOAD_FAST",
        "tz"
    ],
    [
        "BINARY_OP",
        "s += tz"
    ],
    [
        "STORE_FAST",
        "s"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "time_string"
    ],
    [
        "LOAD_GLOBAL",
        "str"
    ],
    [
        "CALL",
        "isinstance(time_string, str)"
    ],
    [
        "LOAD_GLOBAL",
        "TypeError"
    ],
    [
        "CALL",
        "TypeError('fromisoformat: argument must be str')"
    ],
    [
        "LOAD_FAST",
        "time_string"
    ],
    [
        "LOAD_ATTR",
        "time_string.removeprefix"
    ],
    [
        "CALL",
        "time_string.removeprefix('T')"
    ],
    [
        "STORE_FAST",
        "time_string"
    ],
    [
        "LOAD_FAST",
        "cls"
    ],
    [
        "LOAD_GLOBAL",
        "_parse_isoformat_time"
    ],
    [
        "LOAD_FAST",
        "time_string"
    ],
    [
        "CALL",
        "_parse_isoformat_time(time_string)"
    ],
    [
        "CALL_FUNCTION_EX",
        "cls(*_parse_isoformat_time(time_string))"
    ],
    [
        "LOAD_GLOBAL",
        "Exception"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "LOAD_FAST",
        "time_string"
    ],
    [
        "BUILD_STRING",
        "f'Invalid isoformat string: {time_string!r}'"
    ],
    [
        "CALL",
        "ValueError(f'Invalid isoformat string: {time_string!r}')"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._hour"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._minute"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._second"
    ],
    [
        "STORE_FAST",
        "timetuple"
    ],
    [
        "LOAD_GLOBAL",
        "_wrap_strftime"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_FAST",
        "fmt"
    ],
    [
        "LOAD_FAST",
        "timetuple"
    ],
    [
        "CALL",
        "_wrap_strftime(self, fmt, timetuple)"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "fmt"
    ],
    [
        "LOAD_GLOBAL",
        "str"
    ],
    [
        "CALL",
        "isinstance(fmt, str)"
    ],
    [
        "LOAD_GLOBAL",
        "TypeError"
    ],
    [
        "LOAD_GLOBAL",
        "type"
    ],
    [
        "LOAD_FAST",
        "fmt"
    ],
    [
        "CALL",
        "type(fmt)"
    ],
    [
        "LOAD_ATTR",
        "type(fmt).__name__"
    ],
    [
        "BINARY_OP",
        "\"must be str, not %s\" % type(fmt).__name__"
    ],
    [
        "CALL",
        "TypeError(\"must be str, not %s\" % type(fmt).__name__)"
    ],
    [
        "LOAD_GLOBAL",
        "len"
    ],
    [
        "LOAD_FAST",
        "fmt"
    ],
    [
        "CALL",
        "len(fmt)"
    ],
    [
        "COMPARE_OP",
        "len(fmt) != 0"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.strftime"
    ],
    [
        "LOAD_FAST",
        "fmt"
    ],
    [
        "CALL",
        "self.strftime(fmt)"
    ],
    [
        "LOAD_GLOBAL",
        "str"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "CALL",
        "str(self)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._tzinfo"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._tzinfo"
    ],
    [
        "LOAD_ATTR",
        "self._tzinfo.utcoffset"
    ],
    [
        "CALL",
        "self._tzinfo.utcoffset(None)"
    ],
    [
        "STORE_FAST",
        "offset"
    ],
    [
        "LOAD_GLOBAL",
        "_check_utc_offset"
    ],
    [
        "LOAD_FAST",
        "offset"
    ],
    [
        "CALL",
        "_check_utc_offset(\"utcoffset\", offset)"
    ],
    [
        "LOAD_FAST",
        "offset"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._tzinfo"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._tzinfo"
    ],
    [
        "LOAD_ATTR",
        "self._tzinfo.tzname"
    ],
    [
        "CALL",
        "self._tzinfo.tzname(None)"
    ],
    [
        "STORE_FAST",
        "name"
    ],
    [
        "LOAD_GLOBAL",
        "_check_tzname"
    ],
    [
        "LOAD_FAST",
        "name"
    ],
    [
        "CALL",
        "_check_tzname(name)"
    ],
    [
        "LOAD_FAST",
        "name"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._tzinfo"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._tzinfo"
    ],
    [
        "LOAD_ATTR",
        "self._tzinfo.dst"
    ],
    [
        "CALL",
        "self._tzinfo.dst(None)"
    ],
    [
        "STORE_FAST",
        "offset"
    ],
    [
        "LOAD_GLOBAL",
        "_check_utc_offset"
    ],
    [
        "LOAD_FAST",
        "offset"
    ],
    [
        "CALL",
        "_check_utc_offset(\"dst\", offset)"
    ],
    [
        "LOAD_FAST",
        "offset"
    ],
    [
        "LOAD_FAST",
        "hour"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.hour"
    ],
    [
        "STORE_FAST",
        "hour"
    ],
    [
        "LOAD_FAST",
        "minute"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.minute"
    ],
    [
        "STORE_FAST",
        "minute"
    ],
    [
        "LOAD_FAST",
        "second"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.second"
    ],
    [
        "STORE_FAST",
        "second"
    ],
    [
        "LOAD_FAST",
        "microsecond"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.microsecond"
    ],
    [
        "STORE_FAST",
        "microsecond"
    ],
    [
        "LOAD_FAST",
        "tzinfo"
    ],
    [
        "IS_OP",
        "tzinfo is True"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.tzinfo"
    ],
    [
        "STORE_FAST",
        "tzinfo"
    ],
    [
        "LOAD_FAST",
        "fold"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._fold"
    ],
    [
        "STORE_FAST",
        "fold"
    ],
    [
        "LOAD_GLOBAL",
        "type"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "CALL",
        "type(self)"
    ],
    [
        "LOAD_FAST",
        "hour"
    ],
    [
        "LOAD_FAST",
        "minute"
    ],
    [
        "LOAD_FAST",
        "second"
    ],
    [
        "LOAD_FAST",
        "microsecond"
    ],
    [
        "LOAD_FAST",
        "tzinfo"
    ],
    [
        "LOAD_FAST",
        "fold"
    ],
    [
        "CALL",
        "type(self)(hour, minute, second, microsecond, tzinfo, fold=fold)"
    ],
    [
        "LOAD_GLOBAL",
        "divmod"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._microsecond"
    ],
    [
        "CALL",
        "divmod(self._microsecond, 256)"
    ],
    [
        "STORE_FAST",
        "us2"
    ],
    [
        "STORE_FAST",
        "us3"
    ],
    [
        "LOAD_GLOBAL",
        "divmod"
    ],
    [
        "LOAD_FAST",
        "us2"
    ],
    [
        "CALL",
        "divmod(us2, 256)"
    ],
    [
        "STORE_FAST",
        "us1"
    ],
    [
        "STORE_FAST",
        "us2"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._hour"
    ],
    [
        "STORE_FAST",
        "h"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._fold"
    ],
    [
        "LOAD_FAST",
        "protocol"
    ],
    [
        "COMPARE_OP",
        "protocol > 3"
    ],
    [
        "LOAD_FAST",
        "h"
    ],
    [
        "BINARY_OP",
        "h += 128"
    ],
    [
        "STORE_FAST",
        "h"
    ],
    [
        "LOAD_GLOBAL",
        "bytes"
    ],
    [
        "LOAD_FAST",
        "h"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._minute"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._second"
    ],
    [
        "LOAD_FAST",
        "us1"
    ],
    [
        "LOAD_FAST",
        "us2"
    ],
    [
        "LOAD_FAST",
        "us3"
    ],
    [
        "CALL",
        "bytes([h, self._minute, self._second,\n                           us1, us2, us3])"
    ],
    [
        "STORE_FAST",
        "basestate"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._tzinfo"
    ],
    [
        "LOAD_FAST",
        "basestate"
    ],
    [
        "LOAD_FAST",
        "basestate"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._tzinfo"
    ],
    [
        "LOAD_FAST",
        "tzinfo"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "tzinfo"
    ],
    [
        "LOAD_GLOBAL",
        "_tzinfo_class"
    ],
    [
        "CALL",
        "isinstance(tzinfo, _tzinfo_class)"
    ],
    [
        "LOAD_GLOBAL",
        "TypeError"
    ],
    [
        "CALL",
        "TypeError(\"bad tzinfo state arg\")"
    ],
    [
        "LOAD_FAST",
        "string"
    ],
    [
        "STORE_FAST",
        "h"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._minute"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._second"
    ],
    [
        "STORE_FAST",
        "us1"
    ],
    [
        "STORE_FAST",
        "us2"
    ],
    [
        "STORE_FAST",
        "us3"
    ],
    [
        "LOAD_FAST",
        "h"
    ],
    [
        "COMPARE_OP",
        "h > 127"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._fold"
    ],
    [
        "LOAD_FAST",
        "h"
    ],
    [
        "BINARY_OP",
        "h - 128"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._hour"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._fold"
    ],
    [
        "LOAD_FAST",
        "h"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._hour"
    ],
    [
        "LOAD_FAST",
        "us1"
    ],
    [
        "BINARY_OP",
        "us1 << 8"
    ],
    [
        "LOAD_FAST",
        "us2"
    ],
    [
        "BINARY_OP",
        "(us1 << 8) | us2"
    ],
    [
        "BINARY_OP",
        "((us1 << 8) | us2) << 8"
    ],
    [
        "LOAD_FAST",
        "us3"
    ],
    [
        "BINARY_OP",
        "(((us1 << 8) | us2) << 8) | us3"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._microsecond"
    ],
    [
        "LOAD_FAST",
        "tzinfo"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._tzinfo"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.__class__"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._getstate"
    ],
    [
        "LOAD_FAST",
        "protocol"
    ],
    [
        "CALL",
        "self._getstate(protocol)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.__reduce_ex__"
    ],
    [
        "CALL",
        "self.__reduce_ex__(2)"
    ],
    [
        "STORE_NAME",
        "\"\"\"datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])\n\n    The year, month and day arguments are required. tzinfo may be None, or an\n    instance of a tzinfo subclass. The remaining arguments may be ints.\n    \"\"\""
    ],
    [
        "LOAD_NAME",
        "date"
    ],
    [
        "LOAD_ATTR",
        "date.__slots__"
    ],
    [
        "LOAD_NAME",
        "time"
    ],
    [
        "LOAD_ATTR",
        "time.__slots__"
    ],
    [
        "BINARY_OP",
        "date.__slots__ + time.__slots__"
    ],
    [
        "STORE_NAME",
        "__slots__"
    ],
    [
        "STORE_NAME",
        "    def __new__(cls, year, month=None, day=None, hour=0, minute=0, second=0,\n                microsecond=0, tzinfo=None, *, fold=0):\n        if (isinstance(year, (bytes, str)) and len(year) == 10 and\n            1 <= ord(year[2:3])&0x7F <= 12):\n            # Pickle support\n            if isinstance(year, str):\n                try:\n                    year = bytes(year, 'latin1')\n                except UnicodeEncodeError:\n                    # More informative error message.\n                    raise ValueError(\n                        \"Failed to encode latin1 string when unpickling \"\n                        \"a datetime object. \"\n                        \"pickle.load(data, encoding='latin1') is assumed.\")\n            self = object.__new__(cls)\n            self.__setstate(year, month)\n            self._hashcode = -1\n            return self\n        year, month, day = _check_date_fields(year, month, day)\n        hour, minute, second, microsecond, fold = _check_time_fields(\n            hour, minute, second, microsecond, fold)\n        _check_tzinfo_arg(tzinfo)\n        self = object.__new__(cls)\n        self._year = year\n        self._month = month\n        self._day = day\n        self._hour = hour\n        self._minute = minute\n        self._second = second\n        self._microsecond = microsecond\n        self._tzinfo = tzinfo\n        self._hashcode = -1\n        self._fold = fold\n        return self"
    ],
    [
        "LOAD_NAME",
        "property"
    ],
    [
        "CALL",
        "property"
    ],
    [
        "STORE_NAME",
        "    @property\n    def hour(self):\n        \"\"\"hour (0-23)\"\"\"\n        return self._hour"
    ],
    [
        "LOAD_NAME",
        "property"
    ],
    [
        "CALL",
        "property"
    ],
    [
        "STORE_NAME",
        "    @property\n    def minute(self):\n        \"\"\"minute (0-59)\"\"\"\n        return self._minute"
    ],
    [
        "LOAD_NAME",
        "property"
    ],
    [
        "CALL",
        "property"
    ],
    [
        "STORE_NAME",
        "    @property\n    def second(self):\n        \"\"\"second (0-59)\"\"\"\n        return self._second"
    ],
    [
        "LOAD_NAME",
        "property"
    ],
    [
        "CALL",
        "property"
    ],
    [
        "STORE_NAME",
        "    @property\n    def microsecond(self):\n        \"\"\"microsecond (0-999999)\"\"\"\n        return self._microsecond"
    ],
    [
        "LOAD_NAME",
        "property"
    ],
    [
        "CALL",
        "property"
    ],
    [
        "STORE_NAME",
        "    @property\n    def tzinfo(self):\n        \"\"\"timezone info object\"\"\"\n        return self._tzinfo"
    ],
    [
        "LOAD_NAME",
        "property"
    ],
    [
        "CALL",
        "property"
    ],
    [
        "STORE_NAME",
        "    @property\n    def fold(self):\n        return self._fold"
    ],
    [
        "LOAD_NAME",
        "classmethod"
    ],
    [
        "CALL",
        "classmethod"
    ],
    [
        "STORE_NAME",
        "    @classmethod\n    def _fromtimestamp(cls, t, utc, tz):\n        \"\"\"Construct a datetime from a POSIX timestamp (like time.time()).\n\n        A timezone info object may be passed in as well.\n        \"\"\"\n        frac, t = _math.modf(t)\n        us = round(frac * 1e6)\n        if us >= 1000000:\n            t += 1\n            us -= 1000000\n        elif us < 0:\n            t -= 1\n            us += 1000000\n\n        converter = _time.gmtime if utc else _time.localtime\n        y, m, d, hh, mm, ss, weekday, jday, dst = converter(t)\n        ss = min(ss, 59)    # clamp out leap seconds if the platform has them\n        result = cls(y, m, d, hh, mm, ss, us, tz)\n        if tz is None and not utc:\n            # As of version 2015f max fold in IANA database is\n            # 23 hours at 1969-09-30 13:00:00 in Kwajalein.\n            # Let's probe 24 hours in the past to detect a transition:\n            max_fold_seconds = 24 * 3600\n\n            # On Windows localtime_s throws an OSError for negative values,\n            # thus we can't perform fold detection for values of time less\n            # than the max time fold. See comments in _datetimemodule's\n            # version of this method for more details.\n            if t < max_fold_seconds and sys.platform.startswith(\"win\"):\n                return result\n\n            y, m, d, hh, mm, ss = converter(t - max_fold_seconds)[:6]\n            probe1 = cls(y, m, d, hh, mm, ss, us, tz)\n            trans = result - probe1 - timedelta(0, max_fold_seconds)\n            if trans.days < 0:\n                y, m, d, hh, mm, ss = converter(t + trans // timedelta(0, 1))[:6]\n                probe2 = cls(y, m, d, hh, mm, ss, us, tz)\n                if probe2 == result:\n                    result._fold = 1\n        elif tz is not None:\n            result = tz.fromutc(result)\n        return result"
    ],
    [
        "LOAD_NAME",
        "classmethod"
    ],
    [
        "CALL",
        "classmethod"
    ],
    [
        "STORE_NAME",
        "    @classmethod\n    def fromtimestamp(cls, t, tz=None):\n        \"\"\"Construct a datetime from a POSIX timestamp (like time.time()).\n\n        A timezone info object may be passed in as well.\n        \"\"\"\n        _check_tzinfo_arg(tz)\n\n        return cls._fromtimestamp(t, tz is not None, tz)"
    ],
    [
        "LOAD_NAME",
        "classmethod"
    ],
    [
        "CALL",
        "classmethod"
    ],
    [
        "STORE_NAME",
        "    @classmethod\n    def utcfromtimestamp(cls, t):\n        \"\"\"Construct a naive UTC datetime from a POSIX timestamp.\"\"\"\n        return cls._fromtimestamp(t, True, None)"
    ],
    [
        "LOAD_NAME",
        "classmethod"
    ],
    [
        "CALL",
        "classmethod"
    ],
    [
        "STORE_NAME",
        "    @classmethod\n    def now(cls, tz=None):\n        \"Construct a datetime from time.time() and optional time zone info.\"\n        t = _time.time()\n        return cls.fromtimestamp(t, tz)"
    ],
    [
        "LOAD_NAME",
        "classmethod"
    ],
    [
        "CALL",
        "classmethod"
    ],
    [
        "STORE_NAME",
        "    @classmethod\n    def utcnow(cls):\n        \"Construct a UTC datetime from time.time().\"\n        t = _time.time()\n        return cls.utcfromtimestamp(t)"
    ],
    [
        "LOAD_NAME",
        "classmethod"
    ],
    [
        "CALL",
        "classmethod"
    ],
    [
        "STORE_NAME",
        "    @classmethod\n    def combine(cls, date, time, tzinfo=True):\n        \"Construct a datetime from a given date and a given time.\"\n        if not isinstance(date, _date_class):\n            raise TypeError(\"date argument must be a date instance\")\n        if not isinstance(time, _time_class):\n            raise TypeError(\"time argument must be a time instance\")\n        if tzinfo is True:\n            tzinfo = time.tzinfo\n        return cls(date.year, date.month, date.day,\n                   time.hour, time.minute, time.second, time.microsecond,\n                   tzinfo, fold=time.fold)"
    ],
    [
        "LOAD_NAME",
        "classmethod"
    ],
    [
        "CALL",
        "classmethod"
    ],
    [
        "STORE_NAME",
        "    @classmethod\n    def fromisoformat(cls, date_string):\n        \"\"\"Construct a datetime from a string in one of the ISO 8601 formats.\"\"\"\n        if not isinstance(date_string, str):\n            raise TypeError('fromisoformat: argument must be str')\n\n        if len(date_string) < 7:\n            raise ValueError(f'Invalid isoformat string: {date_string!r}')\n\n        # Split this at the separator\n        try:\n            separator_location = _find_isoformat_datetime_separator(date_string)\n            dstr = date_string[0:separator_location]\n            tstr = date_string[(separator_location+1):]\n\n            date_components = _parse_isoformat_date(dstr)\n        except ValueError:\n            raise ValueError(\n                f'Invalid isoformat string: {date_string!r}') from None\n\n        if tstr:\n            try:\n                time_components = _parse_isoformat_time(tstr)\n            except ValueError:\n                raise ValueError(\n                    f'Invalid isoformat string: {date_string!r}') from None\n        else:\n            time_components = [0, 0, 0, 0, None]\n\n        return cls(*(date_components + time_components))"
    ],
    [
        "STORE_NAME",
        "    def timetuple(self):\n        \"Return local time tuple compatible with time.localtime().\"\n        dst = self.dst()\n        if dst is None:\n            dst = -1\n        elif dst:\n            dst = 1\n        else:\n            dst = 0\n        return _build_struct_time(self.year, self.month, self.day,\n                                  self.hour, self.minute, self.second,\n                                  dst)"
    ],
    [
        "STORE_NAME",
        "    def _mktime(self):\n        \"\"\"Return integer POSIX timestamp.\"\"\"\n        epoch = datetime(1970, 1, 1)\n        max_fold_seconds = 24 * 3600\n        t = (self - epoch) // timedelta(0, 1)\n        def local(u):\n            y, m, d, hh, mm, ss = _time.localtime(u)[:6]\n            return (datetime(y, m, d, hh, mm, ss) - epoch) // timedelta(0, 1)\n\n        # Our goal is to solve t = local(u) for u.\n        a = local(t) - t\n        u1 = t - a\n        t1 = local(u1)\n        if t1 == t:\n            # We found one solution, but it may not be the one we need.\n            # Look for an earlier solution (if `fold` is 0), or a\n            # later one (if `fold` is 1).\n            u2 = u1 + (-max_fold_seconds, max_fold_seconds)[self.fold]\n            b = local(u2) - u2\n            if a == b:\n                return u1\n        else:\n            b = t1 - u1\n            assert a != b\n        u2 = t - b\n        t2 = local(u2)\n        if t2 == t:\n            return u2\n        if t1 == t:\n            return u1\n        # We have found both offsets a and b, but neither t - a nor t - b is\n        # a solution.  This means t is in the gap.\n        return (max, min)[self.fold](u1, u2)"
    ],
    [
        "STORE_NAME",
        "    def timestamp(self):\n        \"Return POSIX timestamp as float\"\n        if self._tzinfo is None:\n            s = self._mktime()\n            return s + self.microsecond / 1e6\n        else:\n            return (self - _EPOCH).total_seconds()"
    ],
    [
        "STORE_NAME",
        "    def utctimetuple(self):\n        \"Return UTC time tuple compatible with time.gmtime().\"\n        offset = self.utcoffset()\n        if offset:\n            self -= offset\n        y, m, d = self.year, self.month, self.day\n        hh, mm, ss = self.hour, self.minute, self.second\n        return _build_struct_time(y, m, d, hh, mm, ss, 0)"
    ],
    [
        "STORE_NAME",
        "    def date(self):\n        \"Return the date part.\"\n        return date(self._year, self._month, self._day)"
    ],
    [
        "STORE_NAME",
        "    def time(self):\n        \"Return the time part, with tzinfo None.\"\n        return time(self.hour, self.minute, self.second, self.microsecond, fold=self.fold)"
    ],
    [
        "STORE_NAME",
        "    def timetz(self):\n        \"Return the time part, with same tzinfo.\"\n        return time(self.hour, self.minute, self.second, self.microsecond,\n                    self._tzinfo, fold=self.fold)"
    ],
    [
        "STORE_NAME",
        "    def replace(self, year=None, month=None, day=None, hour=None,\n                minute=None, second=None, microsecond=None, tzinfo=True,\n                *, fold=None):\n        \"\"\"Return a new datetime with new values for the specified fields.\"\"\"\n        if year is None:\n            year = self.year\n        if month is None:\n            month = self.month\n        if day is None:\n            day = self.day\n        if hour is None:\n            hour = self.hour\n        if minute is None:\n            minute = self.minute\n        if second is None:\n            second = self.second\n        if microsecond is None:\n            microsecond = self.microsecond\n        if tzinfo is True:\n            tzinfo = self.tzinfo\n        if fold is None:\n            fold = self.fold\n        return type(self)(year, month, day, hour, minute, second,\n                          microsecond, tzinfo, fold=fold)"
    ],
    [
        "STORE_NAME",
        "    def _local_timezone(self):\n        if self.tzinfo is None:\n            ts = self._mktime()\n        else:\n            ts = (self - _EPOCH) // timedelta(seconds=1)\n        localtm = _time.localtime(ts)\n        local = datetime(*localtm[:6])\n        # Extract TZ data\n        gmtoff = localtm.tm_gmtoff\n        zone = localtm.tm_zone\n        return timezone(timedelta(seconds=gmtoff), zone)"
    ],
    [
        "STORE_NAME",
        "    def astimezone(self, tz=None):\n        if tz is None:\n            tz = self._local_timezone()\n        elif not isinstance(tz, tzinfo):\n            raise TypeError(\"tz argument must be an instance of tzinfo\")\n\n        mytz = self.tzinfo\n        if mytz is None:\n            mytz = self._local_timezone()\n            myoffset = mytz.utcoffset(self)\n        else:\n            myoffset = mytz.utcoffset(self)\n            if myoffset is None:\n                mytz = self.replace(tzinfo=None)._local_timezone()\n                myoffset = mytz.utcoffset(self)\n\n        if tz is mytz:\n            return self\n\n        # Convert self to UTC, and attach the new time zone object.\n        utc = (self - myoffset).replace(tzinfo=tz)\n\n        # Convert from UTC to tz's local time.\n        return tz.fromutc(utc)"
    ],
    [
        "STORE_NAME",
        "    def ctime(self):\n        \"Return ctime() style string.\"\n        weekday = self.toordinal() % 7 or 7\n        return \"%s %s %2d %02d:%02d:%02d %04d\" % (\n            _DAYNAMES[weekday],\n            _MONTHNAMES[self._month],\n            self._day,\n            self._hour, self._minute, self._second,\n            self._year)"
    ],
    [
        "STORE_NAME",
        "    def isoformat(self, sep='T', timespec='auto'):\n        \"\"\"Return the time formatted according to ISO.\n\n        The full format looks like 'YYYY-MM-DD HH:MM:SS.mmmmmm'.\n        By default, the fractional part is omitted if self.microsecond == 0.\n\n        If self.tzinfo is not None, the UTC offset is also attached, giving\n        giving a full format of 'YYYY-MM-DD HH:MM:SS.mmmmmm+HH:MM'.\n\n        Optional argument sep specifies the separator between date and\n        time, default 'T'.\n\n        The optional argument timespec specifies the number of additional\n        terms of the time to include. Valid options are 'auto', 'hours',\n        'minutes', 'seconds', 'milliseconds' and 'microseconds'.\n        \"\"\"\n        s = (\"%04d-%02d-%02d%c\" % (self._year, self._month, self._day, sep) +\n             _format_time(self._hour, self._minute, self._second,\n                          self._microsecond, timespec))\n\n        off = self.utcoffset()\n        tz = _format_offset(off)\n        if tz:\n            s += tz\n\n        return s"
    ],
    [
        "STORE_NAME",
        "    def __repr__(self):\n        \"\"\"Convert to formal string, for repr().\"\"\"\n        L = [self._year, self._month, self._day,  # These are never zero\n             self._hour, self._minute, self._second, self._microsecond]\n        if L[-1] == 0:\n            del L[-1]\n        if L[-1] == 0:\n            del L[-1]\n        s = \"%s.%s(%s)\" % (self.__class__.__module__,\n                           self.__class__.__qualname__,\n                           \", \".join(map(str, L)))\n        if self._tzinfo is not None:\n            assert s[-1:] == \")\"\n            s = s[:-1] + \", tzinfo=%r\" % self._tzinfo + \")\"\n        if self._fold:\n            assert s[-1:] == \")\"\n            s = s[:-1] + \", fold=1)\"\n        return s"
    ],
    [
        "STORE_NAME",
        "    def __str__(self):\n        \"Convert to string, for str().\"\n        return self.isoformat(sep=' ')"
    ],
    [
        "LOAD_NAME",
        "classmethod"
    ],
    [
        "CALL",
        "classmethod"
    ],
    [
        "STORE_NAME",
        "    @classmethod\n    def strptime(cls, date_string, format):\n        'string, format -> new datetime parsed from a string (like time.strptime()).'\n        import _strptime\n        return _strptime._strptime_datetime(cls, date_string, format)"
    ],
    [
        "STORE_NAME",
        "    def utcoffset(self):\n        \"\"\"Return the timezone offset as timedelta positive east of UTC (negative west of\n        UTC).\"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.utcoffset(self)\n        _check_utc_offset(\"utcoffset\", offset)\n        return offset"
    ],
    [
        "STORE_NAME",
        "    def tzname(self):\n        \"\"\"Return the timezone name.\n\n        Note that the name is 100% informational -- there's no requirement that\n        it mean anything in particular. For example, \"GMT\", \"UTC\", \"-500\",\n        \"-5:00\", \"EDT\", \"US/Eastern\", \"America/New York\" are all valid replies.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        name = self._tzinfo.tzname(self)\n        _check_tzname(name)\n        return name"
    ],
    [
        "STORE_NAME",
        "    def dst(self):\n        \"\"\"Return 0 if DST is not in effect, or the DST offset (as timedelta\n        positive eastward) if DST is in effect.\n\n        This is purely informational; the DST offset has already been added to\n        the UTC offset returned by utcoffset() if applicable, so there's no\n        need to consult dst() unless you're interested in displaying the DST\n        info.\n        \"\"\"\n        if self._tzinfo is None:\n            return None\n        offset = self._tzinfo.dst(self)\n        _check_utc_offset(\"dst\", offset)\n        return offset"
    ],
    [
        "STORE_NAME",
        "    def __eq__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other, allow_mixed=True) == 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            return False"
    ],
    [
        "STORE_NAME",
        "    def __le__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) <= 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)"
    ],
    [
        "STORE_NAME",
        "    def __lt__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) < 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)"
    ],
    [
        "STORE_NAME",
        "    def __ge__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) >= 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)"
    ],
    [
        "STORE_NAME",
        "    def __gt__(self, other):\n        if isinstance(other, datetime):\n            return self._cmp(other) > 0\n        elif not isinstance(other, date):\n            return NotImplemented\n        else:\n            _cmperror(self, other)"
    ],
    [
        "STORE_NAME",
        "    def _cmp(self, other, allow_mixed=False):\n        assert isinstance(other, datetime)\n        mytz = self._tzinfo\n        ottz = other._tzinfo\n        myoff = otoff = None\n\n        if mytz is ottz:\n            base_compare = True\n        else:\n            myoff = self.utcoffset()\n            otoff = other.utcoffset()\n            # Assume that allow_mixed means that we are called from __eq__\n            if allow_mixed:\n                if myoff != self.replace(fold=not self.fold).utcoffset():\n                    return 2\n                if otoff != other.replace(fold=not other.fold).utcoffset():\n                    return 2\n            base_compare = myoff == otoff\n\n        if base_compare:\n            return _cmp((self._year, self._month, self._day,\n                         self._hour, self._minute, self._second,\n                         self._microsecond),\n                        (other._year, other._month, other._day,\n                         other._hour, other._minute, other._second,\n                         other._microsecond))\n        if myoff is None or otoff is None:\n            if allow_mixed:\n                return 2 # arbitrary non-zero value\n            else:\n                raise TypeError(\"cannot compare naive and aware datetimes\")\n        # XXX What follows could be done more efficiently...\n        diff = self - other     # this will take offsets into account\n        if diff.days < 0:\n            return -1\n        return diff and 1 or 0"
    ],
    [
        "STORE_NAME",
        "    def __add__(self, other):\n        \"Add a datetime and a timedelta.\"\n        if not isinstance(other, timedelta):\n            return NotImplemented\n        delta = timedelta(self.toordinal(),\n                          hours=self._hour,\n                          minutes=self._minute,\n                          seconds=self._second,\n                          microseconds=self._microsecond)\n        delta += other\n        hour, rem = divmod(delta.seconds, 3600)\n        minute, second = divmod(rem, 60)\n        if 0 < delta.days <= _MAXORDINAL:\n            return type(self).combine(date.fromordinal(delta.days),\n                                      time(hour, minute, second,\n                                           delta.microseconds,\n                                           tzinfo=self._tzinfo))\n        raise OverflowError(\"result out of range\")"
    ],
    [
        "LOAD_NAME",
        "__add__"
    ],
    [
        "STORE_NAME",
        "__radd__"
    ],
    [
        "STORE_NAME",
        "    def __sub__(self, other):\n        \"Subtract two datetimes, or a datetime and a timedelta.\"\n        if not isinstance(other, datetime):\n            if isinstance(other, timedelta):\n                return self + -other\n            return NotImplemented\n\n        days1 = self.toordinal()\n        days2 = other.toordinal()\n        secs1 = self._second + self._minute * 60 + self._hour * 3600\n        secs2 = other._second + other._minute * 60 + other._hour * 3600\n        base = timedelta(days1 - days2,\n                         secs1 - secs2,\n                         self._microsecond - other._microsecond)\n        if self._tzinfo is other._tzinfo:\n            return base\n        myoff = self.utcoffset()\n        otoff = other.utcoffset()\n        if myoff == otoff:\n            return base\n        if myoff is None or otoff is None:\n            raise TypeError(\"cannot mix naive and timezone-aware time\")\n        return base + otoff - myoff"
    ],
    [
        "STORE_NAME",
        "    def __hash__(self):\n        if self._hashcode == -1:\n            if self.fold:\n                t = self.replace(fold=0)\n            else:\n                t = self\n            tzoff = t.utcoffset()\n            if tzoff is None:\n                self._hashcode = hash(t._getstate()[0])\n            else:\n                days = _ymd2ord(self.year, self.month, self.day)\n                seconds = self.hour * 3600 + self.minute * 60 + self.second\n                self._hashcode = hash(timedelta(days, seconds, self.microsecond) - tzoff)\n        return self._hashcode"
    ],
    [
        "STORE_NAME",
        "    def _getstate(self, protocol=3):\n        yhi, ylo = divmod(self._year, 256)\n        us2, us3 = divmod(self._microsecond, 256)\n        us1, us2 = divmod(us2, 256)\n        m = self._month\n        if self._fold and protocol > 3:\n            m += 128\n        basestate = bytes([yhi, ylo, m, self._day,\n                           self._hour, self._minute, self._second,\n                           us1, us2, us3])\n        if self._tzinfo is None:\n            return (basestate,)\n        else:\n            return (basestate, self._tzinfo)"
    ],
    [
        "STORE_NAME",
        "    def __setstate(self, string, tzinfo):\n        if tzinfo is not None and not isinstance(tzinfo, _tzinfo_class):\n            raise TypeError(\"bad tzinfo state arg\")\n        (yhi, ylo, m, self._day, self._hour,\n         self._minute, self._second, us1, us2, us3) = string\n        if m > 127:\n            self._fold = 1\n            self._month = m - 128\n        else:\n            self._fold = 0\n            self._month = m\n        self._year = yhi * 256 + ylo\n        self._microsecond = (((us1 << 8) | us2) << 8) | us3\n        self._tzinfo = tzinfo"
    ],
    [
        "STORE_NAME",
        "    def __reduce_ex__(self, protocol):\n        return (self.__class__, self._getstate(protocol))"
    ],
    [
        "STORE_NAME",
        "    def __reduce__(self):\n        return self.__reduce_ex__(2)"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "LOAD_GLOBAL",
        "bytes"
    ],
    [
        "LOAD_GLOBAL",
        "str"
    ],
    [
        "CALL",
        "isinstance(year, (bytes, str))"
    ],
    [
        "LOAD_GLOBAL",
        "len"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "CALL",
        "len(year)"
    ],
    [
        "COMPARE_OP",
        "len(year) == 10"
    ],
    [
        "LOAD_GLOBAL",
        "ord"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "BINARY_SLICE",
        "year[2:3]"
    ],
    [
        "CALL",
        "ord(year[2:3])"
    ],
    [
        "BINARY_OP",
        "ord(year[2:3])&0x7F"
    ],
    [
        "COMPARE_OP",
        "1 <= ord(year[2:3])&0x7F <= 12"
    ],
    [
        "COMPARE_OP",
        "1 <= ord(year[2:3])&0x7F <= 12"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "LOAD_GLOBAL",
        "str"
    ],
    [
        "CALL",
        "isinstance(year, str)"
    ],
    [
        "LOAD_GLOBAL",
        "bytes"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "CALL",
        "bytes(year, 'latin1')"
    ],
    [
        "STORE_FAST",
        "year"
    ],
    [
        "LOAD_GLOBAL",
        "object"
    ],
    [
        "LOAD_ATTR",
        "object.__new__"
    ],
    [
        "LOAD_FAST",
        "cls"
    ],
    [
        "CALL",
        "object.__new__(cls)"
    ],
    [
        "STORE_FAST",
        "self"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.__setstate"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "LOAD_FAST",
        "month"
    ],
    [
        "CALL",
        "self.__setstate(year, month)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._hashcode"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_GLOBAL",
        "_check_date_fields"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "LOAD_FAST",
        "month"
    ],
    [
        "LOAD_FAST",
        "day"
    ],
    [
        "CALL",
        "_check_date_fields(year, month, day)"
    ],
    [
        "STORE_FAST",
        "year"
    ],
    [
        "STORE_FAST",
        "month"
    ],
    [
        "STORE_FAST",
        "day"
    ],
    [
        "LOAD_GLOBAL",
        "_check_time_fields"
    ],
    [
        "LOAD_FAST",
        "hour"
    ],
    [
        "LOAD_FAST",
        "minute"
    ],
    [
        "LOAD_FAST",
        "second"
    ],
    [
        "LOAD_FAST",
        "microsecond"
    ],
    [
        "LOAD_FAST",
        "fold"
    ],
    [
        "CALL",
        "_check_time_fields(\n            hour, minute, second, microsecond, fold)"
    ],
    [
        "STORE_FAST",
        "hour"
    ],
    [
        "STORE_FAST",
        "minute"
    ],
    [
        "STORE_FAST",
        "second"
    ],
    [
        "STORE_FAST",
        "microsecond"
    ],
    [
        "STORE_FAST",
        "fold"
    ],
    [
        "LOAD_GLOBAL",
        "_check_tzinfo_arg"
    ],
    [
        "LOAD_FAST",
        "tzinfo"
    ],
    [
        "CALL",
        "_check_tzinfo_arg(tzinfo)"
    ],
    [
        "LOAD_GLOBAL",
        "object"
    ],
    [
        "LOAD_ATTR",
        "object.__new__"
    ],
    [
        "LOAD_FAST",
        "cls"
    ],
    [
        "CALL",
        "object.__new__(cls)"
    ],
    [
        "STORE_FAST",
        "self"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._year"
    ],
    [
        "LOAD_FAST",
        "month"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._month"
    ],
    [
        "LOAD_FAST",
        "day"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._day"
    ],
    [
        "LOAD_FAST",
        "hour"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._hour"
    ],
    [
        "LOAD_FAST",
        "minute"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._minute"
    ],
    [
        "LOAD_FAST",
        "second"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._second"
    ],
    [
        "LOAD_FAST",
        "microsecond"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._microsecond"
    ],
    [
        "LOAD_FAST",
        "tzinfo"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._tzinfo"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._hashcode"
    ],
    [
        "LOAD_FAST",
        "fold"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._fold"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_GLOBAL",
        "UnicodeEncodeError"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "CALL",
        "ValueError(\n                        \"Failed to encode latin1 string when unpickling \"\n                        \"a datetime object. \"\n                        \"pickle.load(data, encoding='latin1') is assumed.\")"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._hour"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._minute"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._second"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._microsecond"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._tzinfo"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._fold"
    ],
    [
        "LOAD_GLOBAL",
        "_math"
    ],
    [
        "LOAD_ATTR",
        "_math.modf"
    ],
    [
        "LOAD_FAST",
        "t"
    ],
    [
        "CALL",
        "_math.modf(t)"
    ],
    [
        "STORE_FAST",
        "frac"
    ],
    [
        "STORE_FAST",
        "t"
    ],
    [
        "LOAD_GLOBAL",
        "round"
    ],
    [
        "LOAD_FAST",
        "frac"
    ],
    [
        "BINARY_OP",
        "frac * 1e6"
    ],
    [
        "CALL",
        "round(frac * 1e6)"
    ],
    [
        "STORE_FAST",
        "us"
    ],
    [
        "LOAD_FAST",
        "us"
    ],
    [
        "COMPARE_OP",
        "us >= 1000000"
    ],
    [
        "LOAD_FAST",
        "t"
    ],
    [
        "BINARY_OP",
        "t += 1"
    ],
    [
        "STORE_FAST",
        "t"
    ],
    [
        "LOAD_FAST",
        "us"
    ],
    [
        "BINARY_OP",
        "us -= 1000000"
    ],
    [
        "STORE_FAST",
        "us"
    ],
    [
        "LOAD_FAST",
        "us"
    ],
    [
        "COMPARE_OP",
        "us < 0"
    ],
    [
        "LOAD_FAST",
        "t"
    ],
    [
        "BINARY_OP",
        "t -= 1"
    ],
    [
        "STORE_FAST",
        "t"
    ],
    [
        "LOAD_FAST",
        "us"
    ],
    [
        "BINARY_OP",
        "us += 1000000"
    ],
    [
        "STORE_FAST",
        "us"
    ],
    [
        "LOAD_FAST",
        "utc"
    ],
    [
        "LOAD_GLOBAL",
        "_time"
    ],
    [
        "LOAD_ATTR",
        "_time.gmtime"
    ],
    [
        "LOAD_GLOBAL",
        "_time"
    ],
    [
        "LOAD_ATTR",
        "_time.localtime"
    ],
    [
        "STORE_FAST",
        "converter"
    ],
    [
        "LOAD_FAST",
        "converter"
    ],
    [
        "LOAD_FAST",
        "t"
    ],
    [
        "CALL",
        "converter(t)"
    ],
    [
        "STORE_FAST",
        "y"
    ],
    [
        "STORE_FAST",
        "m"
    ],
    [
        "STORE_FAST",
        "d"
    ],
    [
        "STORE_FAST",
        "hh"
    ],
    [
        "STORE_FAST",
        "mm"
    ],
    [
        "STORE_FAST",
        "ss"
    ],
    [
        "STORE_FAST",
        "weekday"
    ],
    [
        "STORE_FAST",
        "jday"
    ],
    [
        "STORE_FAST",
        "dst"
    ],
    [
        "LOAD_GLOBAL",
        "min"
    ],
    [
        "LOAD_FAST",
        "ss"
    ],
    [
        "CALL",
        "min(ss, 59)"
    ],
    [
        "STORE_FAST",
        "ss"
    ],
    [
        "LOAD_FAST",
        "cls"
    ],
    [
        "LOAD_FAST",
        "y"
    ],
    [
        "LOAD_FAST",
        "m"
    ],
    [
        "LOAD_FAST",
        "d"
    ],
    [
        "LOAD_FAST",
        "hh"
    ],
    [
        "LOAD_FAST",
        "mm"
    ],
    [
        "LOAD_FAST",
        "ss"
    ],
    [
        "LOAD_FAST",
        "us"
    ],
    [
        "LOAD_FAST",
        "tz"
    ],
    [
        "CALL",
        "cls(y, m, d, hh, mm, ss, us, tz)"
    ],
    [
        "STORE_FAST",
        "result"
    ],
    [
        "LOAD_FAST",
        "tz"
    ],
    [
        "LOAD_FAST",
        "utc"
    ],
    [
        "STORE_FAST",
        "max_fold_seconds"
    ],
    [
        "LOAD_FAST",
        "t"
    ],
    [
        "LOAD_FAST",
        "max_fold_seconds"
    ],
    [
        "COMPARE_OP",
        "t < max_fold_seconds"
    ],
    [
        "LOAD_GLOBAL",
        "sys"
    ],
    [
        "LOAD_ATTR",
        "sys.platform"
    ],
    [
        "LOAD_ATTR",
        "sys.platform.startswith"
    ],
    [
        "CALL",
        "sys.platform.startswith(\"win\")"
    ],
    [
        "LOAD_FAST",
        "result"
    ],
    [
        "LOAD_FAST",
        "converter"
    ],
    [
        "LOAD_FAST",
        "t"
    ],
    [
        "LOAD_FAST",
        "max_fold_seconds"
    ],
    [
        "BINARY_OP",
        "t - max_fold_seconds"
    ],
    [
        "CALL",
        "converter(t - max_fold_seconds)"
    ],
    [
        "BINARY_SLICE",
        "converter(t - max_fold_seconds)[:6]"
    ],
    [
        "STORE_FAST",
        "y"
    ],
    [
        "STORE_FAST",
        "m"
    ],
    [
        "STORE_FAST",
        "d"
    ],
    [
        "STORE_FAST",
        "hh"
    ],
    [
        "STORE_FAST",
        "mm"
    ],
    [
        "STORE_FAST",
        "ss"
    ],
    [
        "LOAD_FAST",
        "cls"
    ],
    [
        "LOAD_FAST",
        "y"
    ],
    [
        "LOAD_FAST",
        "m"
    ],
    [
        "LOAD_FAST",
        "d"
    ],
    [
        "LOAD_FAST",
        "hh"
    ],
    [
        "LOAD_FAST",
        "mm"
    ],
    [
        "LOAD_FAST",
        "ss"
    ],
    [
        "LOAD_FAST",
        "us"
    ],
    [
        "LOAD_FAST",
        "tz"
    ],
    [
        "CALL",
        "cls(y, m, d, hh, mm, ss, us, tz)"
    ],
    [
        "STORE_FAST",
        "probe1"
    ],
    [
        "LOAD_FAST",
        "result"
    ],
    [
        "LOAD_FAST",
        "probe1"
    ],
    [
        "BINARY_OP",
        "result - probe1"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "LOAD_FAST",
        "max_fold_seconds"
    ],
    [
        "CALL",
        "timedelta(0, max_fold_seconds)"
    ],
    [
        "BINARY_OP",
        "result - probe1 - timedelta(0, max_fold_seconds)"
    ],
    [
        "STORE_FAST",
        "trans"
    ],
    [
        "LOAD_FAST",
        "trans"
    ],
    [
        "LOAD_ATTR",
        "trans.days"
    ],
    [
        "COMPARE_OP",
        "trans.days < 0"
    ],
    [
        "LOAD_FAST",
        "converter"
    ],
    [
        "LOAD_FAST",
        "t"
    ],
    [
        "LOAD_FAST",
        "trans"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "CALL",
        "timedelta(0, 1)"
    ],
    [
        "BINARY_OP",
        "trans // timedelta(0, 1)"
    ],
    [
        "BINARY_OP",
        "t + trans // timedelta(0, 1)"
    ],
    [
        "CALL",
        "converter(t + trans // timedelta(0, 1))"
    ],
    [
        "BINARY_SLICE",
        "converter(t + trans // timedelta(0, 1))[:6]"
    ],
    [
        "STORE_FAST",
        "y"
    ],
    [
        "STORE_FAST",
        "m"
    ],
    [
        "STORE_FAST",
        "d"
    ],
    [
        "STORE_FAST",
        "hh"
    ],
    [
        "STORE_FAST",
        "mm"
    ],
    [
        "STORE_FAST",
        "ss"
    ],
    [
        "LOAD_FAST",
        "cls"
    ],
    [
        "LOAD_FAST",
        "y"
    ],
    [
        "LOAD_FAST",
        "m"
    ],
    [
        "LOAD_FAST",
        "d"
    ],
    [
        "LOAD_FAST",
        "hh"
    ],
    [
        "LOAD_FAST",
        "mm"
    ],
    [
        "LOAD_FAST",
        "ss"
    ],
    [
        "LOAD_FAST",
        "us"
    ],
    [
        "LOAD_FAST",
        "tz"
    ],
    [
        "CALL",
        "cls(y, m, d, hh, mm, ss, us, tz)"
    ],
    [
        "STORE_FAST",
        "probe2"
    ],
    [
        "LOAD_FAST",
        "probe2"
    ],
    [
        "LOAD_FAST",
        "result"
    ],
    [
        "COMPARE_OP",
        "probe2 == result"
    ],
    [
        "LOAD_FAST",
        "result"
    ],
    [
        "STORE_ATTR",
        "result._fold"
    ],
    [
        "LOAD_FAST",
        "result"
    ],
    [
        "LOAD_FAST",
        "tz"
    ],
    [
        "LOAD_FAST",
        "tz"
    ],
    [
        "LOAD_ATTR",
        "tz.fromutc"
    ],
    [
        "LOAD_FAST",
        "result"
    ],
    [
        "CALL",
        "tz.fromutc(result)"
    ],
    [
        "STORE_FAST",
        "result"
    ],
    [
        "LOAD_FAST",
        "result"
    ],
    [
        "LOAD_GLOBAL",
        "_check_tzinfo_arg"
    ],
    [
        "LOAD_FAST",
        "tz"
    ],
    [
        "CALL",
        "_check_tzinfo_arg(tz)"
    ],
    [
        "LOAD_FAST",
        "cls"
    ],
    [
        "LOAD_ATTR",
        "cls._fromtimestamp"
    ],
    [
        "LOAD_FAST",
        "t"
    ],
    [
        "LOAD_FAST",
        "tz"
    ],
    [
        "IS_OP",
        "tz is not None"
    ],
    [
        "LOAD_FAST",
        "tz"
    ],
    [
        "CALL",
        "cls._fromtimestamp(t, tz is not None, tz)"
    ],
    [
        "LOAD_FAST",
        "cls"
    ],
    [
        "LOAD_ATTR",
        "cls._fromtimestamp"
    ],
    [
        "LOAD_FAST",
        "t"
    ],
    [
        "CALL",
        "cls._fromtimestamp(t, True, None)"
    ],
    [
        "LOAD_GLOBAL",
        "_time"
    ],
    [
        "LOAD_ATTR",
        "_time.time"
    ],
    [
        "CALL",
        "_time.time()"
    ],
    [
        "STORE_FAST",
        "t"
    ],
    [
        "LOAD_FAST",
        "cls"
    ],
    [
        "LOAD_ATTR",
        "cls.fromtimestamp"
    ],
    [
        "LOAD_FAST",
        "t"
    ],
    [
        "LOAD_FAST",
        "tz"
    ],
    [
        "CALL",
        "cls.fromtimestamp(t, tz)"
    ],
    [
        "LOAD_GLOBAL",
        "_time"
    ],
    [
        "LOAD_ATTR",
        "_time.time"
    ],
    [
        "CALL",
        "_time.time()"
    ],
    [
        "STORE_FAST",
        "t"
    ],
    [
        "LOAD_FAST",
        "cls"
    ],
    [
        "LOAD_ATTR",
        "cls.utcfromtimestamp"
    ],
    [
        "LOAD_FAST",
        "t"
    ],
    [
        "CALL",
        "cls.utcfromtimestamp(t)"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "date"
    ],
    [
        "LOAD_GLOBAL",
        "_date_class"
    ],
    [
        "CALL",
        "isinstance(date, _date_class)"
    ],
    [
        "LOAD_GLOBAL",
        "TypeError"
    ],
    [
        "CALL",
        "TypeError(\"date argument must be a date instance\")"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "time"
    ],
    [
        "LOAD_GLOBAL",
        "_time_class"
    ],
    [
        "CALL",
        "isinstance(time, _time_class)"
    ],
    [
        "LOAD_GLOBAL",
        "TypeError"
    ],
    [
        "CALL",
        "TypeError(\"time argument must be a time instance\")"
    ],
    [
        "LOAD_FAST",
        "tzinfo"
    ],
    [
        "IS_OP",
        "tzinfo is True"
    ],
    [
        "LOAD_FAST",
        "time"
    ],
    [
        "LOAD_ATTR",
        "time.tzinfo"
    ],
    [
        "STORE_FAST",
        "tzinfo"
    ],
    [
        "LOAD_FAST",
        "cls"
    ],
    [
        "LOAD_FAST",
        "date"
    ],
    [
        "LOAD_ATTR",
        "date.year"
    ],
    [
        "LOAD_FAST",
        "date"
    ],
    [
        "LOAD_ATTR",
        "date.month"
    ],
    [
        "LOAD_FAST",
        "date"
    ],
    [
        "LOAD_ATTR",
        "date.day"
    ],
    [
        "LOAD_FAST",
        "time"
    ],
    [
        "LOAD_ATTR",
        "time.hour"
    ],
    [
        "LOAD_FAST",
        "time"
    ],
    [
        "LOAD_ATTR",
        "time.minute"
    ],
    [
        "LOAD_FAST",
        "time"
    ],
    [
        "LOAD_ATTR",
        "time.second"
    ],
    [
        "LOAD_FAST",
        "time"
    ],
    [
        "LOAD_ATTR",
        "time.microsecond"
    ],
    [
        "LOAD_FAST",
        "tzinfo"
    ],
    [
        "LOAD_FAST",
        "time"
    ],
    [
        "LOAD_ATTR",
        "time.fold"
    ],
    [
        "CALL",
        "cls(date.year, date.month, date.day,\n                   time.hour, time.minute, time.second, time.microsecond,\n                   tzinfo, fold=time.fold)"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "date_string"
    ],
    [
        "LOAD_GLOBAL",
        "str"
    ],
    [
        "CALL",
        "isinstance(date_string, str)"
    ],
    [
        "LOAD_GLOBAL",
        "TypeError"
    ],
    [
        "CALL",
        "TypeError('fromisoformat: argument must be str')"
    ],
    [
        "LOAD_GLOBAL",
        "len"
    ],
    [
        "LOAD_FAST",
        "date_string"
    ],
    [
        "CALL",
        "len(date_string)"
    ],
    [
        "COMPARE_OP",
        "len(date_string) < 7"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "LOAD_FAST",
        "date_string"
    ],
    [
        "BUILD_STRING",
        "f'Invalid isoformat string: {date_string!r}'"
    ],
    [
        "CALL",
        "ValueError(f'Invalid isoformat string: {date_string!r}')"
    ],
    [
        "LOAD_GLOBAL",
        "_find_isoformat_datetime_separator"
    ],
    [
        "LOAD_FAST",
        "date_string"
    ],
    [
        "CALL",
        "_find_isoformat_datetime_separator(date_string)"
    ],
    [
        "STORE_FAST",
        "separator_location"
    ],
    [
        "LOAD_FAST",
        "date_string"
    ],
    [
        "LOAD_FAST",
        "separator_location"
    ],
    [
        "BINARY_SLICE",
        "date_string[0:separator_location]"
    ],
    [
        "STORE_FAST",
        "dstr"
    ],
    [
        "LOAD_FAST",
        "date_string"
    ],
    [
        "LOAD_FAST",
        "separator_location"
    ],
    [
        "BINARY_OP",
        "separator_location+1"
    ],
    [
        "BINARY_SLICE",
        "date_string[(separator_location+1):]"
    ],
    [
        "STORE_FAST",
        "tstr"
    ],
    [
        "LOAD_GLOBAL",
        "_parse_isoformat_date"
    ],
    [
        "LOAD_FAST",
        "dstr"
    ],
    [
        "CALL",
        "_parse_isoformat_date(dstr)"
    ],
    [
        "STORE_FAST",
        "date_components"
    ],
    [
        "LOAD_FAST",
        "tstr"
    ],
    [
        "LOAD_GLOBAL",
        "_parse_isoformat_time"
    ],
    [
        "LOAD_FAST",
        "tstr"
    ],
    [
        "CALL",
        "_parse_isoformat_time(tstr)"
    ],
    [
        "STORE_FAST",
        "time_components"
    ],
    [
        "STORE_FAST",
        "time_components"
    ],
    [
        "LOAD_FAST",
        "cls"
    ],
    [
        "LOAD_FAST",
        "date_components"
    ],
    [
        "LOAD_FAST",
        "time_components"
    ],
    [
        "BINARY_OP",
        "date_components + time_components"
    ],
    [
        "CALL_FUNCTION_EX",
        "cls(*(date_components + time_components))"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "LOAD_FAST",
        "date_string"
    ],
    [
        "BUILD_STRING",
        "f'Invalid isoformat string: {date_string!r}'"
    ],
    [
        "CALL",
        "ValueError(\n                f'Invalid isoformat string: {date_string!r}')"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "LOAD_FAST",
        "date_string"
    ],
    [
        "BUILD_STRING",
        "f'Invalid isoformat string: {date_string!r}'"
    ],
    [
        "CALL",
        "ValueError(\n                    f'Invalid isoformat string: {date_string!r}')"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.dst"
    ],
    [
        "CALL",
        "self.dst()"
    ],
    [
        "STORE_FAST",
        "dst"
    ],
    [
        "LOAD_FAST",
        "dst"
    ],
    [
        "STORE_FAST",
        "dst"
    ],
    [
        "LOAD_FAST",
        "dst"
    ],
    [
        "STORE_FAST",
        "dst"
    ],
    [
        "STORE_FAST",
        "dst"
    ],
    [
        "LOAD_GLOBAL",
        "_build_struct_time"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.year"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.month"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.day"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.hour"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.minute"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.second"
    ],
    [
        "LOAD_FAST",
        "dst"
    ],
    [
        "CALL",
        "_build_struct_time(self.year, self.month, self.day,\n                                  self.hour, self.minute, self.second,\n                                  dst)"
    ],
    [
        "LOAD_GLOBAL",
        "datetime"
    ],
    [
        "CALL",
        "datetime(1970, 1, 1)"
    ],
    [
        "STORE_DEREF",
        "epoch"
    ],
    [
        "STORE_FAST",
        "max_fold_seconds"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_DEREF",
        "epoch"
    ],
    [
        "BINARY_OP",
        "self - epoch"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "CALL",
        "timedelta(0, 1)"
    ],
    [
        "BINARY_OP",
        "(self - epoch) // timedelta(0, 1)"
    ],
    [
        "STORE_FAST",
        "t"
    ],
    [
        "STORE_FAST",
        "        def local(u):\n            y, m, d, hh, mm, ss = _time.localtime(u)[:6]\n            return (datetime(y, m, d, hh, mm, ss) - epoch) // timedelta(0, 1)"
    ],
    [
        "LOAD_FAST",
        "local"
    ],
    [
        "LOAD_FAST",
        "t"
    ],
    [
        "CALL",
        "local(t)"
    ],
    [
        "LOAD_FAST",
        "t"
    ],
    [
        "BINARY_OP",
        "local(t) - t"
    ],
    [
        "STORE_FAST",
        "a"
    ],
    [
        "LOAD_FAST",
        "t"
    ],
    [
        "LOAD_FAST",
        "a"
    ],
    [
        "BINARY_OP",
        "t - a"
    ],
    [
        "STORE_FAST",
        "u1"
    ],
    [
        "LOAD_FAST",
        "local"
    ],
    [
        "LOAD_FAST",
        "u1"
    ],
    [
        "CALL",
        "local(u1)"
    ],
    [
        "STORE_FAST",
        "t1"
    ],
    [
        "LOAD_FAST",
        "t1"
    ],
    [
        "LOAD_FAST",
        "t"
    ],
    [
        "COMPARE_OP",
        "t1 == t"
    ],
    [
        "LOAD_FAST",
        "u1"
    ],
    [
        "LOAD_FAST",
        "max_fold_seconds"
    ],
    [
        "UNARY_NEGATIVE",
        "-max_fold_seconds"
    ],
    [
        "LOAD_FAST",
        "max_fold_seconds"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.fold"
    ],
    [
        "BINARY_SUBSCR",
        "(-max_fold_seconds, max_fold_seconds)[self.fold]"
    ],
    [
        "BINARY_OP",
        "u1 + (-max_fold_seconds, max_fold_seconds)[self.fold]"
    ],
    [
        "STORE_FAST",
        "u2"
    ],
    [
        "LOAD_FAST",
        "local"
    ],
    [
        "LOAD_FAST",
        "u2"
    ],
    [
        "CALL",
        "local(u2)"
    ],
    [
        "LOAD_FAST",
        "u2"
    ],
    [
        "BINARY_OP",
        "local(u2) - u2"
    ],
    [
        "STORE_FAST",
        "b"
    ],
    [
        "LOAD_FAST",
        "a"
    ],
    [
        "LOAD_FAST",
        "b"
    ],
    [
        "COMPARE_OP",
        "a == b"
    ],
    [
        "LOAD_FAST",
        "u1"
    ],
    [
        "LOAD_FAST",
        "t1"
    ],
    [
        "LOAD_FAST",
        "u1"
    ],
    [
        "BINARY_OP",
        "t1 - u1"
    ],
    [
        "STORE_FAST",
        "b"
    ],
    [
        "LOAD_FAST",
        "a"
    ],
    [
        "LOAD_FAST",
        "b"
    ],
    [
        "COMPARE_OP",
        "a != b"
    ],
    [
        "LOAD_FAST",
        "t"
    ],
    [
        "LOAD_FAST",
        "b"
    ],
    [
        "BINARY_OP",
        "t - b"
    ],
    [
        "STORE_FAST",
        "u2"
    ],
    [
        "LOAD_FAST",
        "local"
    ],
    [
        "LOAD_FAST",
        "u2"
    ],
    [
        "CALL",
        "local(u2)"
    ],
    [
        "STORE_FAST",
        "t2"
    ],
    [
        "LOAD_FAST",
        "t2"
    ],
    [
        "LOAD_FAST",
        "t"
    ],
    [
        "COMPARE_OP",
        "t2 == t"
    ],
    [
        "LOAD_FAST",
        "u2"
    ],
    [
        "LOAD_FAST",
        "t1"
    ],
    [
        "LOAD_FAST",
        "t"
    ],
    [
        "COMPARE_OP",
        "t1 == t"
    ],
    [
        "LOAD_FAST",
        "u1"
    ],
    [
        "LOAD_GLOBAL",
        "max"
    ],
    [
        "LOAD_GLOBAL",
        "min"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.fold"
    ],
    [
        "BINARY_SUBSCR",
        "(max, min)[self.fold]"
    ],
    [
        "LOAD_FAST",
        "u1"
    ],
    [
        "LOAD_FAST",
        "u2"
    ],
    [
        "CALL",
        "(max, min)[self.fold](u1, u2)"
    ],
    [
        "LOAD_GLOBAL",
        "_time"
    ],
    [
        "LOAD_ATTR",
        "_time.localtime"
    ],
    [
        "LOAD_FAST",
        "u"
    ],
    [
        "CALL",
        "_time.localtime(u)"
    ],
    [
        "BINARY_SLICE",
        "_time.localtime(u)[:6]"
    ],
    [
        "STORE_FAST",
        "y"
    ],
    [
        "STORE_FAST",
        "m"
    ],
    [
        "STORE_FAST",
        "d"
    ],
    [
        "STORE_FAST",
        "hh"
    ],
    [
        "STORE_FAST",
        "mm"
    ],
    [
        "STORE_FAST",
        "ss"
    ],
    [
        "LOAD_GLOBAL",
        "datetime"
    ],
    [
        "LOAD_FAST",
        "y"
    ],
    [
        "LOAD_FAST",
        "m"
    ],
    [
        "LOAD_FAST",
        "d"
    ],
    [
        "LOAD_FAST",
        "hh"
    ],
    [
        "LOAD_FAST",
        "mm"
    ],
    [
        "LOAD_FAST",
        "ss"
    ],
    [
        "CALL",
        "datetime(y, m, d, hh, mm, ss)"
    ],
    [
        "LOAD_DEREF",
        "epoch"
    ],
    [
        "BINARY_OP",
        "datetime(y, m, d, hh, mm, ss) - epoch"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "CALL",
        "timedelta(0, 1)"
    ],
    [
        "BINARY_OP",
        "(datetime(y, m, d, hh, mm, ss) - epoch) // timedelta(0, 1)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._tzinfo"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._mktime"
    ],
    [
        "CALL",
        "self._mktime()"
    ],
    [
        "STORE_FAST",
        "s"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.microsecond"
    ],
    [
        "BINARY_OP",
        "self.microsecond / 1e6"
    ],
    [
        "BINARY_OP",
        "s + self.microsecond / 1e6"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_GLOBAL",
        "_EPOCH"
    ],
    [
        "BINARY_OP",
        "self - _EPOCH"
    ],
    [
        "LOAD_ATTR",
        "(self - _EPOCH).total_seconds"
    ],
    [
        "CALL",
        "(self - _EPOCH).total_seconds()"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.utcoffset"
    ],
    [
        "CALL",
        "self.utcoffset()"
    ],
    [
        "STORE_FAST",
        "offset"
    ],
    [
        "LOAD_FAST",
        "offset"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_FAST",
        "offset"
    ],
    [
        "BINARY_OP",
        "self -= offset"
    ],
    [
        "STORE_FAST",
        "self"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.year"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.month"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.day"
    ],
    [
        "STORE_FAST",
        "d"
    ],
    [
        "STORE_FAST",
        "m"
    ],
    [
        "STORE_FAST",
        "y"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.hour"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.minute"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.second"
    ],
    [
        "STORE_FAST",
        "ss"
    ],
    [
        "STORE_FAST",
        "mm"
    ],
    [
        "STORE_FAST",
        "hh"
    ],
    [
        "LOAD_GLOBAL",
        "_build_struct_time"
    ],
    [
        "LOAD_FAST",
        "y"
    ],
    [
        "LOAD_FAST",
        "m"
    ],
    [
        "LOAD_FAST",
        "d"
    ],
    [
        "LOAD_FAST",
        "hh"
    ],
    [
        "LOAD_FAST",
        "mm"
    ],
    [
        "LOAD_FAST",
        "ss"
    ],
    [
        "CALL",
        "_build_struct_time(y, m, d, hh, mm, ss, 0)"
    ],
    [
        "LOAD_GLOBAL",
        "date"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._year"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._month"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._day"
    ],
    [
        "CALL",
        "date(self._year, self._month, self._day)"
    ],
    [
        "LOAD_GLOBAL",
        "time"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.hour"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.minute"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.second"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.microsecond"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.fold"
    ],
    [
        "CALL",
        "time(self.hour, self.minute, self.second, self.microsecond, fold=self.fold)"
    ],
    [
        "LOAD_GLOBAL",
        "time"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.hour"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.minute"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.second"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.microsecond"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._tzinfo"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.fold"
    ],
    [
        "CALL",
        "time(self.hour, self.minute, self.second, self.microsecond,\n                    self._tzinfo, fold=self.fold)"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.year"
    ],
    [
        "STORE_FAST",
        "year"
    ],
    [
        "LOAD_FAST",
        "month"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.month"
    ],
    [
        "STORE_FAST",
        "month"
    ],
    [
        "LOAD_FAST",
        "day"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.day"
    ],
    [
        "STORE_FAST",
        "day"
    ],
    [
        "LOAD_FAST",
        "hour"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.hour"
    ],
    [
        "STORE_FAST",
        "hour"
    ],
    [
        "LOAD_FAST",
        "minute"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.minute"
    ],
    [
        "STORE_FAST",
        "minute"
    ],
    [
        "LOAD_FAST",
        "second"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.second"
    ],
    [
        "STORE_FAST",
        "second"
    ],
    [
        "LOAD_FAST",
        "microsecond"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.microsecond"
    ],
    [
        "STORE_FAST",
        "microsecond"
    ],
    [
        "LOAD_FAST",
        "tzinfo"
    ],
    [
        "IS_OP",
        "tzinfo is True"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.tzinfo"
    ],
    [
        "STORE_FAST",
        "tzinfo"
    ],
    [
        "LOAD_FAST",
        "fold"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.fold"
    ],
    [
        "STORE_FAST",
        "fold"
    ],
    [
        "LOAD_GLOBAL",
        "type"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "CALL",
        "type(self)"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "LOAD_FAST",
        "month"
    ],
    [
        "LOAD_FAST",
        "day"
    ],
    [
        "LOAD_FAST",
        "hour"
    ],
    [
        "LOAD_FAST",
        "minute"
    ],
    [
        "LOAD_FAST",
        "second"
    ],
    [
        "LOAD_FAST",
        "microsecond"
    ],
    [
        "LOAD_FAST",
        "tzinfo"
    ],
    [
        "LOAD_FAST",
        "fold"
    ],
    [
        "CALL",
        "type(self)(year, month, day, hour, minute, second,\n                          microsecond, tzinfo, fold=fold)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.tzinfo"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._mktime"
    ],
    [
        "CALL",
        "self._mktime()"
    ],
    [
        "STORE_FAST",
        "ts"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_GLOBAL",
        "_EPOCH"
    ],
    [
        "BINARY_OP",
        "self - _EPOCH"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "CALL",
        "timedelta(seconds=1)"
    ],
    [
        "BINARY_OP",
        "(self - _EPOCH) // timedelta(seconds=1)"
    ],
    [
        "STORE_FAST",
        "ts"
    ],
    [
        "LOAD_GLOBAL",
        "_time"
    ],
    [
        "LOAD_ATTR",
        "_time.localtime"
    ],
    [
        "LOAD_FAST",
        "ts"
    ],
    [
        "CALL",
        "_time.localtime(ts)"
    ],
    [
        "STORE_FAST",
        "localtm"
    ],
    [
        "LOAD_GLOBAL",
        "datetime"
    ],
    [
        "LOAD_FAST",
        "localtm"
    ],
    [
        "BINARY_SLICE",
        "localtm[:6]"
    ],
    [
        "CALL_FUNCTION_EX",
        "datetime(*localtm[:6])"
    ],
    [
        "STORE_FAST",
        "local"
    ],
    [
        "LOAD_FAST",
        "localtm"
    ],
    [
        "LOAD_ATTR",
        "localtm.tm_gmtoff"
    ],
    [
        "STORE_FAST",
        "gmtoff"
    ],
    [
        "LOAD_FAST",
        "localtm"
    ],
    [
        "LOAD_ATTR",
        "localtm.tm_zone"
    ],
    [
        "STORE_FAST",
        "zone"
    ],
    [
        "LOAD_GLOBAL",
        "timezone"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "LOAD_FAST",
        "gmtoff"
    ],
    [
        "CALL",
        "timedelta(seconds=gmtoff)"
    ],
    [
        "LOAD_FAST",
        "zone"
    ],
    [
        "CALL",
        "timezone(timedelta(seconds=gmtoff), zone)"
    ],
    [
        "LOAD_FAST",
        "tz"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._local_timezone"
    ],
    [
        "CALL",
        "self._local_timezone()"
    ],
    [
        "STORE_FAST",
        "tz"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "tz"
    ],
    [
        "LOAD_GLOBAL",
        "tzinfo"
    ],
    [
        "CALL",
        "isinstance(tz, tzinfo)"
    ],
    [
        "LOAD_GLOBAL",
        "TypeError"
    ],
    [
        "CALL",
        "TypeError(\"tz argument must be an instance of tzinfo\")"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.tzinfo"
    ],
    [
        "STORE_FAST",
        "mytz"
    ],
    [
        "LOAD_FAST",
        "mytz"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._local_timezone"
    ],
    [
        "CALL",
        "self._local_timezone()"
    ],
    [
        "STORE_FAST",
        "mytz"
    ],
    [
        "LOAD_FAST",
        "mytz"
    ],
    [
        "LOAD_ATTR",
        "mytz.utcoffset"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "CALL",
        "mytz.utcoffset(self)"
    ],
    [
        "STORE_FAST",
        "myoffset"
    ],
    [
        "LOAD_FAST",
        "mytz"
    ],
    [
        "LOAD_ATTR",
        "mytz.utcoffset"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "CALL",
        "mytz.utcoffset(self)"
    ],
    [
        "STORE_FAST",
        "myoffset"
    ],
    [
        "LOAD_FAST",
        "myoffset"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.replace"
    ],
    [
        "CALL",
        "self.replace(tzinfo=None)"
    ],
    [
        "LOAD_ATTR",
        "self.replace(tzinfo=None)._local_timezone"
    ],
    [
        "CALL",
        "self.replace(tzinfo=None)._local_timezone()"
    ],
    [
        "STORE_FAST",
        "mytz"
    ],
    [
        "LOAD_FAST",
        "mytz"
    ],
    [
        "LOAD_ATTR",
        "mytz.utcoffset"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "CALL",
        "mytz.utcoffset(self)"
    ],
    [
        "STORE_FAST",
        "myoffset"
    ],
    [
        "LOAD_FAST",
        "tz"
    ],
    [
        "LOAD_FAST",
        "mytz"
    ],
    [
        "IS_OP",
        "tz is mytz"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_FAST",
        "myoffset"
    ],
    [
        "BINARY_OP",
        "self - myoffset"
    ],
    [
        "LOAD_ATTR",
        "(self - myoffset).replace"
    ],
    [
        "LOAD_FAST",
        "tz"
    ],
    [
        "CALL",
        "(self - myoffset).replace(tzinfo=tz)"
    ],
    [
        "STORE_FAST",
        "utc"
    ],
    [
        "LOAD_FAST",
        "tz"
    ],
    [
        "LOAD_ATTR",
        "tz.fromutc"
    ],
    [
        "LOAD_FAST",
        "utc"
    ],
    [
        "CALL",
        "tz.fromutc(utc)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.toordinal"
    ],
    [
        "CALL",
        "self.toordinal()"
    ],
    [
        "BINARY_OP",
        "self.toordinal() % 7"
    ],
    [
        "STORE_FAST",
        "weekday"
    ],
    [
        "LOAD_GLOBAL",
        "_DAYNAMES"
    ],
    [
        "LOAD_FAST",
        "weekday"
    ],
    [
        "BINARY_SUBSCR",
        "_DAYNAMES[weekday]"
    ],
    [
        "LOAD_GLOBAL",
        "_MONTHNAMES"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._month"
    ],
    [
        "BINARY_SUBSCR",
        "_MONTHNAMES[self._month]"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._day"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._hour"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._minute"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._second"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._year"
    ],
    [
        "BINARY_OP",
        "\"%s %s %2d %02d:%02d:%02d %04d\" % (\n            _DAYNAMES[weekday],\n            _MONTHNAMES[self._month],\n            self._day,\n            self._hour, self._minute, self._second,\n            self._year)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._year"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._month"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._day"
    ],
    [
        "LOAD_FAST",
        "sep"
    ],
    [
        "BINARY_OP",
        "\"%04d-%02d-%02d%c\" % (self._year, self._month, self._day, sep)"
    ],
    [
        "LOAD_GLOBAL",
        "_format_time"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._hour"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._minute"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._second"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._microsecond"
    ],
    [
        "LOAD_FAST",
        "timespec"
    ],
    [
        "CALL",
        "_format_time(self._hour, self._minute, self._second,\n                          self._microsecond, timespec)"
    ],
    [
        "BINARY_OP",
        "\"%04d-%02d-%02d%c\" % (self._year, self._month, self._day, sep) +\n             _format_time(self._hour, self._minute, self._second,\n                          self._microsecond, timespec)"
    ],
    [
        "STORE_FAST",
        "s"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.utcoffset"
    ],
    [
        "CALL",
        "self.utcoffset()"
    ],
    [
        "STORE_FAST",
        "off"
    ],
    [
        "LOAD_GLOBAL",
        "_format_offset"
    ],
    [
        "LOAD_FAST",
        "off"
    ],
    [
        "CALL",
        "_format_offset(off)"
    ],
    [
        "STORE_FAST",
        "tz"
    ],
    [
        "LOAD_FAST",
        "tz"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "LOAD_FAST",
        "tz"
    ],
    [
        "BINARY_OP",
        "s += tz"
    ],
    [
        "STORE_FAST",
        "s"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._year"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._month"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._day"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._hour"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._minute"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._second"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._microsecond"
    ],
    [
        "STORE_FAST",
        "L"
    ],
    [
        "LOAD_FAST",
        "L"
    ],
    [
        "BINARY_SUBSCR",
        "L[-1]"
    ],
    [
        "COMPARE_OP",
        "L[-1] == 0"
    ],
    [
        "LOAD_FAST",
        "L"
    ],
    [
        "DELETE_SUBSCR",
        "L[-1]"
    ],
    [
        "LOAD_FAST",
        "L"
    ],
    [
        "BINARY_SUBSCR",
        "L[-1]"
    ],
    [
        "COMPARE_OP",
        "L[-1] == 0"
    ],
    [
        "LOAD_FAST",
        "L"
    ],
    [
        "DELETE_SUBSCR",
        "L[-1]"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.__class__"
    ],
    [
        "LOAD_ATTR",
        "self.__class__.__module__"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.__class__"
    ],
    [
        "LOAD_ATTR",
        "self.__class__.__qualname__"
    ],
    [
        "LOAD_ATTR",
        "\", \".join"
    ],
    [
        "LOAD_GLOBAL",
        "map"
    ],
    [
        "LOAD_GLOBAL",
        "str"
    ],
    [
        "LOAD_FAST",
        "L"
    ],
    [
        "CALL",
        "map(str, L)"
    ],
    [
        "CALL",
        "\", \".join(map(str, L))"
    ],
    [
        "BUILD_STRING",
        "\"%s.%s(%s)\" % (self.__class__.__module__,\n                           self.__class__.__qualname__,\n                           \", \".join(map(str, L)))"
    ],
    [
        "STORE_FAST",
        "s"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._tzinfo"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "BINARY_SLICE",
        "s[-1:]"
    ],
    [
        "COMPARE_OP",
        "s[-1:] == \")\""
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "BINARY_SLICE",
        "s[:-1]"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._tzinfo"
    ],
    [
        "BINARY_OP",
        "\", tzinfo=%r\" % self._tzinfo"
    ],
    [
        "BINARY_OP",
        "s[:-1] + \", tzinfo=%r\" % self._tzinfo"
    ],
    [
        "BINARY_OP",
        "s[:-1] + \", tzinfo=%r\" % self._tzinfo + \")\""
    ],
    [
        "STORE_FAST",
        "s"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._fold"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "BINARY_SLICE",
        "s[-1:]"
    ],
    [
        "COMPARE_OP",
        "s[-1:] == \")\""
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "BINARY_SLICE",
        "s[:-1]"
    ],
    [
        "BINARY_OP",
        "s[:-1] + \", fold=1)\""
    ],
    [
        "STORE_FAST",
        "s"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.isoformat"
    ],
    [
        "CALL",
        "self.isoformat(sep=' ')"
    ],
    [
        "STORE_FAST",
        "import _strptime"
    ],
    [
        "LOAD_FAST",
        "_strptime"
    ],
    [
        "LOAD_ATTR",
        "_strptime._strptime_datetime"
    ],
    [
        "LOAD_FAST",
        "cls"
    ],
    [
        "LOAD_FAST",
        "date_string"
    ],
    [
        "LOAD_FAST",
        "format"
    ],
    [
        "CALL",
        "_strptime._strptime_datetime(cls, date_string, format)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._tzinfo"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._tzinfo"
    ],
    [
        "LOAD_ATTR",
        "self._tzinfo.utcoffset"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "CALL",
        "self._tzinfo.utcoffset(self)"
    ],
    [
        "STORE_FAST",
        "offset"
    ],
    [
        "LOAD_GLOBAL",
        "_check_utc_offset"
    ],
    [
        "LOAD_FAST",
        "offset"
    ],
    [
        "CALL",
        "_check_utc_offset(\"utcoffset\", offset)"
    ],
    [
        "LOAD_FAST",
        "offset"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._tzinfo"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._tzinfo"
    ],
    [
        "LOAD_ATTR",
        "self._tzinfo.tzname"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "CALL",
        "self._tzinfo.tzname(self)"
    ],
    [
        "STORE_FAST",
        "name"
    ],
    [
        "LOAD_GLOBAL",
        "_check_tzname"
    ],
    [
        "LOAD_FAST",
        "name"
    ],
    [
        "CALL",
        "_check_tzname(name)"
    ],
    [
        "LOAD_FAST",
        "name"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._tzinfo"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._tzinfo"
    ],
    [
        "LOAD_ATTR",
        "self._tzinfo.dst"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "CALL",
        "self._tzinfo.dst(self)"
    ],
    [
        "STORE_FAST",
        "offset"
    ],
    [
        "LOAD_GLOBAL",
        "_check_utc_offset"
    ],
    [
        "LOAD_FAST",
        "offset"
    ],
    [
        "CALL",
        "_check_utc_offset(\"dst\", offset)"
    ],
    [
        "LOAD_FAST",
        "offset"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "datetime"
    ],
    [
        "CALL",
        "isinstance(other, datetime)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._cmp"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "CALL",
        "self._cmp(other, allow_mixed=True)"
    ],
    [
        "COMPARE_OP",
        "self._cmp(other, allow_mixed=True) == 0"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "date"
    ],
    [
        "CALL",
        "isinstance(other, date)"
    ],
    [
        "LOAD_GLOBAL",
        "NotImplemented"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "datetime"
    ],
    [
        "CALL",
        "isinstance(other, datetime)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._cmp"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "CALL",
        "self._cmp(other)"
    ],
    [
        "COMPARE_OP",
        "self._cmp(other) <= 0"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "date"
    ],
    [
        "CALL",
        "isinstance(other, date)"
    ],
    [
        "LOAD_GLOBAL",
        "NotImplemented"
    ],
    [
        "LOAD_GLOBAL",
        "_cmperror"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "CALL",
        "_cmperror(self, other)"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "datetime"
    ],
    [
        "CALL",
        "isinstance(other, datetime)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._cmp"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "CALL",
        "self._cmp(other)"
    ],
    [
        "COMPARE_OP",
        "self._cmp(other) < 0"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "date"
    ],
    [
        "CALL",
        "isinstance(other, date)"
    ],
    [
        "LOAD_GLOBAL",
        "NotImplemented"
    ],
    [
        "LOAD_GLOBAL",
        "_cmperror"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "CALL",
        "_cmperror(self, other)"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "datetime"
    ],
    [
        "CALL",
        "isinstance(other, datetime)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._cmp"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "CALL",
        "self._cmp(other)"
    ],
    [
        "COMPARE_OP",
        "self._cmp(other) >= 0"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "date"
    ],
    [
        "CALL",
        "isinstance(other, date)"
    ],
    [
        "LOAD_GLOBAL",
        "NotImplemented"
    ],
    [
        "LOAD_GLOBAL",
        "_cmperror"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "CALL",
        "_cmperror(self, other)"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "datetime"
    ],
    [
        "CALL",
        "isinstance(other, datetime)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._cmp"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "CALL",
        "self._cmp(other)"
    ],
    [
        "COMPARE_OP",
        "self._cmp(other) > 0"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "date"
    ],
    [
        "CALL",
        "isinstance(other, date)"
    ],
    [
        "LOAD_GLOBAL",
        "NotImplemented"
    ],
    [
        "LOAD_GLOBAL",
        "_cmperror"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "CALL",
        "_cmperror(self, other)"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "datetime"
    ],
    [
        "CALL",
        "isinstance(other, datetime)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._tzinfo"
    ],
    [
        "STORE_FAST",
        "mytz"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other._tzinfo"
    ],
    [
        "STORE_FAST",
        "ottz"
    ],
    [
        "STORE_FAST",
        "myoff"
    ],
    [
        "STORE_FAST",
        "otoff"
    ],
    [
        "LOAD_FAST",
        "mytz"
    ],
    [
        "LOAD_FAST",
        "ottz"
    ],
    [
        "IS_OP",
        "mytz is ottz"
    ],
    [
        "STORE_FAST",
        "base_compare"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.utcoffset"
    ],
    [
        "CALL",
        "self.utcoffset()"
    ],
    [
        "STORE_FAST",
        "myoff"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other.utcoffset"
    ],
    [
        "CALL",
        "other.utcoffset()"
    ],
    [
        "STORE_FAST",
        "otoff"
    ],
    [
        "LOAD_FAST",
        "allow_mixed"
    ],
    [
        "LOAD_FAST",
        "myoff"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.replace"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.fold"
    ],
    [
        "UNARY_NOT",
        "not self.fold"
    ],
    [
        "CALL",
        "self.replace(fold=not self.fold)"
    ],
    [
        "LOAD_ATTR",
        "self.replace(fold=not self.fold).utcoffset"
    ],
    [
        "CALL",
        "self.replace(fold=not self.fold).utcoffset()"
    ],
    [
        "COMPARE_OP",
        "myoff != self.replace(fold=not self.fold).utcoffset()"
    ],
    [
        "LOAD_FAST",
        "otoff"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other.replace"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other.fold"
    ],
    [
        "UNARY_NOT",
        "not other.fold"
    ],
    [
        "CALL",
        "other.replace(fold=not other.fold)"
    ],
    [
        "LOAD_ATTR",
        "other.replace(fold=not other.fold).utcoffset"
    ],
    [
        "CALL",
        "other.replace(fold=not other.fold).utcoffset()"
    ],
    [
        "COMPARE_OP",
        "otoff != other.replace(fold=not other.fold).utcoffset()"
    ],
    [
        "LOAD_FAST",
        "myoff"
    ],
    [
        "LOAD_FAST",
        "otoff"
    ],
    [
        "COMPARE_OP",
        "myoff == otoff"
    ],
    [
        "STORE_FAST",
        "base_compare"
    ],
    [
        "LOAD_FAST",
        "base_compare"
    ],
    [
        "LOAD_GLOBAL",
        "_cmp"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._year"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._month"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._day"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._hour"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._minute"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._second"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._microsecond"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other._year"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other._month"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other._day"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other._hour"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other._minute"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other._second"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other._microsecond"
    ],
    [
        "CALL",
        "_cmp((self._year, self._month, self._day,\n                         self._hour, self._minute, self._second,\n                         self._microsecond),\n                        (other._year, other._month, other._day,\n                         other._hour, other._minute, other._second,\n                         other._microsecond))"
    ],
    [
        "LOAD_FAST",
        "myoff"
    ],
    [
        "LOAD_FAST",
        "otoff"
    ],
    [
        "LOAD_FAST",
        "allow_mixed"
    ],
    [
        "LOAD_GLOBAL",
        "TypeError"
    ],
    [
        "CALL",
        "TypeError(\"cannot compare naive and aware datetimes\")"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "BINARY_OP",
        "self - other"
    ],
    [
        "STORE_FAST",
        "diff"
    ],
    [
        "LOAD_FAST",
        "diff"
    ],
    [
        "LOAD_ATTR",
        "diff.days"
    ],
    [
        "COMPARE_OP",
        "diff.days < 0"
    ],
    [
        "LOAD_FAST",
        "diff"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "CALL",
        "isinstance(other, timedelta)"
    ],
    [
        "LOAD_GLOBAL",
        "NotImplemented"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.toordinal"
    ],
    [
        "CALL",
        "self.toordinal()"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._hour"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._minute"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._second"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._microsecond"
    ],
    [
        "CALL",
        "timedelta(self.toordinal(),\n                          hours=self._hour,\n                          minutes=self._minute,\n                          seconds=self._second,\n                          microseconds=self._microsecond)"
    ],
    [
        "STORE_FAST",
        "delta"
    ],
    [
        "LOAD_FAST",
        "delta"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "BINARY_OP",
        "delta += other"
    ],
    [
        "STORE_FAST",
        "delta"
    ],
    [
        "LOAD_GLOBAL",
        "divmod"
    ],
    [
        "LOAD_FAST",
        "delta"
    ],
    [
        "LOAD_ATTR",
        "delta.seconds"
    ],
    [
        "CALL",
        "divmod(delta.seconds, 3600)"
    ],
    [
        "STORE_FAST",
        "hour"
    ],
    [
        "STORE_FAST",
        "rem"
    ],
    [
        "LOAD_GLOBAL",
        "divmod"
    ],
    [
        "LOAD_FAST",
        "rem"
    ],
    [
        "CALL",
        "divmod(rem, 60)"
    ],
    [
        "STORE_FAST",
        "minute"
    ],
    [
        "STORE_FAST",
        "second"
    ],
    [
        "LOAD_FAST",
        "delta"
    ],
    [
        "LOAD_ATTR",
        "delta.days"
    ],
    [
        "COMPARE_OP",
        "0 < delta.days <= _MAXORDINAL"
    ],
    [
        "LOAD_GLOBAL",
        "_MAXORDINAL"
    ],
    [
        "COMPARE_OP",
        "0 < delta.days <= _MAXORDINAL"
    ],
    [
        "LOAD_GLOBAL",
        "OverflowError"
    ],
    [
        "CALL",
        "OverflowError(\"result out of range\")"
    ],
    [
        "LOAD_GLOBAL",
        "type"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "CALL",
        "type(self)"
    ],
    [
        "LOAD_ATTR",
        "type(self).combine"
    ],
    [
        "LOAD_GLOBAL",
        "date"
    ],
    [
        "LOAD_ATTR",
        "date.fromordinal"
    ],
    [
        "LOAD_FAST",
        "delta"
    ],
    [
        "LOAD_ATTR",
        "delta.days"
    ],
    [
        "CALL",
        "date.fromordinal(delta.days)"
    ],
    [
        "LOAD_GLOBAL",
        "time"
    ],
    [
        "LOAD_FAST",
        "hour"
    ],
    [
        "LOAD_FAST",
        "minute"
    ],
    [
        "LOAD_FAST",
        "second"
    ],
    [
        "LOAD_FAST",
        "delta"
    ],
    [
        "LOAD_ATTR",
        "delta.microseconds"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._tzinfo"
    ],
    [
        "CALL",
        "time(hour, minute, second,\n                                           delta.microseconds,\n                                           tzinfo=self._tzinfo)"
    ],
    [
        "CALL",
        "type(self).combine(date.fromordinal(delta.days),\n                                      time(hour, minute, second,\n                                           delta.microseconds,\n                                           tzinfo=self._tzinfo))"
    ],
    [
        "LOAD_GLOBAL",
        "OverflowError"
    ],
    [
        "CALL",
        "OverflowError(\"result out of range\")"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "datetime"
    ],
    [
        "CALL",
        "isinstance(other, datetime)"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "CALL",
        "isinstance(other, timedelta)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "UNARY_NEGATIVE",
        "-other"
    ],
    [
        "BINARY_OP",
        "self + -other"
    ],
    [
        "LOAD_GLOBAL",
        "NotImplemented"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.toordinal"
    ],
    [
        "CALL",
        "self.toordinal()"
    ],
    [
        "STORE_FAST",
        "days1"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other.toordinal"
    ],
    [
        "CALL",
        "other.toordinal()"
    ],
    [
        "STORE_FAST",
        "days2"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._second"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._minute"
    ],
    [
        "BINARY_OP",
        "self._minute * 60"
    ],
    [
        "BINARY_OP",
        "self._second + self._minute * 60"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._hour"
    ],
    [
        "BINARY_OP",
        "self._hour * 3600"
    ],
    [
        "BINARY_OP",
        "self._second + self._minute * 60 + self._hour * 3600"
    ],
    [
        "STORE_FAST",
        "secs1"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other._second"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other._minute"
    ],
    [
        "BINARY_OP",
        "other._minute * 60"
    ],
    [
        "BINARY_OP",
        "other._second + other._minute * 60"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other._hour"
    ],
    [
        "BINARY_OP",
        "other._hour * 3600"
    ],
    [
        "BINARY_OP",
        "other._second + other._minute * 60 + other._hour * 3600"
    ],
    [
        "STORE_FAST",
        "secs2"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "LOAD_FAST",
        "days1"
    ],
    [
        "LOAD_FAST",
        "days2"
    ],
    [
        "BINARY_OP",
        "days1 - days2"
    ],
    [
        "LOAD_FAST",
        "secs1"
    ],
    [
        "LOAD_FAST",
        "secs2"
    ],
    [
        "BINARY_OP",
        "secs1 - secs2"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._microsecond"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other._microsecond"
    ],
    [
        "BINARY_OP",
        "self._microsecond - other._microsecond"
    ],
    [
        "CALL",
        "timedelta(days1 - days2,\n                         secs1 - secs2,\n                         self._microsecond - other._microsecond)"
    ],
    [
        "STORE_FAST",
        "base"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._tzinfo"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other._tzinfo"
    ],
    [
        "IS_OP",
        "self._tzinfo is other._tzinfo"
    ],
    [
        "LOAD_FAST",
        "base"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.utcoffset"
    ],
    [
        "CALL",
        "self.utcoffset()"
    ],
    [
        "STORE_FAST",
        "myoff"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other.utcoffset"
    ],
    [
        "CALL",
        "other.utcoffset()"
    ],
    [
        "STORE_FAST",
        "otoff"
    ],
    [
        "LOAD_FAST",
        "myoff"
    ],
    [
        "LOAD_FAST",
        "otoff"
    ],
    [
        "COMPARE_OP",
        "myoff == otoff"
    ],
    [
        "LOAD_FAST",
        "base"
    ],
    [
        "LOAD_FAST",
        "myoff"
    ],
    [
        "LOAD_FAST",
        "otoff"
    ],
    [
        "LOAD_GLOBAL",
        "TypeError"
    ],
    [
        "CALL",
        "TypeError(\"cannot mix naive and timezone-aware time\")"
    ],
    [
        "LOAD_FAST",
        "base"
    ],
    [
        "LOAD_FAST",
        "otoff"
    ],
    [
        "BINARY_OP",
        "base + otoff"
    ],
    [
        "LOAD_FAST",
        "myoff"
    ],
    [
        "BINARY_OP",
        "base + otoff - myoff"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._hashcode"
    ],
    [
        "COMPARE_OP",
        "self._hashcode == -1"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.fold"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.replace"
    ],
    [
        "CALL",
        "self.replace(fold=0)"
    ],
    [
        "STORE_FAST",
        "t"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_FAST",
        "t"
    ],
    [
        "LOAD_FAST",
        "t"
    ],
    [
        "LOAD_ATTR",
        "t.utcoffset"
    ],
    [
        "CALL",
        "t.utcoffset()"
    ],
    [
        "STORE_FAST",
        "tzoff"
    ],
    [
        "LOAD_FAST",
        "tzoff"
    ],
    [
        "LOAD_GLOBAL",
        "hash"
    ],
    [
        "LOAD_FAST",
        "t"
    ],
    [
        "LOAD_ATTR",
        "t._getstate"
    ],
    [
        "CALL",
        "t._getstate()"
    ],
    [
        "BINARY_SUBSCR",
        "t._getstate()[0]"
    ],
    [
        "CALL",
        "hash(t._getstate()[0])"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._hashcode"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._hashcode"
    ],
    [
        "LOAD_GLOBAL",
        "_ymd2ord"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.year"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.month"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.day"
    ],
    [
        "CALL",
        "_ymd2ord(self.year, self.month, self.day)"
    ],
    [
        "STORE_FAST",
        "days"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.hour"
    ],
    [
        "BINARY_OP",
        "self.hour * 3600"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.minute"
    ],
    [
        "BINARY_OP",
        "self.minute * 60"
    ],
    [
        "BINARY_OP",
        "self.hour * 3600 + self.minute * 60"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.second"
    ],
    [
        "BINARY_OP",
        "self.hour * 3600 + self.minute * 60 + self.second"
    ],
    [
        "STORE_FAST",
        "seconds"
    ],
    [
        "LOAD_GLOBAL",
        "hash"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "LOAD_FAST",
        "days"
    ],
    [
        "LOAD_FAST",
        "seconds"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.microsecond"
    ],
    [
        "CALL",
        "timedelta(days, seconds, self.microsecond)"
    ],
    [
        "LOAD_FAST",
        "tzoff"
    ],
    [
        "BINARY_OP",
        "timedelta(days, seconds, self.microsecond) - tzoff"
    ],
    [
        "CALL",
        "hash(timedelta(days, seconds, self.microsecond) - tzoff)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._hashcode"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._hashcode"
    ],
    [
        "LOAD_GLOBAL",
        "divmod"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._year"
    ],
    [
        "CALL",
        "divmod(self._year, 256)"
    ],
    [
        "STORE_FAST",
        "yhi"
    ],
    [
        "STORE_FAST",
        "ylo"
    ],
    [
        "LOAD_GLOBAL",
        "divmod"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._microsecond"
    ],
    [
        "CALL",
        "divmod(self._microsecond, 256)"
    ],
    [
        "STORE_FAST",
        "us2"
    ],
    [
        "STORE_FAST",
        "us3"
    ],
    [
        "LOAD_GLOBAL",
        "divmod"
    ],
    [
        "LOAD_FAST",
        "us2"
    ],
    [
        "CALL",
        "divmod(us2, 256)"
    ],
    [
        "STORE_FAST",
        "us1"
    ],
    [
        "STORE_FAST",
        "us2"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._month"
    ],
    [
        "STORE_FAST",
        "m"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._fold"
    ],
    [
        "LOAD_FAST",
        "protocol"
    ],
    [
        "COMPARE_OP",
        "protocol > 3"
    ],
    [
        "LOAD_FAST",
        "m"
    ],
    [
        "BINARY_OP",
        "m += 128"
    ],
    [
        "STORE_FAST",
        "m"
    ],
    [
        "LOAD_GLOBAL",
        "bytes"
    ],
    [
        "LOAD_FAST",
        "yhi"
    ],
    [
        "LOAD_FAST",
        "ylo"
    ],
    [
        "LOAD_FAST",
        "m"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._day"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._hour"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._minute"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._second"
    ],
    [
        "LOAD_FAST",
        "us1"
    ],
    [
        "LOAD_FAST",
        "us2"
    ],
    [
        "LOAD_FAST",
        "us3"
    ],
    [
        "CALL",
        "bytes([yhi, ylo, m, self._day,\n                           self._hour, self._minute, self._second,\n                           us1, us2, us3])"
    ],
    [
        "STORE_FAST",
        "basestate"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._tzinfo"
    ],
    [
        "LOAD_FAST",
        "basestate"
    ],
    [
        "LOAD_FAST",
        "basestate"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._tzinfo"
    ],
    [
        "LOAD_FAST",
        "tzinfo"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "tzinfo"
    ],
    [
        "LOAD_GLOBAL",
        "_tzinfo_class"
    ],
    [
        "CALL",
        "isinstance(tzinfo, _tzinfo_class)"
    ],
    [
        "LOAD_GLOBAL",
        "TypeError"
    ],
    [
        "CALL",
        "TypeError(\"bad tzinfo state arg\")"
    ],
    [
        "LOAD_FAST",
        "string"
    ],
    [
        "STORE_FAST",
        "yhi"
    ],
    [
        "STORE_FAST",
        "ylo"
    ],
    [
        "STORE_FAST",
        "m"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._day"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._hour"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._minute"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._second"
    ],
    [
        "STORE_FAST",
        "us1"
    ],
    [
        "STORE_FAST",
        "us2"
    ],
    [
        "STORE_FAST",
        "us3"
    ],
    [
        "LOAD_FAST",
        "m"
    ],
    [
        "COMPARE_OP",
        "m > 127"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._fold"
    ],
    [
        "LOAD_FAST",
        "m"
    ],
    [
        "BINARY_OP",
        "m - 128"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._month"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._fold"
    ],
    [
        "LOAD_FAST",
        "m"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._month"
    ],
    [
        "LOAD_FAST",
        "yhi"
    ],
    [
        "BINARY_OP",
        "yhi * 256"
    ],
    [
        "LOAD_FAST",
        "ylo"
    ],
    [
        "BINARY_OP",
        "yhi * 256 + ylo"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._year"
    ],
    [
        "LOAD_FAST",
        "us1"
    ],
    [
        "BINARY_OP",
        "us1 << 8"
    ],
    [
        "LOAD_FAST",
        "us2"
    ],
    [
        "BINARY_OP",
        "(us1 << 8) | us2"
    ],
    [
        "BINARY_OP",
        "((us1 << 8) | us2) << 8"
    ],
    [
        "LOAD_FAST",
        "us3"
    ],
    [
        "BINARY_OP",
        "(((us1 << 8) | us2) << 8) | us3"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._microsecond"
    ],
    [
        "LOAD_FAST",
        "tzinfo"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._tzinfo"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.__class__"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._getstate"
    ],
    [
        "LOAD_FAST",
        "protocol"
    ],
    [
        "CALL",
        "self._getstate(protocol)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.__reduce_ex__"
    ],
    [
        "CALL",
        "self.__reduce_ex__(2)"
    ],
    [
        "STORE_FAST",
        "THURSDAY"
    ],
    [
        "LOAD_GLOBAL",
        "_ymd2ord"
    ],
    [
        "LOAD_FAST",
        "year"
    ],
    [
        "CALL",
        "_ymd2ord(year, 1, 1)"
    ],
    [
        "STORE_FAST",
        "firstday"
    ],
    [
        "LOAD_FAST",
        "firstday"
    ],
    [
        "BINARY_OP",
        "firstday + 6"
    ],
    [
        "BINARY_OP",
        "(firstday + 6) % 7"
    ],
    [
        "STORE_FAST",
        "firstweekday"
    ],
    [
        "LOAD_FAST",
        "firstday"
    ],
    [
        "LOAD_FAST",
        "firstweekday"
    ],
    [
        "BINARY_OP",
        "firstday - firstweekday"
    ],
    [
        "STORE_FAST",
        "week1monday"
    ],
    [
        "LOAD_FAST",
        "firstweekday"
    ],
    [
        "LOAD_FAST",
        "THURSDAY"
    ],
    [
        "COMPARE_OP",
        "firstweekday > THURSDAY"
    ],
    [
        "LOAD_FAST",
        "week1monday"
    ],
    [
        "BINARY_OP",
        "week1monday += 7"
    ],
    [
        "STORE_FAST",
        "week1monday"
    ],
    [
        "LOAD_FAST",
        "week1monday"
    ],
    [
        "STORE_NAME",
        "__slots__"
    ],
    [
        "LOAD_NAME",
        "object"
    ],
    [
        "CALL",
        "object()"
    ],
    [
        "STORE_NAME",
        "_Omitted"
    ],
    [
        "LOAD_NAME",
        "_Omitted"
    ],
    [
        "STORE_NAME",
        "    def __new__(cls, offset, name=_Omitted):\n        if not isinstance(offset, timedelta):\n            raise TypeError(\"offset must be a timedelta\")\n        if name is cls._Omitted:\n            if not offset:\n                return cls.utc\n            name = None\n        elif not isinstance(name, str):\n            raise TypeError(\"name must be a string\")\n        if not cls._minoffset <= offset <= cls._maxoffset:\n            raise ValueError(\"offset must be a timedelta \"\n                             \"strictly between -timedelta(hours=24) and \"\n                             \"timedelta(hours=24).\")\n        return cls._create(offset, name)"
    ],
    [
        "LOAD_NAME",
        "classmethod"
    ],
    [
        "CALL",
        "classmethod"
    ],
    [
        "STORE_NAME",
        "    @classmethod\n    def _create(cls, offset, name=None):\n        self = tzinfo.__new__(cls)\n        self._offset = offset\n        self._name = name\n        return self"
    ],
    [
        "STORE_NAME",
        "    def __getinitargs__(self):\n        \"\"\"pickle support\"\"\"\n        if self._name is None:\n            return (self._offset,)\n        return (self._offset, self._name)"
    ],
    [
        "STORE_NAME",
        "    def __eq__(self, other):\n        if isinstance(other, timezone):\n            return self._offset == other._offset\n        return NotImplemented"
    ],
    [
        "STORE_NAME",
        "    def __hash__(self):\n        return hash(self._offset)"
    ],
    [
        "STORE_NAME",
        "    def __repr__(self):\n        \"\"\"Convert to formal string, for repr().\n\n        >>> tz = timezone.utc\n        >>> repr(tz)\n        'datetime.timezone.utc'\n        >>> tz = timezone(timedelta(hours=-5), 'EST')\n        >>> repr(tz)\n        \"datetime.timezone(datetime.timedelta(-1, 68400), 'EST')\"\n        \"\"\"\n        if self is self.utc:\n            return 'datetime.timezone.utc'\n        if self._name is None:\n            return \"%s.%s(%r)\" % (self.__class__.__module__,\n                                  self.__class__.__qualname__,\n                                  self._offset)\n        return \"%s.%s(%r, %r)\" % (self.__class__.__module__,\n                                  self.__class__.__qualname__,\n                                  self._offset, self._name)"
    ],
    [
        "STORE_NAME",
        "    def __str__(self):\n        return self.tzname(None)"
    ],
    [
        "STORE_NAME",
        "    def utcoffset(self, dt):\n        if isinstance(dt, datetime) or dt is None:\n            return self._offset\n        raise TypeError(\"utcoffset() argument must be a datetime instance\"\n                        \" or None\")"
    ],
    [
        "STORE_NAME",
        "    def tzname(self, dt):\n        if isinstance(dt, datetime) or dt is None:\n            if self._name is None:\n                return self._name_from_offset(self._offset)\n            return self._name\n        raise TypeError(\"tzname() argument must be a datetime instance\"\n                        \" or None\")"
    ],
    [
        "STORE_NAME",
        "    def dst(self, dt):\n        if isinstance(dt, datetime) or dt is None:\n            return None\n        raise TypeError(\"dst() argument must be a datetime instance\"\n                        \" or None\")"
    ],
    [
        "STORE_NAME",
        "    def fromutc(self, dt):\n        if isinstance(dt, datetime):\n            if dt.tzinfo is not self:\n                raise ValueError(\"fromutc: dt.tzinfo \"\n                                 \"is not self\")\n            return dt + self._offset\n        raise TypeError(\"fromutc() argument must be a datetime instance\"\n                        \" or None\")"
    ],
    [
        "LOAD_NAME",
        "timedelta"
    ],
    [
        "CALL",
        "timedelta(hours=24, microseconds=-1)"
    ],
    [
        "STORE_NAME",
        "_maxoffset"
    ],
    [
        "LOAD_NAME",
        "_maxoffset"
    ],
    [
        "UNARY_NEGATIVE",
        "-_maxoffset"
    ],
    [
        "STORE_NAME",
        "_minoffset"
    ],
    [
        "LOAD_NAME",
        "staticmethod"
    ],
    [
        "CALL",
        "staticmethod"
    ],
    [
        "STORE_NAME",
        "    @staticmethod\n    def _name_from_offset(delta):\n        if not delta:\n            return 'UTC'\n        if delta < timedelta(0):\n            sign = '-'\n            delta = -delta\n        else:\n            sign = '+'\n        hours, rest = divmod(delta, timedelta(hours=1))\n        minutes, rest = divmod(rest, timedelta(minutes=1))\n        seconds = rest.seconds\n        microseconds = rest.microseconds\n        if microseconds:\n            return (f'UTC{sign}{hours:02d}:{minutes:02d}:{seconds:02d}'\n                    f'.{microseconds:06d}')\n        if seconds:\n            return f'UTC{sign}{hours:02d}:{minutes:02d}:{seconds:02d}'\n        return f'UTC{sign}{hours:02d}:{minutes:02d}'"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "offset"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "CALL",
        "isinstance(offset, timedelta)"
    ],
    [
        "LOAD_GLOBAL",
        "TypeError"
    ],
    [
        "CALL",
        "TypeError(\"offset must be a timedelta\")"
    ],
    [
        "LOAD_FAST",
        "name"
    ],
    [
        "LOAD_FAST",
        "cls"
    ],
    [
        "LOAD_ATTR",
        "cls._Omitted"
    ],
    [
        "IS_OP",
        "name is cls._Omitted"
    ],
    [
        "LOAD_FAST",
        "offset"
    ],
    [
        "LOAD_FAST",
        "cls"
    ],
    [
        "LOAD_ATTR",
        "cls.utc"
    ],
    [
        "STORE_FAST",
        "name"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "name"
    ],
    [
        "LOAD_GLOBAL",
        "str"
    ],
    [
        "CALL",
        "isinstance(name, str)"
    ],
    [
        "LOAD_GLOBAL",
        "TypeError"
    ],
    [
        "CALL",
        "TypeError(\"name must be a string\")"
    ],
    [
        "LOAD_FAST",
        "cls"
    ],
    [
        "LOAD_ATTR",
        "cls._minoffset"
    ],
    [
        "LOAD_FAST",
        "offset"
    ],
    [
        "COMPARE_OP",
        "cls._minoffset <= offset <= cls._maxoffset"
    ],
    [
        "LOAD_FAST",
        "cls"
    ],
    [
        "LOAD_ATTR",
        "cls._maxoffset"
    ],
    [
        "COMPARE_OP",
        "cls._minoffset <= offset <= cls._maxoffset"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "CALL",
        "ValueError(\"offset must be a timedelta \"\n                             \"strictly between -timedelta(hours=24) and \"\n                             \"timedelta(hours=24).\")"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "CALL",
        "ValueError(\"offset must be a timedelta \"\n                             \"strictly between -timedelta(hours=24) and \"\n                             \"timedelta(hours=24).\")"
    ],
    [
        "LOAD_FAST",
        "cls"
    ],
    [
        "LOAD_ATTR",
        "cls._create"
    ],
    [
        "LOAD_FAST",
        "offset"
    ],
    [
        "LOAD_FAST",
        "name"
    ],
    [
        "CALL",
        "cls._create(offset, name)"
    ],
    [
        "LOAD_GLOBAL",
        "tzinfo"
    ],
    [
        "LOAD_ATTR",
        "tzinfo.__new__"
    ],
    [
        "LOAD_FAST",
        "cls"
    ],
    [
        "CALL",
        "tzinfo.__new__(cls)"
    ],
    [
        "STORE_FAST",
        "self"
    ],
    [
        "LOAD_FAST",
        "offset"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._offset"
    ],
    [
        "LOAD_FAST",
        "name"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._name"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._name"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._offset"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._offset"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._name"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_GLOBAL",
        "timezone"
    ],
    [
        "CALL",
        "isinstance(other, timezone)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._offset"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "LOAD_ATTR",
        "other._offset"
    ],
    [
        "COMPARE_OP",
        "self._offset == other._offset"
    ],
    [
        "LOAD_GLOBAL",
        "NotImplemented"
    ],
    [
        "LOAD_GLOBAL",
        "hash"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._offset"
    ],
    [
        "CALL",
        "hash(self._offset)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.utc"
    ],
    [
        "IS_OP",
        "self is self.utc"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._name"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.__class__"
    ],
    [
        "LOAD_ATTR",
        "self.__class__.__module__"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.__class__"
    ],
    [
        "LOAD_ATTR",
        "self.__class__.__qualname__"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._offset"
    ],
    [
        "BUILD_STRING",
        "\"%s.%s(%r)\" % (self.__class__.__module__,\n                                  self.__class__.__qualname__,\n                                  self._offset)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.__class__"
    ],
    [
        "LOAD_ATTR",
        "self.__class__.__module__"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.__class__"
    ],
    [
        "LOAD_ATTR",
        "self.__class__.__qualname__"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._offset"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._name"
    ],
    [
        "BUILD_STRING",
        "\"%s.%s(%r, %r)\" % (self.__class__.__module__,\n                                  self.__class__.__qualname__,\n                                  self._offset, self._name)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.tzname"
    ],
    [
        "CALL",
        "self.tzname(None)"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "dt"
    ],
    [
        "LOAD_GLOBAL",
        "datetime"
    ],
    [
        "CALL",
        "isinstance(dt, datetime)"
    ],
    [
        "LOAD_FAST",
        "dt"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._offset"
    ],
    [
        "LOAD_GLOBAL",
        "TypeError"
    ],
    [
        "CALL",
        "TypeError(\"utcoffset() argument must be a datetime instance\"\n                        \" or None\")"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "dt"
    ],
    [
        "LOAD_GLOBAL",
        "datetime"
    ],
    [
        "CALL",
        "isinstance(dt, datetime)"
    ],
    [
        "LOAD_FAST",
        "dt"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._name"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._name_from_offset"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._offset"
    ],
    [
        "CALL",
        "self._name_from_offset(self._offset)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._name"
    ],
    [
        "LOAD_GLOBAL",
        "TypeError"
    ],
    [
        "CALL",
        "TypeError(\"tzname() argument must be a datetime instance\"\n                        \" or None\")"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "dt"
    ],
    [
        "LOAD_GLOBAL",
        "datetime"
    ],
    [
        "CALL",
        "isinstance(dt, datetime)"
    ],
    [
        "LOAD_FAST",
        "dt"
    ],
    [
        "LOAD_GLOBAL",
        "TypeError"
    ],
    [
        "CALL",
        "TypeError(\"dst() argument must be a datetime instance\"\n                        \" or None\")"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "dt"
    ],
    [
        "LOAD_GLOBAL",
        "datetime"
    ],
    [
        "CALL",
        "isinstance(dt, datetime)"
    ],
    [
        "LOAD_FAST",
        "dt"
    ],
    [
        "LOAD_ATTR",
        "dt.tzinfo"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "IS_OP",
        "dt.tzinfo is not self"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "CALL",
        "ValueError(\"fromutc: dt.tzinfo \"\n                                 \"is not self\")"
    ],
    [
        "LOAD_FAST",
        "dt"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._offset"
    ],
    [
        "BINARY_OP",
        "dt + self._offset"
    ],
    [
        "LOAD_GLOBAL",
        "TypeError"
    ],
    [
        "CALL",
        "TypeError(\"fromutc() argument must be a datetime instance\"\n                        \" or None\")"
    ],
    [
        "LOAD_FAST",
        "delta"
    ],
    [
        "LOAD_FAST",
        "delta"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "CALL",
        "timedelta(0)"
    ],
    [
        "COMPARE_OP",
        "delta < timedelta(0)"
    ],
    [
        "STORE_FAST",
        "sign"
    ],
    [
        "LOAD_FAST",
        "delta"
    ],
    [
        "UNARY_NEGATIVE",
        "-delta"
    ],
    [
        "STORE_FAST",
        "delta"
    ],
    [
        "STORE_FAST",
        "sign"
    ],
    [
        "LOAD_GLOBAL",
        "divmod"
    ],
    [
        "LOAD_FAST",
        "delta"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "CALL",
        "timedelta(hours=1)"
    ],
    [
        "CALL",
        "divmod(delta, timedelta(hours=1))"
    ],
    [
        "STORE_FAST",
        "hours"
    ],
    [
        "STORE_FAST",
        "rest"
    ],
    [
        "LOAD_GLOBAL",
        "divmod"
    ],
    [
        "LOAD_FAST",
        "rest"
    ],
    [
        "LOAD_GLOBAL",
        "timedelta"
    ],
    [
        "CALL",
        "timedelta(minutes=1)"
    ],
    [
        "CALL",
        "divmod(rest, timedelta(minutes=1))"
    ],
    [
        "STORE_FAST",
        "minutes"
    ],
    [
        "STORE_FAST",
        "rest"
    ],
    [
        "LOAD_FAST",
        "rest"
    ],
    [
        "LOAD_ATTR",
        "rest.seconds"
    ],
    [
        "STORE_FAST",
        "seconds"
    ],
    [
        "LOAD_FAST",
        "rest"
    ],
    [
        "LOAD_ATTR",
        "rest.microseconds"
    ],
    [
        "STORE_FAST",
        "microseconds"
    ],
    [
        "LOAD_FAST",
        "microseconds"
    ],
    [
        "LOAD_FAST",
        "sign"
    ],
    [
        "LOAD_FAST",
        "hours"
    ],
    [
        "LOAD_FAST",
        "minutes"
    ],
    [
        "LOAD_FAST",
        "seconds"
    ],
    [
        "LOAD_FAST",
        "microseconds"
    ],
    [
        "BUILD_STRING",
        "f'UTC{sign}{hours:02d}:{minutes:02d}:{seconds:02d}'\n                    f'.{microseconds:06d}'"
    ],
    [
        "LOAD_FAST",
        "seconds"
    ],
    [
        "LOAD_FAST",
        "sign"
    ],
    [
        "LOAD_FAST",
        "hours"
    ],
    [
        "LOAD_FAST",
        "minutes"
    ],
    [
        "LOAD_FAST",
        "seconds"
    ],
    [
        "BUILD_STRING",
        "f'UTC{sign}{hours:02d}:{minutes:02d}:{seconds:02d}'"
    ],
    [
        "LOAD_FAST",
        "sign"
    ],
    [
        "LOAD_FAST",
        "hours"
    ],
    [
        "LOAD_FAST",
        "minutes"
    ],
    [
        "BUILD_STRING",
        "f'UTC{sign}{hours:02d}:{minutes:02d}'"
    ]
]