[
    [
        "STORE_NAME",
        "\"\"\"\nThis module provides the generic functionality of tracing code by\nmodifying its AST. Eventually this will become a separate package.\nThis is similar to the standard library module bdb, while birdseye\nitself would correspond to pdb.\nMost of the work is in TreeTracerBase.\n\"\"\""
    ],
    [
        "STORE_NAME",
        "from __future__ import print_function, division, absolute_import"
    ],
    [
        "STORE_NAME",
        "from __future__ import print_function, division, absolute_import"
    ],
    [
        "STORE_NAME",
        "from __future__ import print_function, division, absolute_import"
    ],
    [
        "STORE_NAME",
        "from future import standard_library"
    ],
    [
        "LOAD_NAME",
        "standard_library"
    ],
    [
        "LOAD_ATTR",
        "standard_library.install_aliases"
    ],
    [
        "CALL",
        "standard_library.install_aliases()"
    ],
    [
        "STORE_NAME",
        "import ast"
    ],
    [
        "STORE_NAME",
        "import inspect"
    ],
    [
        "STORE_NAME",
        "import sys"
    ],
    [
        "STORE_NAME",
        "from collections import namedtuple, defaultdict"
    ],
    [
        "STORE_NAME",
        "from collections import namedtuple, defaultdict"
    ],
    [
        "STORE_NAME",
        "from copy import deepcopy"
    ],
    [
        "STORE_NAME",
        "from functools import partial, update_wrapper, wraps"
    ],
    [
        "STORE_NAME",
        "from functools import partial, update_wrapper, wraps"
    ],
    [
        "STORE_NAME",
        "from functools import partial, update_wrapper, wraps"
    ],
    [
        "STORE_NAME",
        "from itertools import takewhile"
    ],
    [
        "STORE_NAME",
        "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Callable, cast, Union"
    ],
    [
        "STORE_NAME",
        "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Callable, cast, Union"
    ],
    [
        "STORE_NAME",
        "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Callable, cast, Union"
    ],
    [
        "STORE_NAME",
        "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Callable, cast, Union"
    ],
    [
        "STORE_NAME",
        "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Callable, cast, Union"
    ],
    [
        "STORE_NAME",
        "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Callable, cast, Union"
    ],
    [
        "STORE_NAME",
        "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Callable, cast, Union"
    ],
    [
        "STORE_NAME",
        "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Callable, cast, Union"
    ],
    [
        "STORE_NAME",
        "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Callable, cast, Union"
    ],
    [
        "STORE_NAME",
        "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Callable, cast, Union"
    ],
    [
        "STORE_NAME",
        "from types import FrameType, TracebackType, CodeType, FunctionType"
    ],
    [
        "STORE_NAME",
        "from types import FrameType, TracebackType, CodeType, FunctionType"
    ],
    [
        "STORE_NAME",
        "from types import FrameType, TracebackType, CodeType, FunctionType"
    ],
    [
        "STORE_NAME",
        "from types import FrameType, TracebackType, CodeType, FunctionType"
    ],
    [
        "STORE_NAME",
        "from birdseye.utils import PY3, Type, is_lambda, lru_cache, read_source_file, is_ipython_cell, \\\n    is_future_import"
    ],
    [
        "STORE_NAME",
        "from birdseye.utils import PY3, Type, is_lambda, lru_cache, read_source_file, is_ipython_cell, \\\n    is_future_import"
    ],
    [
        "STORE_NAME",
        "from birdseye.utils import PY3, Type, is_lambda, lru_cache, read_source_file, is_ipython_cell, \\\n    is_future_import"
    ],
    [
        "STORE_NAME",
        "from birdseye.utils import PY3, Type, is_lambda, lru_cache, read_source_file, is_ipython_cell, \\\n    is_future_import"
    ],
    [
        "STORE_NAME",
        "from birdseye.utils import PY3, Type, is_lambda, lru_cache, read_source_file, is_ipython_cell, \\\n    is_future_import"
    ],
    [
        "STORE_NAME",
        "from birdseye.utils import PY3, Type, is_lambda, lru_cache, read_source_file, is_ipython_cell, \\\n    is_future_import"
    ],
    [
        "STORE_NAME",
        "from birdseye.utils import PY3, Type, is_lambda, lru_cache, read_source_file, is_ipython_cell, \\\n    is_future_import"
    ],
    [
        "LOAD_NAME",
        "object"
    ],
    [
        "CALL",
        "class TracedFile(object):\n    \"\"\"\n    An instance of this class corresponds to a single .py file.\n    It contains some useful data in the following attributes:\n\n    - filename: name of the source file\n    - source: textual contents of the file\n    - root: root of the original Abstract Syntax Tree (AST) of the source,\n            where the nodes of this tree have an additional handy attribute:\n            - parent: parent of the node, so this node is a child node of its parent\n    - tracer: instance of TreeTracerBase\n    - code: executable code object compiled from the modified AST\n    \"\"\"\n\n    is_ipython_cell = False\n\n    def __init__(self, tracer, source, filename, flags):\n        # type: (TreeTracerBase, str, str, int) -> None\n        # Here the source code is parsed, modified, and compiled\n        self.root = compile(source, filename, 'exec', ast.PyCF_ONLY_AST | flags, dont_inherit=True)  # type: ast.Module\n\n        self.nodes = []  # type: List[ast.AST]\n\n        self.set_basic_node_attributes()\n\n        new_root = tracer.parse_extra(self.root, source, filename)\n        if new_root is not None:\n            self.root = new_root\n\n        self.set_basic_node_attributes()\n        self.set_enter_call_nodes()\n\n        new_root = deepcopy(self.root)\n        new_root = _NodeVisitor().visit(new_root)\n\n        self.code = compile(new_root, filename, \"exec\", dont_inherit=True, flags=flags)  # type: CodeType\n        self.tracer = tracer\n        self.source = source\n        self.filename = filename\n\n    def set_basic_node_attributes(self):\n        self.nodes = []  # type: List[ast.AST]\n        for node in ast.walk(self.root):  # type: ast.AST\n            for child in ast.iter_child_nodes(node):\n                child.parent = node\n            node._tree_index = len(self.nodes)\n            self.nodes.append(node)\n\n        # Mark __future__ imports and anything before (i.e. module docstrings)\n        # to be ignored by the AST transformer\n        for i, stmt in enumerate(self.root.body):\n            if is_future_import(stmt):\n                for s in self.root.body[:i + 1]:\n                    for node in ast.walk(s):\n                        node._visit_ignore = True\n\n    def set_enter_call_nodes(self):\n        for node in self.nodes:\n            if isinstance(node, (ast.Module, ast.FunctionDef)):\n                for stmt in node.body:\n                    if not is_future_import(stmt):\n                        stmt._enter_call_node = True\n                        break"
    ],
    [
        "STORE_NAME",
        "class TracedFile(object):\n    \"\"\"\n    An instance of this class corresponds to a single .py file.\n    It contains some useful data in the following attributes:\n\n    - filename: name of the source file\n    - source: textual contents of the file\n    - root: root of the original Abstract Syntax Tree (AST) of the source,\n            where the nodes of this tree have an additional handy attribute:\n            - parent: parent of the node, so this node is a child node of its parent\n    - tracer: instance of TreeTracerBase\n    - code: executable code object compiled from the modified AST\n    \"\"\"\n\n    is_ipython_cell = False\n\n    def __init__(self, tracer, source, filename, flags):\n        # type: (TreeTracerBase, str, str, int) -> None\n        # Here the source code is parsed, modified, and compiled\n        self.root = compile(source, filename, 'exec', ast.PyCF_ONLY_AST | flags, dont_inherit=True)  # type: ast.Module\n\n        self.nodes = []  # type: List[ast.AST]\n\n        self.set_basic_node_attributes()\n\n        new_root = tracer.parse_extra(self.root, source, filename)\n        if new_root is not None:\n            self.root = new_root\n\n        self.set_basic_node_attributes()\n        self.set_enter_call_nodes()\n\n        new_root = deepcopy(self.root)\n        new_root = _NodeVisitor().visit(new_root)\n\n        self.code = compile(new_root, filename, \"exec\", dont_inherit=True, flags=flags)  # type: CodeType\n        self.tracer = tracer\n        self.source = source\n        self.filename = filename\n\n    def set_basic_node_attributes(self):\n        self.nodes = []  # type: List[ast.AST]\n        for node in ast.walk(self.root):  # type: ast.AST\n            for child in ast.iter_child_nodes(node):\n                child.parent = node\n            node._tree_index = len(self.nodes)\n            self.nodes.append(node)\n\n        # Mark __future__ imports and anything before (i.e. module docstrings)\n        # to be ignored by the AST transformer\n        for i, stmt in enumerate(self.root.body):\n            if is_future_import(stmt):\n                for s in self.root.body[:i + 1]:\n                    for node in ast.walk(s):\n                        node._visit_ignore = True\n\n    def set_enter_call_nodes(self):\n        for node in self.nodes:\n            if isinstance(node, (ast.Module, ast.FunctionDef)):\n                for stmt in node.body:\n                    if not is_future_import(stmt):\n                        stmt._enter_call_node = True\n                        break"
    ],
    [
        "LOAD_NAME",
        "object"
    ],
    [
        "CALL",
        "class FrameInfo(object):\n    \"\"\"\n    Contains extra data about an execution frame.\n    Can be obtained from the stack attribute of a TreeTracerBase instance\n    \"\"\"\n    def __init__(self):\n        # Stack of statements currently being executed\n        self.statement_stack = []  # type: List[ast.stmt]\n\n        # Stack of expression nodes within the above statement that\n        # the interpreter is planning on evaluating, or has just evaluated\n        # in the case of the last element of the list. For example, given\n        # the expression f(g(x)), the stack would be [f, g, x] before and just\n        # after evaluating x, since function arguments are evaluated before the\n        # actual function call.\n        self.expression_stack = []  # type: List[ast.expr]\n\n        # Mapping from the expression node to its most recent value\n        # in the corresponding frame\n        self.expression_values = {}  # type: Dict[ast.expr, Any]\n\n        # Node where the frame has explicitly returned\n        # There may be parent nodes such as enclosing loops that still need to finish executing\n        self.return_node = None  # type: Optional[ast.Return]\n\n        # Most recent exception raised in the frame\n        self.exc_value = None"
    ],
    [
        "STORE_NAME",
        "class FrameInfo(object):\n    \"\"\"\n    Contains extra data about an execution frame.\n    Can be obtained from the stack attribute of a TreeTracerBase instance\n    \"\"\"\n    def __init__(self):\n        # Stack of statements currently being executed\n        self.statement_stack = []  # type: List[ast.stmt]\n\n        # Stack of expression nodes within the above statement that\n        # the interpreter is planning on evaluating, or has just evaluated\n        # in the case of the last element of the list. For example, given\n        # the expression f(g(x)), the stack would be [f, g, x] before and just\n        # after evaluating x, since function arguments are evaluated before the\n        # actual function call.\n        self.expression_stack = []  # type: List[ast.expr]\n\n        # Mapping from the expression node to its most recent value\n        # in the corresponding frame\n        self.expression_values = {}  # type: Dict[ast.expr, Any]\n\n        # Node where the frame has explicitly returned\n        # There may be parent nodes such as enclosing loops that still need to finish executing\n        self.return_node = None  # type: Optional[ast.Return]\n\n        # Most recent exception raised in the frame\n        self.exc_value = None"
    ],
    [
        "LOAD_NAME",
        "NamedTuple"
    ],
    [
        "LOAD_NAME",
        "Optional"
    ],
    [
        "LOAD_NAME",
        "Union"
    ],
    [
        "LOAD_NAME",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.expr"
    ],
    [
        "LOAD_NAME",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.stmt"
    ],
    [
        "BINARY_SUBSCR",
        "Union[ast.expr, ast.stmt]"
    ],
    [
        "BINARY_SUBSCR",
        "Optional[Union[ast.expr, ast.stmt]]"
    ],
    [
        "LOAD_NAME",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.AST"
    ],
    [
        "LOAD_NAME",
        "FrameType"
    ],
    [
        "LOAD_NAME",
        "FrameType"
    ],
    [
        "CALL",
        "NamedTuple('EnterCallInfo', [\n\n    # Node  from where the call was made\n    ('call_node', Optional[Union[ast.expr, ast.stmt]]),\n\n    # Node where the call begins\n    ('enter_node', ast.AST),\n\n    # Frame from which the call was made\n    ('caller_frame', FrameType),\n\n    # Frame of the call\n    ('current_frame', FrameType)])"
    ],
    [
        "STORE_NAME",
        "EnterCallInfo"
    ],
    [
        "LOAD_NAME",
        "NamedTuple"
    ],
    [
        "LOAD_NAME",
        "Optional"
    ],
    [
        "LOAD_NAME",
        "Union"
    ],
    [
        "LOAD_NAME",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.expr"
    ],
    [
        "LOAD_NAME",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.stmt"
    ],
    [
        "BINARY_SUBSCR",
        "Union[ast.expr, ast.stmt]"
    ],
    [
        "BINARY_SUBSCR",
        "Optional[Union[ast.expr, ast.stmt]]"
    ],
    [
        "LOAD_NAME",
        "Optional"
    ],
    [
        "LOAD_NAME",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.Return"
    ],
    [
        "BINARY_SUBSCR",
        "Optional[ast.Return]"
    ],
    [
        "LOAD_NAME",
        "FrameType"
    ],
    [
        "LOAD_NAME",
        "FrameType"
    ],
    [
        "LOAD_NAME",
        "Any"
    ],
    [
        "LOAD_NAME",
        "Optional"
    ],
    [
        "LOAD_NAME",
        "Exception"
    ],
    [
        "BINARY_SUBSCR",
        "Optional[Exception]"
    ],
    [
        "LOAD_NAME",
        "Optional"
    ],
    [
        "LOAD_NAME",
        "TracebackType"
    ],
    [
        "BINARY_SUBSCR",
        "Optional[TracebackType]"
    ],
    [
        "CALL",
        "NamedTuple('ExitCallInfo', [\n\n    # Node  from where the call was made\n    ('call_node', Optional[Union[ast.expr, ast.stmt]]),\n\n    # Node where the call explicitly returned\n    ('return_node', Optional[ast.Return]),\n\n    # Frame from which the call was made\n    ('caller_frame', FrameType),\n\n    # Frame of the call\n    ('current_frame', FrameType),\n\n    # Node where the call explicitly returned\n    ('return_value', Any),\n\n    # Exception raised in the call causing it to end,\n    # will propagate to the caller\n    ('exc_value', Optional[Exception]),\n\n    # Traceback corresponding to exc_value\n    ('exc_tb', Optional[TracebackType])])"
    ],
    [
        "STORE_NAME",
        "ExitCallInfo"
    ],
    [
        "LOAD_NAME",
        "namedtuple"
    ],
    [
        "CALL",
        "namedtuple('ChangeValue', 'value')"
    ],
    [
        "STORE_NAME",
        "ChangeValue"
    ],
    [
        "LOAD_NAME",
        "object"
    ],
    [
        "CALL",
        "class TreeTracerBase(object):\n    \"\"\"\n    Create a subclass of this class with one or more of the 'hooks'\n    (methods which are empty in this class) overridden to take a custom action\n    in the given situation. Then decorate functions with an instance of this class\n    to trace them.\n    \"\"\"\n\n    def __init__(self):\n        # Mapping from frames of execution being traced to FrameInfo objects\n        # for extra metadata.\n        self.stack = {}  # type: Dict[FrameType, FrameInfo]\n        self.main_to_secondary_frames = defaultdict(list)\n        self.secondary_to_main_frames = {}\n\n    @lru_cache()\n    def compile(self, source, filename, flags=0):\n        # type: (str, str, int) -> TracedFile\n        return TracedFile(self, source, filename, flags)\n\n    def _trace_methods_dict(self, traced_file):\n        # type: (TracedFile) -> Dict[str, Callable]\n        return {f.__name__: partial(f, traced_file)\n                for f in [\n                    self._treetrace_hidden_with_stmt,\n                    self._treetrace_hidden_before_expr,\n                    self._treetrace_hidden_after_expr,\n                ]}\n\n    def trace_function(self, func):\n        # type: (FunctionType) -> FunctionType\n        \"\"\"\n        Returns a version of the passed function with the AST modified to\n        trigger the tracing hooks.\n        \"\"\"\n        if not isinstance(func, FunctionType):\n            raise ValueError('You can only trace user-defined functions. '\n                             'The birdseye decorator must be applied first, '\n                             'at the bottom of the list.')\n\n        try:\n            if inspect.iscoroutinefunction(func) or inspect.isasyncgenfunction(func):\n                raise ValueError('You cannot trace async functions')\n        except AttributeError:\n            pass\n\n        if is_lambda(func):\n            raise ValueError('You cannot trace lambdas')\n\n        filename = inspect.getsourcefile(func)  # type: str\n\n        if is_ipython_cell(filename):\n            # noinspection PyPackageRequirements\n            from IPython import get_ipython\n            import linecache\n\n            flags = get_ipython().compile.flags\n            source = ''.join(linecache.cache[filename][2])\n        else:\n            source = read_source_file(filename)\n            flags = 0\n\n        # We compile the entire file instead of just the function source\n        # because it can contain context which affects the function code,\n        # e.g. enclosing functions and classes or __future__ imports\n        traced_file = self.compile(source, filename, flags)\n\n        if func.__dict__:\n            raise ValueError('The birdseye decorator must be applied first, '\n                             'at the bottom of the list.')\n\n        # Then we have to recursively search through the newly compiled\n        # code to find the code we actually want corresponding to this function\n        code_options = []  # type: List[CodeType]\n\n        def find_code(root_code):\n            # type: (CodeType) -> None\n            for const in root_code.co_consts:  # type: CodeType\n                if not inspect.iscode(const):\n                    continue\n                matches = (const.co_firstlineno == func.__code__.co_firstlineno and\n                           const.co_name == func.__code__.co_name)\n                if matches:\n                    code_options.append(const)\n                find_code(const)\n\n        find_code(traced_file.code)\n\n        if len(code_options) > 1:\n            # Currently lambdas aren't allowed anyway, but should be in the future\n            assert is_lambda(func)\n            raise ValueError(\"Failed to trace lambda. Convert the function to a def.\")\n        new_func_code = code_options[0]  # type: CodeType\n\n        # Give the new function access to the hooks\n        # We have to use the original __globals__ and not a copy\n        # because it's the actual module namespace that may get updated by other code\n        func.__globals__.update(self._trace_methods_dict(traced_file))\n\n        # http://stackoverflow.com/a/13503277/2482744\n        # noinspection PyArgumentList\n        new_func = FunctionType(new_func_code, func.__globals__, func.__name__, func.__defaults__, func.__closure__)\n        update_wrapper(new_func, func)  # type: FunctionType\n        if PY3:\n            new_func.__kwdefaults__ = getattr(func, '__kwdefaults__', None)\n        new_func.traced_file = traced_file\n        return new_func\n\n    def __call__(self, func=None, optional=False):\n        # type: (FunctionType, bool) -> Callable\n        \"\"\"\n        Decorator which returns a (possibly optionally) traced function.\n        This decorator can be called with or without arguments.\n        Typically it is called without arguments, in which case it returns\n        a traced function.\n        If optional=True, it returns a function similar to the original\n        but with an additional optional parameter trace_call, default False.\n        If trace_call is false, the underlying untraced function is used.\n        If true, the traced version is used.\n        \"\"\"\n        if inspect.isclass(func):\n            raise TypeError('Decorating classes is no longer supported')\n\n        if func:\n            # The decorator has been called without arguments/parentheses,\n            # e.g.\n            # @eye\n            # def ...\n            return self.trace_function(func)\n\n        # The decorator has been called with arguments/parentheses,\n        # e.g.\n        # @eye(...)\n        # def ...\n        # We must return a decorator\n\n        if not optional:\n            return self.trace_function\n\n        def decorator(actual_func):\n\n            traced = self.trace_function(actual_func)\n\n            @wraps(actual_func)\n            def wrapper(*args, **kwargs):\n                trace_call = kwargs.pop('trace_call', False)\n                if trace_call:\n                    f = traced\n                else:\n                    f = actual_func\n                return f(*args, **kwargs)\n\n            return wrapper\n\n        return decorator\n\n    def _main_frame(self, node):\n        # type: (ast.AST) -> Optional[FrameType]\n        frame = sys._getframe(2)\n        result = self.secondary_to_main_frames.get(frame)\n        if result:\n            return result\n\n        original_frame = frame\n\n        while frame.f_code.co_name in ('<listcomp>', '<dictcomp>', '<setcomp>'):\n            frame = frame.f_back\n\n        for node in ancestors(node):\n            if isinstance(node, (ast.FunctionDef, ast.Lambda)):\n                break\n\n            if isinstance(node, ast.ClassDef):\n                frame = frame.f_back\n\n        if frame.f_code.co_name in ('<lambda>', '<genexpr>'):\n            return None\n\n        self.secondary_to_main_frames[original_frame] = frame\n        self.main_to_secondary_frames[frame].append(original_frame)\n        return frame\n\n    def _treetrace_hidden_with_stmt(self, traced_file, _tree_index):\n        # type: (TracedFile, int) -> _StmtContext\n        \"\"\"\n        Called directly from the modified code.\n        Every statement in the original code becomes:\n\n        with _treetrace_hidden_with_stmt(...):\n            <statement>\n        \"\"\"\n        node = traced_file.nodes[_tree_index]\n        node = cast(ast.stmt, node)\n        frame = self._main_frame(node)\n        return _StmtContext(self, node, frame)\n\n    def _treetrace_hidden_before_expr(self, traced_file, _tree_index):\n        # type: (TracedFile, int) -> ast.expr\n        \"\"\"\n        Called directly from the modified code before an expression is\n        evaluated.\n        \"\"\"\n        node = traced_file.nodes[_tree_index]\n        node = cast(ast.expr, node)\n        frame = self._main_frame(node)\n        if frame is None:\n            return node\n\n        frame_info = self.stack[frame]\n        frame_info.expression_stack.append(node)\n\n        self.before_expr(node, frame)\n        return node\n\n    def _treetrace_hidden_after_expr(self, _, node, value):\n        # type: (TracedFile, ast.expr, Any) -> Any\n        \"\"\"\n        Called directly from the modified code after an expression is\n        evaluated.\n        \"\"\"\n        frame = self._main_frame(node)\n        if frame is None:\n            return value\n\n        result = self._after_expr(node, frame, value, None, None)\n        if result is not None:\n            assert isinstance(result, ChangeValue), \"after_expr must return None or an instance of ChangeValue\"\n            value = result.value\n        return value\n\n    def _after_expr(self, node, frame, value, exc_value, exc_tb):\n        frame_info = self.stack[frame]\n        frame_info.expression_stack.pop()\n        frame_info.expression_values[node] = value\n        return self.after_expr(node, frame, value, exc_value, exc_tb)\n\n    def _enter_call(self, enter_node, current_frame):\n        # type: (ast.AST, FrameType) -> None\n        caller_frame, call_node = self._get_caller_stuff(current_frame)\n        self.stack[current_frame] = FrameInfo()\n        self.enter_call(EnterCallInfo(call_node, enter_node, caller_frame, current_frame))\n\n    def _get_caller_stuff(self, frame):\n        # type: (FrameType) -> Tuple[FrameType, Optional[Union[ast.expr, ast.stmt]]]\n        caller_frame = frame.f_back\n        call_node = None\n        main_frame = self.secondary_to_main_frames.get(caller_frame)\n        if main_frame:\n            caller_frame = main_frame\n            frame_info = self.stack[caller_frame]\n            expression_stack = frame_info.expression_stack\n            if expression_stack:\n                call_node = expression_stack[-1]\n            else:\n                call_node = frame_info.statement_stack[-1]  # type: ignore\n        return caller_frame, call_node\n\n    # The methods below are hooks meant to be overridden in subclasses to take custom actions\n\n    def before_expr(self, node, frame):\n        # type: (ast.expr, FrameType) -> None\n        \"\"\"\n        Called right before the expression corresponding to `node` is evaluated\n        within `frame`.\n        \"\"\"\n\n    def after_expr(self, node, frame, value, exc_value, exc_tb):\n        # type: (ast.expr, FrameType, Any, Optional[BaseException], Optional[TracebackType]) -> Optional[ChangeValue]\n        \"\"\"\n        Called right after the expression corresponding to `node` is evaluated\n        within `frame`. `value` is the value of the expression, if it succeeded.\n        If the evaluation raised an exception, exc_value will be the exception object\n        and exc_tb the traceback.\n\n        Return `ChangeValue(x)` to change the value of the expression as\n        seen by the rest of the program from `value` to `x`.\n        \"\"\"\n\n    def before_stmt(self, node, frame):\n        # type: (ast.stmt, FrameType) -> None\n        \"\"\"\n        Called right before the statement corresponding to `node` is executed\n        within `frame`.\n        \"\"\"\n\n    def after_stmt(self, node, frame, exc_value, exc_traceback, exc_node):\n        # type: (ast.stmt, FrameType, Optional[BaseException], Optional[TracebackType], Optional[ast.AST]) -> Optional[bool]\n        \"\"\"\n        Called right after the statement corresponding to `node` is executed\n        within `frame`.\n        If the statement raised an exception, exc_value will be the exception object,\n        exc_tb the traceback, and exc_node the node where the exception was raised\n        (either this statement or an expression within).\n\n        Returning True will suppress any exception raised (as with __exit__ in general).\n        \"\"\"\n\n    def enter_call(self, enter_info):\n        # type: (EnterCallInfo) -> None\n        \"\"\"\n        Called before a function call begins executing. For typical `def` functions,\n        this is called before the `before_stmt` for to the first statement in the function.\n        \"\"\"\n\n    def exit_call(self, exit_info):\n        # type: (ExitCallInfo) -> None\n        \"\"\"\n        Called after a function call finishes executing. For typical `def` functions,\n        this is called after the `after_stmt` for to the last statement to execute.\n        \"\"\"\n\n    def parse_extra(self, root, source, filename):\n        # type: (ast.Module, str, str) -> Optional[ast.Module]\n        \"\"\"\n        Called before the AST (root) is modified to let subclasses make additional changes first.\n        \"\"\""
    ],
    [
        "STORE_NAME",
        "class TreeTracerBase(object):\n    \"\"\"\n    Create a subclass of this class with one or more of the 'hooks'\n    (methods which are empty in this class) overridden to take a custom action\n    in the given situation. Then decorate functions with an instance of this class\n    to trace them.\n    \"\"\"\n\n    def __init__(self):\n        # Mapping from frames of execution being traced to FrameInfo objects\n        # for extra metadata.\n        self.stack = {}  # type: Dict[FrameType, FrameInfo]\n        self.main_to_secondary_frames = defaultdict(list)\n        self.secondary_to_main_frames = {}\n\n    @lru_cache()\n    def compile(self, source, filename, flags=0):\n        # type: (str, str, int) -> TracedFile\n        return TracedFile(self, source, filename, flags)\n\n    def _trace_methods_dict(self, traced_file):\n        # type: (TracedFile) -> Dict[str, Callable]\n        return {f.__name__: partial(f, traced_file)\n                for f in [\n                    self._treetrace_hidden_with_stmt,\n                    self._treetrace_hidden_before_expr,\n                    self._treetrace_hidden_after_expr,\n                ]}\n\n    def trace_function(self, func):\n        # type: (FunctionType) -> FunctionType\n        \"\"\"\n        Returns a version of the passed function with the AST modified to\n        trigger the tracing hooks.\n        \"\"\"\n        if not isinstance(func, FunctionType):\n            raise ValueError('You can only trace user-defined functions. '\n                             'The birdseye decorator must be applied first, '\n                             'at the bottom of the list.')\n\n        try:\n            if inspect.iscoroutinefunction(func) or inspect.isasyncgenfunction(func):\n                raise ValueError('You cannot trace async functions')\n        except AttributeError:\n            pass\n\n        if is_lambda(func):\n            raise ValueError('You cannot trace lambdas')\n\n        filename = inspect.getsourcefile(func)  # type: str\n\n        if is_ipython_cell(filename):\n            # noinspection PyPackageRequirements\n            from IPython import get_ipython\n            import linecache\n\n            flags = get_ipython().compile.flags\n            source = ''.join(linecache.cache[filename][2])\n        else:\n            source = read_source_file(filename)\n            flags = 0\n\n        # We compile the entire file instead of just the function source\n        # because it can contain context which affects the function code,\n        # e.g. enclosing functions and classes or __future__ imports\n        traced_file = self.compile(source, filename, flags)\n\n        if func.__dict__:\n            raise ValueError('The birdseye decorator must be applied first, '\n                             'at the bottom of the list.')\n\n        # Then we have to recursively search through the newly compiled\n        # code to find the code we actually want corresponding to this function\n        code_options = []  # type: List[CodeType]\n\n        def find_code(root_code):\n            # type: (CodeType) -> None\n            for const in root_code.co_consts:  # type: CodeType\n                if not inspect.iscode(const):\n                    continue\n                matches = (const.co_firstlineno == func.__code__.co_firstlineno and\n                           const.co_name == func.__code__.co_name)\n                if matches:\n                    code_options.append(const)\n                find_code(const)\n\n        find_code(traced_file.code)\n\n        if len(code_options) > 1:\n            # Currently lambdas aren't allowed anyway, but should be in the future\n            assert is_lambda(func)\n            raise ValueError(\"Failed to trace lambda. Convert the function to a def.\")\n        new_func_code = code_options[0]  # type: CodeType\n\n        # Give the new function access to the hooks\n        # We have to use the original __globals__ and not a copy\n        # because it's the actual module namespace that may get updated by other code\n        func.__globals__.update(self._trace_methods_dict(traced_file))\n\n        # http://stackoverflow.com/a/13503277/2482744\n        # noinspection PyArgumentList\n        new_func = FunctionType(new_func_code, func.__globals__, func.__name__, func.__defaults__, func.__closure__)\n        update_wrapper(new_func, func)  # type: FunctionType\n        if PY3:\n            new_func.__kwdefaults__ = getattr(func, '__kwdefaults__', None)\n        new_func.traced_file = traced_file\n        return new_func\n\n    def __call__(self, func=None, optional=False):\n        # type: (FunctionType, bool) -> Callable\n        \"\"\"\n        Decorator which returns a (possibly optionally) traced function.\n        This decorator can be called with or without arguments.\n        Typically it is called without arguments, in which case it returns\n        a traced function.\n        If optional=True, it returns a function similar to the original\n        but with an additional optional parameter trace_call, default False.\n        If trace_call is false, the underlying untraced function is used.\n        If true, the traced version is used.\n        \"\"\"\n        if inspect.isclass(func):\n            raise TypeError('Decorating classes is no longer supported')\n\n        if func:\n            # The decorator has been called without arguments/parentheses,\n            # e.g.\n            # @eye\n            # def ...\n            return self.trace_function(func)\n\n        # The decorator has been called with arguments/parentheses,\n        # e.g.\n        # @eye(...)\n        # def ...\n        # We must return a decorator\n\n        if not optional:\n            return self.trace_function\n\n        def decorator(actual_func):\n\n            traced = self.trace_function(actual_func)\n\n            @wraps(actual_func)\n            def wrapper(*args, **kwargs):\n                trace_call = kwargs.pop('trace_call', False)\n                if trace_call:\n                    f = traced\n                else:\n                    f = actual_func\n                return f(*args, **kwargs)\n\n            return wrapper\n\n        return decorator\n\n    def _main_frame(self, node):\n        # type: (ast.AST) -> Optional[FrameType]\n        frame = sys._getframe(2)\n        result = self.secondary_to_main_frames.get(frame)\n        if result:\n            return result\n\n        original_frame = frame\n\n        while frame.f_code.co_name in ('<listcomp>', '<dictcomp>', '<setcomp>'):\n            frame = frame.f_back\n\n        for node in ancestors(node):\n            if isinstance(node, (ast.FunctionDef, ast.Lambda)):\n                break\n\n            if isinstance(node, ast.ClassDef):\n                frame = frame.f_back\n\n        if frame.f_code.co_name in ('<lambda>', '<genexpr>'):\n            return None\n\n        self.secondary_to_main_frames[original_frame] = frame\n        self.main_to_secondary_frames[frame].append(original_frame)\n        return frame\n\n    def _treetrace_hidden_with_stmt(self, traced_file, _tree_index):\n        # type: (TracedFile, int) -> _StmtContext\n        \"\"\"\n        Called directly from the modified code.\n        Every statement in the original code becomes:\n\n        with _treetrace_hidden_with_stmt(...):\n            <statement>\n        \"\"\"\n        node = traced_file.nodes[_tree_index]\n        node = cast(ast.stmt, node)\n        frame = self._main_frame(node)\n        return _StmtContext(self, node, frame)\n\n    def _treetrace_hidden_before_expr(self, traced_file, _tree_index):\n        # type: (TracedFile, int) -> ast.expr\n        \"\"\"\n        Called directly from the modified code before an expression is\n        evaluated.\n        \"\"\"\n        node = traced_file.nodes[_tree_index]\n        node = cast(ast.expr, node)\n        frame = self._main_frame(node)\n        if frame is None:\n            return node\n\n        frame_info = self.stack[frame]\n        frame_info.expression_stack.append(node)\n\n        self.before_expr(node, frame)\n        return node\n\n    def _treetrace_hidden_after_expr(self, _, node, value):\n        # type: (TracedFile, ast.expr, Any) -> Any\n        \"\"\"\n        Called directly from the modified code after an expression is\n        evaluated.\n        \"\"\"\n        frame = self._main_frame(node)\n        if frame is None:\n            return value\n\n        result = self._after_expr(node, frame, value, None, None)\n        if result is not None:\n            assert isinstance(result, ChangeValue), \"after_expr must return None or an instance of ChangeValue\"\n            value = result.value\n        return value\n\n    def _after_expr(self, node, frame, value, exc_value, exc_tb):\n        frame_info = self.stack[frame]\n        frame_info.expression_stack.pop()\n        frame_info.expression_values[node] = value\n        return self.after_expr(node, frame, value, exc_value, exc_tb)\n\n    def _enter_call(self, enter_node, current_frame):\n        # type: (ast.AST, FrameType) -> None\n        caller_frame, call_node = self._get_caller_stuff(current_frame)\n        self.stack[current_frame] = FrameInfo()\n        self.enter_call(EnterCallInfo(call_node, enter_node, caller_frame, current_frame))\n\n    def _get_caller_stuff(self, frame):\n        # type: (FrameType) -> Tuple[FrameType, Optional[Union[ast.expr, ast.stmt]]]\n        caller_frame = frame.f_back\n        call_node = None\n        main_frame = self.secondary_to_main_frames.get(caller_frame)\n        if main_frame:\n            caller_frame = main_frame\n            frame_info = self.stack[caller_frame]\n            expression_stack = frame_info.expression_stack\n            if expression_stack:\n                call_node = expression_stack[-1]\n            else:\n                call_node = frame_info.statement_stack[-1]  # type: ignore\n        return caller_frame, call_node\n\n    # The methods below are hooks meant to be overridden in subclasses to take custom actions\n\n    def before_expr(self, node, frame):\n        # type: (ast.expr, FrameType) -> None\n        \"\"\"\n        Called right before the expression corresponding to `node` is evaluated\n        within `frame`.\n        \"\"\"\n\n    def after_expr(self, node, frame, value, exc_value, exc_tb):\n        # type: (ast.expr, FrameType, Any, Optional[BaseException], Optional[TracebackType]) -> Optional[ChangeValue]\n        \"\"\"\n        Called right after the expression corresponding to `node` is evaluated\n        within `frame`. `value` is the value of the expression, if it succeeded.\n        If the evaluation raised an exception, exc_value will be the exception object\n        and exc_tb the traceback.\n\n        Return `ChangeValue(x)` to change the value of the expression as\n        seen by the rest of the program from `value` to `x`.\n        \"\"\"\n\n    def before_stmt(self, node, frame):\n        # type: (ast.stmt, FrameType) -> None\n        \"\"\"\n        Called right before the statement corresponding to `node` is executed\n        within `frame`.\n        \"\"\"\n\n    def after_stmt(self, node, frame, exc_value, exc_traceback, exc_node):\n        # type: (ast.stmt, FrameType, Optional[BaseException], Optional[TracebackType], Optional[ast.AST]) -> Optional[bool]\n        \"\"\"\n        Called right after the statement corresponding to `node` is executed\n        within `frame`.\n        If the statement raised an exception, exc_value will be the exception object,\n        exc_tb the traceback, and exc_node the node where the exception was raised\n        (either this statement or an expression within).\n\n        Returning True will suppress any exception raised (as with __exit__ in general).\n        \"\"\"\n\n    def enter_call(self, enter_info):\n        # type: (EnterCallInfo) -> None\n        \"\"\"\n        Called before a function call begins executing. For typical `def` functions,\n        this is called before the `before_stmt` for to the first statement in the function.\n        \"\"\"\n\n    def exit_call(self, exit_info):\n        # type: (ExitCallInfo) -> None\n        \"\"\"\n        Called after a function call finishes executing. For typical `def` functions,\n        this is called after the `after_stmt` for to the last statement to execute.\n        \"\"\"\n\n    def parse_extra(self, root, source, filename):\n        # type: (ast.Module, str, str) -> Optional[ast.Module]\n        \"\"\"\n        Called before the AST (root) is modified to let subclasses make additional changes first.\n        \"\"\""
    ],
    [
        "LOAD_NAME",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.NodeTransformer"
    ],
    [
        "CALL",
        "class _NodeVisitor(ast.NodeTransformer):\n    \"\"\"\n    This does the AST modifications that call the hooks.\n    \"\"\"\n\n    def generic_visit(self, node):\n        # type: (ast.AST) -> ast.AST\n        if not getattr(node, '_visit_ignore', False):\n            if (isinstance(node, ast.expr) and\n                    not (hasattr(node, \"ctx\") and not isinstance(node.ctx, ast.Load)) and\n                    not isinstance(node, getattr(ast, 'Starred', ()))):\n                return self.visit_expr(node)\n            if isinstance(node, ast.stmt):\n                return self.visit_stmt(node)\n        return super(_NodeVisitor, self).generic_visit(node)\n\n    def visit_expr(self, node):\n        # type: (ast.expr) -> ast.Call\n        \"\"\"\n        each expression e gets wrapped like this:\n            _treetrace_hidden_after_expr(_treetrace_hidden_before_expr(_tree_index), e)\n\n        where the _treetrace_* functions are the corresponding methods with the\n        TreeTracerBase and traced_file arguments already filled in (see _trace_methods_dict)\n        \"\"\"\n\n        before_marker = self._create_simple_marker_call(node, TreeTracerBase._treetrace_hidden_before_expr)\n        ast.copy_location(before_marker, node)\n\n        after_marker = ast.Call(\n            func=ast.Name(id=TreeTracerBase._treetrace_hidden_after_expr.__name__,\n                          ctx=ast.Load()),\n            args=[\n                before_marker,\n                super(_NodeVisitor, self).generic_visit(node),\n            ],\n            keywords=[],\n        )\n        ast.copy_location(after_marker, node)\n        ast.fix_missing_locations(after_marker)\n\n        return after_marker\n\n    def visit_stmt(self, node):\n        # type: (ast.stmt) -> ast.With\n        \"\"\"\n        Every statement in the original code becomes:\n\n        with _treetrace_hidden_with_stmt(_tree_index):\n            <statement>\n\n        where the _treetrace_hidden_with_stmt function is the the corresponding method with the\n        TreeTracerBase and traced_file arguments already filled in (see _trace_methods_dict)\n        \"\"\"\n        context_expr = self._create_simple_marker_call(\n            super(_NodeVisitor, self).generic_visit(node),\n            TreeTracerBase._treetrace_hidden_with_stmt)\n\n        if PY3:\n            wrapped = ast.With(\n                items=[ast.withitem(context_expr=context_expr)],\n                body=[node],\n            )\n        else:\n            wrapped = ast.With(\n                context_expr=context_expr,\n                body=[node],\n            )\n        ast.copy_location(wrapped, node)\n        ast.fix_missing_locations(wrapped)\n        return wrapped\n\n    @staticmethod\n    def _create_simple_marker_call(node, func):\n        # type: (ast.AST, Callable) -> ast.Call\n        \"\"\"\n        Returns a Call node representing `func(node._tree_index)`\n        where node._tree_index is a numerical literal which allows the node object\n        to be retrieved later through the nodes attribute of a TracedFile.\n        \"\"\"\n        return ast.Call(\n            func=ast.Name(id=func.__name__,\n                          ctx=ast.Load()),\n            args=[ast.Num(node._tree_index)],\n            keywords=[],\n        )"
    ],
    [
        "STORE_NAME",
        "class _NodeVisitor(ast.NodeTransformer):\n    \"\"\"\n    This does the AST modifications that call the hooks.\n    \"\"\"\n\n    def generic_visit(self, node):\n        # type: (ast.AST) -> ast.AST\n        if not getattr(node, '_visit_ignore', False):\n            if (isinstance(node, ast.expr) and\n                    not (hasattr(node, \"ctx\") and not isinstance(node.ctx, ast.Load)) and\n                    not isinstance(node, getattr(ast, 'Starred', ()))):\n                return self.visit_expr(node)\n            if isinstance(node, ast.stmt):\n                return self.visit_stmt(node)\n        return super(_NodeVisitor, self).generic_visit(node)\n\n    def visit_expr(self, node):\n        # type: (ast.expr) -> ast.Call\n        \"\"\"\n        each expression e gets wrapped like this:\n            _treetrace_hidden_after_expr(_treetrace_hidden_before_expr(_tree_index), e)\n\n        where the _treetrace_* functions are the corresponding methods with the\n        TreeTracerBase and traced_file arguments already filled in (see _trace_methods_dict)\n        \"\"\"\n\n        before_marker = self._create_simple_marker_call(node, TreeTracerBase._treetrace_hidden_before_expr)\n        ast.copy_location(before_marker, node)\n\n        after_marker = ast.Call(\n            func=ast.Name(id=TreeTracerBase._treetrace_hidden_after_expr.__name__,\n                          ctx=ast.Load()),\n            args=[\n                before_marker,\n                super(_NodeVisitor, self).generic_visit(node),\n            ],\n            keywords=[],\n        )\n        ast.copy_location(after_marker, node)\n        ast.fix_missing_locations(after_marker)\n\n        return after_marker\n\n    def visit_stmt(self, node):\n        # type: (ast.stmt) -> ast.With\n        \"\"\"\n        Every statement in the original code becomes:\n\n        with _treetrace_hidden_with_stmt(_tree_index):\n            <statement>\n\n        where the _treetrace_hidden_with_stmt function is the the corresponding method with the\n        TreeTracerBase and traced_file arguments already filled in (see _trace_methods_dict)\n        \"\"\"\n        context_expr = self._create_simple_marker_call(\n            super(_NodeVisitor, self).generic_visit(node),\n            TreeTracerBase._treetrace_hidden_with_stmt)\n\n        if PY3:\n            wrapped = ast.With(\n                items=[ast.withitem(context_expr=context_expr)],\n                body=[node],\n            )\n        else:\n            wrapped = ast.With(\n                context_expr=context_expr,\n                body=[node],\n            )\n        ast.copy_location(wrapped, node)\n        ast.fix_missing_locations(wrapped)\n        return wrapped\n\n    @staticmethod\n    def _create_simple_marker_call(node, func):\n        # type: (ast.AST, Callable) -> ast.Call\n        \"\"\"\n        Returns a Call node representing `func(node._tree_index)`\n        where node._tree_index is a numerical literal which allows the node object\n        to be retrieved later through the nodes attribute of a TracedFile.\n        \"\"\"\n        return ast.Call(\n            func=ast.Name(id=func.__name__,\n                          ctx=ast.Load()),\n            args=[ast.Num(node._tree_index)],\n            keywords=[],\n        )"
    ],
    [
        "LOAD_NAME",
        "object"
    ],
    [
        "CALL",
        "class _StmtContext(object):\n    __slots__ = ('tracer', 'node', 'frame')\n\n    def __init__(self, tracer, node, frame):\n        # type: (TreeTracerBase, ast.stmt, FrameType) -> None\n        self.tracer = tracer\n        self.node = node\n        self.frame = frame\n\n    def __enter__(self):\n        tracer = self.tracer\n        node = self.node\n        frame = self.frame\n        if getattr(node, '_enter_call_node', False):\n            tracer._enter_call(node, frame)\n        frame_info = tracer.stack[frame]\n        frame_info.expression_stack = []\n        frame_info.statement_stack.append(node)\n        tracer.before_stmt(node, frame)\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        # type: (Type[Exception], Exception, TracebackType) -> bool\n        node = self.node\n        tracer = self.tracer\n        frame = self.frame\n        frame_info = tracer.stack[frame]\n\n        frame_info.statement_stack.pop()\n\n        exc_node = None  # type: Optional[Union[ast.expr, ast.stmt]]\n        if exc_val and exc_val is not frame_info.exc_value:\n            exc_node = node\n            frame_info.exc_value = exc_val\n\n            # Call the after_expr hook if the exception was raised by an expression\n            expression_stack = frame_info.expression_stack\n            if expression_stack:\n                exc_node = expression_stack[-1]\n                tracer._after_expr(exc_node, frame, None, exc_val, exc_tb)\n\n        result = tracer.after_stmt(node, frame, exc_val, exc_tb, exc_node)\n\n        if isinstance(node, ast.Return):\n            frame_info.return_node = node\n\n        parent = node.parent  # type: ast.AST\n        return_node = frame_info.return_node\n        exiting = (isinstance(parent, (ast.FunctionDef, ast.Module)) and\n                   (node is parent.body[-1] or\n                    exc_val or\n                    return_node))\n        if exiting:\n            caller_frame, call_node = tracer._get_caller_stuff(frame)\n            return_value = None\n            if return_node and return_node.value and not exc_val:\n                return_value = frame_info.expression_values[return_node.value]\n            tracer.exit_call(ExitCallInfo(call_node,\n                                          return_node,\n                                          caller_frame,\n                                          frame,\n                                          return_value,\n                                          exc_val,\n                                          exc_tb\n                                          ))\n\n            del tracer.stack[frame]\n            for secondary_frame in self.tracer.main_to_secondary_frames.pop(frame):\n                del self.tracer.secondary_to_main_frames[secondary_frame]\n\n        return result"
    ],
    [
        "STORE_NAME",
        "class _StmtContext(object):\n    __slots__ = ('tracer', 'node', 'frame')\n\n    def __init__(self, tracer, node, frame):\n        # type: (TreeTracerBase, ast.stmt, FrameType) -> None\n        self.tracer = tracer\n        self.node = node\n        self.frame = frame\n\n    def __enter__(self):\n        tracer = self.tracer\n        node = self.node\n        frame = self.frame\n        if getattr(node, '_enter_call_node', False):\n            tracer._enter_call(node, frame)\n        frame_info = tracer.stack[frame]\n        frame_info.expression_stack = []\n        frame_info.statement_stack.append(node)\n        tracer.before_stmt(node, frame)\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        # type: (Type[Exception], Exception, TracebackType) -> bool\n        node = self.node\n        tracer = self.tracer\n        frame = self.frame\n        frame_info = tracer.stack[frame]\n\n        frame_info.statement_stack.pop()\n\n        exc_node = None  # type: Optional[Union[ast.expr, ast.stmt]]\n        if exc_val and exc_val is not frame_info.exc_value:\n            exc_node = node\n            frame_info.exc_value = exc_val\n\n            # Call the after_expr hook if the exception was raised by an expression\n            expression_stack = frame_info.expression_stack\n            if expression_stack:\n                exc_node = expression_stack[-1]\n                tracer._after_expr(exc_node, frame, None, exc_val, exc_tb)\n\n        result = tracer.after_stmt(node, frame, exc_val, exc_tb, exc_node)\n\n        if isinstance(node, ast.Return):\n            frame_info.return_node = node\n\n        parent = node.parent  # type: ast.AST\n        return_node = frame_info.return_node\n        exiting = (isinstance(parent, (ast.FunctionDef, ast.Module)) and\n                   (node is parent.body[-1] or\n                    exc_val or\n                    return_node))\n        if exiting:\n            caller_frame, call_node = tracer._get_caller_stuff(frame)\n            return_value = None\n            if return_node and return_node.value and not exc_val:\n                return_value = frame_info.expression_values[return_node.value]\n            tracer.exit_call(ExitCallInfo(call_node,\n                                          return_node,\n                                          caller_frame,\n                                          frame,\n                                          return_value,\n                                          exc_val,\n                                          exc_tb\n                                          ))\n\n            del tracer.stack[frame]\n            for secondary_frame in self.tracer.main_to_secondary_frames.pop(frame):\n                del self.tracer.secondary_to_main_frames[secondary_frame]\n\n        return result"
    ],
    [
        "STORE_NAME",
        "def ancestors(node):\n    # type: (ast.AST) -> Iterator[ast.AST]\n    while True:\n        try:\n            node = node.parent\n        except AttributeError:\n            break\n        yield node"
    ],
    [
        "LOAD_NAME",
        "Union"
    ],
    [
        "LOAD_NAME",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.For"
    ],
    [
        "LOAD_NAME",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.While"
    ],
    [
        "LOAD_NAME",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.comprehension"
    ],
    [
        "BINARY_SUBSCR",
        "Union[ast.For, ast.While, ast.comprehension]"
    ],
    [
        "STORE_NAME",
        "Loop"
    ],
    [
        "STORE_NAME",
        "def loops(node):\n    # type: (ast.AST) -> Tuple[Loop, ...]\n    \"\"\"\n    Return all the 'enclosing loops' of a node, up to the innermost class or\n    function definition. This also includes the 'for in' clauses in list/dict/set/generator\n    comprehensions. So for example, in this code:\n\n      for x in ...:\n          def foo():\n              while True:\n                  print([z for y in ...])\n\n    The loops enclosing the node 'z' are 'while True' and 'for y in ...', in that order.\n    \"\"\"\n    result = []\n    while True:\n        try:\n            parent = node.parent\n        except AttributeError:\n            break\n        if isinstance(parent, ast.FunctionDef):\n            break\n\n        is_containing_loop = (((isinstance(parent, ast.For) and parent.iter is not node or\n                                isinstance(parent, ast.While))\n                               and node not in parent.orelse) or\n                              (isinstance(parent, ast.comprehension) and node in parent.ifs))\n        if is_containing_loop:\n            result.append(parent)\n\n        elif isinstance(parent, (ast.ListComp,\n                                 ast.GeneratorExp,\n                                 ast.DictComp,\n                                 ast.SetComp)):\n            generators = parent.generators\n            if node in generators:\n                generators = list(takewhile(lambda n: n != node, generators))\n            result.extend(reversed(generators))\n\n        node = parent\n\n    result.reverse()\n    return tuple(result)"
    ],
    [
        "STORE_NAME",
        "\"\"\"\n    An instance of this class corresponds to a single .py file.\n    It contains some useful data in the following attributes:\n\n    - filename: name of the source file\n    - source: textual contents of the file\n    - root: root of the original Abstract Syntax Tree (AST) of the source,\n            where the nodes of this tree have an additional handy attribute:\n            - parent: parent of the node, so this node is a child node of its parent\n    - tracer: instance of TreeTracerBase\n    - code: executable code object compiled from the modified AST\n    \"\"\""
    ],
    [
        "STORE_NAME",
        "is_ipython_cell"
    ],
    [
        "STORE_NAME",
        "    def __init__(self, tracer, source, filename, flags):\n        # type: (TreeTracerBase, str, str, int) -> None\n        # Here the source code is parsed, modified, and compiled\n        self.root = compile(source, filename, 'exec', ast.PyCF_ONLY_AST | flags, dont_inherit=True)  # type: ast.Module\n\n        self.nodes = []  # type: List[ast.AST]\n\n        self.set_basic_node_attributes()\n\n        new_root = tracer.parse_extra(self.root, source, filename)\n        if new_root is not None:\n            self.root = new_root\n\n        self.set_basic_node_attributes()\n        self.set_enter_call_nodes()\n\n        new_root = deepcopy(self.root)\n        new_root = _NodeVisitor().visit(new_root)\n\n        self.code = compile(new_root, filename, \"exec\", dont_inherit=True, flags=flags)  # type: CodeType\n        self.tracer = tracer\n        self.source = source\n        self.filename = filename"
    ],
    [
        "STORE_NAME",
        "    def set_basic_node_attributes(self):\n        self.nodes = []  # type: List[ast.AST]\n        for node in ast.walk(self.root):  # type: ast.AST\n            for child in ast.iter_child_nodes(node):\n                child.parent = node\n            node._tree_index = len(self.nodes)\n            self.nodes.append(node)\n\n        # Mark __future__ imports and anything before (i.e. module docstrings)\n        # to be ignored by the AST transformer\n        for i, stmt in enumerate(self.root.body):\n            if is_future_import(stmt):\n                for s in self.root.body[:i + 1]:\n                    for node in ast.walk(s):\n                        node._visit_ignore = True"
    ],
    [
        "STORE_NAME",
        "    def set_enter_call_nodes(self):\n        for node in self.nodes:\n            if isinstance(node, (ast.Module, ast.FunctionDef)):\n                for stmt in node.body:\n                    if not is_future_import(stmt):\n                        stmt._enter_call_node = True\n                        break"
    ],
    [
        "LOAD_GLOBAL",
        "compile"
    ],
    [
        "LOAD_FAST",
        "source"
    ],
    [
        "LOAD_FAST",
        "filename"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.PyCF_ONLY_AST"
    ],
    [
        "LOAD_FAST",
        "flags"
    ],
    [
        "BINARY_OP",
        "ast.PyCF_ONLY_AST | flags"
    ],
    [
        "CALL",
        "compile(source, filename, 'exec', ast.PyCF_ONLY_AST | flags, dont_inherit=True)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.root"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.nodes"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.set_basic_node_attributes"
    ],
    [
        "CALL",
        "self.set_basic_node_attributes()"
    ],
    [
        "LOAD_FAST",
        "tracer"
    ],
    [
        "LOAD_ATTR",
        "tracer.parse_extra"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.root"
    ],
    [
        "LOAD_FAST",
        "source"
    ],
    [
        "LOAD_FAST",
        "filename"
    ],
    [
        "CALL",
        "tracer.parse_extra(self.root, source, filename)"
    ],
    [
        "STORE_FAST",
        "new_root"
    ],
    [
        "LOAD_FAST",
        "new_root"
    ],
    [
        "LOAD_FAST",
        "new_root"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.root"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.set_basic_node_attributes"
    ],
    [
        "CALL",
        "self.set_basic_node_attributes()"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.set_enter_call_nodes"
    ],
    [
        "CALL",
        "self.set_enter_call_nodes()"
    ],
    [
        "LOAD_GLOBAL",
        "deepcopy"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.root"
    ],
    [
        "CALL",
        "deepcopy(self.root)"
    ],
    [
        "STORE_FAST",
        "new_root"
    ],
    [
        "LOAD_GLOBAL",
        "_NodeVisitor"
    ],
    [
        "CALL",
        "_NodeVisitor()"
    ],
    [
        "LOAD_ATTR",
        "_NodeVisitor().visit"
    ],
    [
        "LOAD_FAST",
        "new_root"
    ],
    [
        "CALL",
        "_NodeVisitor().visit(new_root)"
    ],
    [
        "STORE_FAST",
        "new_root"
    ],
    [
        "LOAD_GLOBAL",
        "compile"
    ],
    [
        "LOAD_FAST",
        "new_root"
    ],
    [
        "LOAD_FAST",
        "filename"
    ],
    [
        "LOAD_FAST",
        "flags"
    ],
    [
        "CALL",
        "compile(new_root, filename, \"exec\", dont_inherit=True, flags=flags)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.code"
    ],
    [
        "LOAD_FAST",
        "tracer"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.tracer"
    ],
    [
        "LOAD_FAST",
        "source"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.source"
    ],
    [
        "LOAD_FAST",
        "filename"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.filename"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.nodes"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.walk"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.root"
    ],
    [
        "CALL",
        "ast.walk(self.root)"
    ],
    [
        "STORE_FAST",
        "node"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.iter_child_nodes"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "CALL",
        "ast.iter_child_nodes(node)"
    ],
    [
        "STORE_FAST",
        "child"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_FAST",
        "child"
    ],
    [
        "STORE_ATTR",
        "child.parent"
    ],
    [
        "LOAD_GLOBAL",
        "len"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.nodes"
    ],
    [
        "CALL",
        "len(self.nodes)"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "STORE_ATTR",
        "node._tree_index"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.nodes"
    ],
    [
        "LOAD_ATTR",
        "self.nodes.append"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "CALL",
        "self.nodes.append(node)"
    ],
    [
        "LOAD_GLOBAL",
        "enumerate"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.root"
    ],
    [
        "LOAD_ATTR",
        "self.root.body"
    ],
    [
        "CALL",
        "enumerate(self.root.body)"
    ],
    [
        "STORE_FAST",
        "i"
    ],
    [
        "STORE_FAST",
        "stmt"
    ],
    [
        "LOAD_GLOBAL",
        "is_future_import"
    ],
    [
        "LOAD_FAST",
        "stmt"
    ],
    [
        "CALL",
        "is_future_import(stmt)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.root"
    ],
    [
        "LOAD_ATTR",
        "self.root.body"
    ],
    [
        "LOAD_FAST",
        "i"
    ],
    [
        "BINARY_OP",
        "i + 1"
    ],
    [
        "BINARY_SLICE",
        "self.root.body[:i + 1]"
    ],
    [
        "STORE_FAST",
        "s"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.walk"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "CALL",
        "ast.walk(s)"
    ],
    [
        "STORE_FAST",
        "node"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "STORE_ATTR",
        "node._visit_ignore"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.nodes"
    ],
    [
        "STORE_FAST",
        "node"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.Module"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.FunctionDef"
    ],
    [
        "CALL",
        "isinstance(node, (ast.Module, ast.FunctionDef))"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node.body"
    ],
    [
        "STORE_FAST",
        "stmt"
    ],
    [
        "LOAD_GLOBAL",
        "is_future_import"
    ],
    [
        "LOAD_FAST",
        "stmt"
    ],
    [
        "CALL",
        "is_future_import(stmt)"
    ],
    [
        "LOAD_FAST",
        "stmt"
    ],
    [
        "STORE_ATTR",
        "stmt._enter_call_node"
    ],
    [
        "STORE_NAME",
        "\"\"\"\n    Contains extra data about an execution frame.\n    Can be obtained from the stack attribute of a TreeTracerBase instance\n    \"\"\""
    ],
    [
        "STORE_NAME",
        "    def __init__(self):\n        # Stack of statements currently being executed\n        self.statement_stack = []  # type: List[ast.stmt]\n\n        # Stack of expression nodes within the above statement that\n        # the interpreter is planning on evaluating, or has just evaluated\n        # in the case of the last element of the list. For example, given\n        # the expression f(g(x)), the stack would be [f, g, x] before and just\n        # after evaluating x, since function arguments are evaluated before the\n        # actual function call.\n        self.expression_stack = []  # type: List[ast.expr]\n\n        # Mapping from the expression node to its most recent value\n        # in the corresponding frame\n        self.expression_values = {}  # type: Dict[ast.expr, Any]\n\n        # Node where the frame has explicitly returned\n        # There may be parent nodes such as enclosing loops that still need to finish executing\n        self.return_node = None  # type: Optional[ast.Return]\n\n        # Most recent exception raised in the frame\n        self.exc_value = None"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.statement_stack"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.expression_stack"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.expression_values"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.return_node"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.exc_value"
    ],
    [
        "STORE_NAME",
        "\"\"\"\n    Create a subclass of this class with one or more of the 'hooks'\n    (methods which are empty in this class) overridden to take a custom action\n    in the given situation. Then decorate functions with an instance of this class\n    to trace them.\n    \"\"\""
    ],
    [
        "STORE_NAME",
        "    def __init__(self):\n        # Mapping from frames of execution being traced to FrameInfo objects\n        # for extra metadata.\n        self.stack = {}  # type: Dict[FrameType, FrameInfo]\n        self.main_to_secondary_frames = defaultdict(list)\n        self.secondary_to_main_frames = {}"
    ],
    [
        "LOAD_NAME",
        "lru_cache"
    ],
    [
        "CALL",
        "lru_cache()"
    ],
    [
        "CALL",
        "lru_cache()"
    ],
    [
        "STORE_NAME",
        "    @lru_cache()\n    def compile(self, source, filename, flags=0):\n        # type: (str, str, int) -> TracedFile\n        return TracedFile(self, source, filename, flags)"
    ],
    [
        "STORE_NAME",
        "    def _trace_methods_dict(self, traced_file):\n        # type: (TracedFile) -> Dict[str, Callable]\n        return {f.__name__: partial(f, traced_file)\n                for f in [\n                    self._treetrace_hidden_with_stmt,\n                    self._treetrace_hidden_before_expr,\n                    self._treetrace_hidden_after_expr,\n                ]}"
    ],
    [
        "STORE_NAME",
        "    def trace_function(self, func):\n        # type: (FunctionType) -> FunctionType\n        \"\"\"\n        Returns a version of the passed function with the AST modified to\n        trigger the tracing hooks.\n        \"\"\"\n        if not isinstance(func, FunctionType):\n            raise ValueError('You can only trace user-defined functions. '\n                             'The birdseye decorator must be applied first, '\n                             'at the bottom of the list.')\n\n        try:\n            if inspect.iscoroutinefunction(func) or inspect.isasyncgenfunction(func):\n                raise ValueError('You cannot trace async functions')\n        except AttributeError:\n            pass\n\n        if is_lambda(func):\n            raise ValueError('You cannot trace lambdas')\n\n        filename = inspect.getsourcefile(func)  # type: str\n\n        if is_ipython_cell(filename):\n            # noinspection PyPackageRequirements\n            from IPython import get_ipython\n            import linecache\n\n            flags = get_ipython().compile.flags\n            source = ''.join(linecache.cache[filename][2])\n        else:\n            source = read_source_file(filename)\n            flags = 0\n\n        # We compile the entire file instead of just the function source\n        # because it can contain context which affects the function code,\n        # e.g. enclosing functions and classes or __future__ imports\n        traced_file = self.compile(source, filename, flags)\n\n        if func.__dict__:\n            raise ValueError('The birdseye decorator must be applied first, '\n                             'at the bottom of the list.')\n\n        # Then we have to recursively search through the newly compiled\n        # code to find the code we actually want corresponding to this function\n        code_options = []  # type: List[CodeType]\n\n        def find_code(root_code):\n            # type: (CodeType) -> None\n            for const in root_code.co_consts:  # type: CodeType\n                if not inspect.iscode(const):\n                    continue\n                matches = (const.co_firstlineno == func.__code__.co_firstlineno and\n                           const.co_name == func.__code__.co_name)\n                if matches:\n                    code_options.append(const)\n                find_code(const)\n\n        find_code(traced_file.code)\n\n        if len(code_options) > 1:\n            # Currently lambdas aren't allowed anyway, but should be in the future\n            assert is_lambda(func)\n            raise ValueError(\"Failed to trace lambda. Convert the function to a def.\")\n        new_func_code = code_options[0]  # type: CodeType\n\n        # Give the new function access to the hooks\n        # We have to use the original __globals__ and not a copy\n        # because it's the actual module namespace that may get updated by other code\n        func.__globals__.update(self._trace_methods_dict(traced_file))\n\n        # http://stackoverflow.com/a/13503277/2482744\n        # noinspection PyArgumentList\n        new_func = FunctionType(new_func_code, func.__globals__, func.__name__, func.__defaults__, func.__closure__)\n        update_wrapper(new_func, func)  # type: FunctionType\n        if PY3:\n            new_func.__kwdefaults__ = getattr(func, '__kwdefaults__', None)\n        new_func.traced_file = traced_file\n        return new_func"
    ],
    [
        "STORE_NAME",
        "    def __call__(self, func=None, optional=False):\n        # type: (FunctionType, bool) -> Callable\n        \"\"\"\n        Decorator which returns a (possibly optionally) traced function.\n        This decorator can be called with or without arguments.\n        Typically it is called without arguments, in which case it returns\n        a traced function.\n        If optional=True, it returns a function similar to the original\n        but with an additional optional parameter trace_call, default False.\n        If trace_call is false, the underlying untraced function is used.\n        If true, the traced version is used.\n        \"\"\"\n        if inspect.isclass(func):\n            raise TypeError('Decorating classes is no longer supported')\n\n        if func:\n            # The decorator has been called without arguments/parentheses,\n            # e.g.\n            # @eye\n            # def ...\n            return self.trace_function(func)\n\n        # The decorator has been called with arguments/parentheses,\n        # e.g.\n        # @eye(...)\n        # def ...\n        # We must return a decorator\n\n        if not optional:\n            return self.trace_function\n\n        def decorator(actual_func):\n\n            traced = self.trace_function(actual_func)\n\n            @wraps(actual_func)\n            def wrapper(*args, **kwargs):\n                trace_call = kwargs.pop('trace_call', False)\n                if trace_call:\n                    f = traced\n                else:\n                    f = actual_func\n                return f(*args, **kwargs)\n\n            return wrapper\n\n        return decorator"
    ],
    [
        "STORE_NAME",
        "    def _main_frame(self, node):\n        # type: (ast.AST) -> Optional[FrameType]\n        frame = sys._getframe(2)\n        result = self.secondary_to_main_frames.get(frame)\n        if result:\n            return result\n\n        original_frame = frame\n\n        while frame.f_code.co_name in ('<listcomp>', '<dictcomp>', '<setcomp>'):\n            frame = frame.f_back\n\n        for node in ancestors(node):\n            if isinstance(node, (ast.FunctionDef, ast.Lambda)):\n                break\n\n            if isinstance(node, ast.ClassDef):\n                frame = frame.f_back\n\n        if frame.f_code.co_name in ('<lambda>', '<genexpr>'):\n            return None\n\n        self.secondary_to_main_frames[original_frame] = frame\n        self.main_to_secondary_frames[frame].append(original_frame)\n        return frame"
    ],
    [
        "STORE_NAME",
        "    def _treetrace_hidden_with_stmt(self, traced_file, _tree_index):\n        # type: (TracedFile, int) -> _StmtContext\n        \"\"\"\n        Called directly from the modified code.\n        Every statement in the original code becomes:\n\n        with _treetrace_hidden_with_stmt(...):\n            <statement>\n        \"\"\"\n        node = traced_file.nodes[_tree_index]\n        node = cast(ast.stmt, node)\n        frame = self._main_frame(node)\n        return _StmtContext(self, node, frame)"
    ],
    [
        "STORE_NAME",
        "    def _treetrace_hidden_before_expr(self, traced_file, _tree_index):\n        # type: (TracedFile, int) -> ast.expr\n        \"\"\"\n        Called directly from the modified code before an expression is\n        evaluated.\n        \"\"\"\n        node = traced_file.nodes[_tree_index]\n        node = cast(ast.expr, node)\n        frame = self._main_frame(node)\n        if frame is None:\n            return node\n\n        frame_info = self.stack[frame]\n        frame_info.expression_stack.append(node)\n\n        self.before_expr(node, frame)\n        return node"
    ],
    [
        "STORE_NAME",
        "    def _treetrace_hidden_after_expr(self, _, node, value):\n        # type: (TracedFile, ast.expr, Any) -> Any\n        \"\"\"\n        Called directly from the modified code after an expression is\n        evaluated.\n        \"\"\"\n        frame = self._main_frame(node)\n        if frame is None:\n            return value\n\n        result = self._after_expr(node, frame, value, None, None)\n        if result is not None:\n            assert isinstance(result, ChangeValue), \"after_expr must return None or an instance of ChangeValue\"\n            value = result.value\n        return value"
    ],
    [
        "STORE_NAME",
        "    def _after_expr(self, node, frame, value, exc_value, exc_tb):\n        frame_info = self.stack[frame]\n        frame_info.expression_stack.pop()\n        frame_info.expression_values[node] = value\n        return self.after_expr(node, frame, value, exc_value, exc_tb)"
    ],
    [
        "STORE_NAME",
        "    def _enter_call(self, enter_node, current_frame):\n        # type: (ast.AST, FrameType) -> None\n        caller_frame, call_node = self._get_caller_stuff(current_frame)\n        self.stack[current_frame] = FrameInfo()\n        self.enter_call(EnterCallInfo(call_node, enter_node, caller_frame, current_frame))"
    ],
    [
        "STORE_NAME",
        "    def _get_caller_stuff(self, frame):\n        # type: (FrameType) -> Tuple[FrameType, Optional[Union[ast.expr, ast.stmt]]]\n        caller_frame = frame.f_back\n        call_node = None\n        main_frame = self.secondary_to_main_frames.get(caller_frame)\n        if main_frame:\n            caller_frame = main_frame\n            frame_info = self.stack[caller_frame]\n            expression_stack = frame_info.expression_stack\n            if expression_stack:\n                call_node = expression_stack[-1]\n            else:\n                call_node = frame_info.statement_stack[-1]  # type: ignore\n        return caller_frame, call_node"
    ],
    [
        "STORE_NAME",
        "    def before_expr(self, node, frame):\n        # type: (ast.expr, FrameType) -> None\n        \"\"\"\n        Called right before the expression corresponding to `node` is evaluated\n        within `frame`.\n        \"\"\""
    ],
    [
        "STORE_NAME",
        "    def after_expr(self, node, frame, value, exc_value, exc_tb):\n        # type: (ast.expr, FrameType, Any, Optional[BaseException], Optional[TracebackType]) -> Optional[ChangeValue]\n        \"\"\"\n        Called right after the expression corresponding to `node` is evaluated\n        within `frame`. `value` is the value of the expression, if it succeeded.\n        If the evaluation raised an exception, exc_value will be the exception object\n        and exc_tb the traceback.\n\n        Return `ChangeValue(x)` to change the value of the expression as\n        seen by the rest of the program from `value` to `x`.\n        \"\"\""
    ],
    [
        "STORE_NAME",
        "    def before_stmt(self, node, frame):\n        # type: (ast.stmt, FrameType) -> None\n        \"\"\"\n        Called right before the statement corresponding to `node` is executed\n        within `frame`.\n        \"\"\""
    ],
    [
        "STORE_NAME",
        "    def after_stmt(self, node, frame, exc_value, exc_traceback, exc_node):\n        # type: (ast.stmt, FrameType, Optional[BaseException], Optional[TracebackType], Optional[ast.AST]) -> Optional[bool]\n        \"\"\"\n        Called right after the statement corresponding to `node` is executed\n        within `frame`.\n        If the statement raised an exception, exc_value will be the exception object,\n        exc_tb the traceback, and exc_node the node where the exception was raised\n        (either this statement or an expression within).\n\n        Returning True will suppress any exception raised (as with __exit__ in general).\n        \"\"\""
    ],
    [
        "STORE_NAME",
        "    def enter_call(self, enter_info):\n        # type: (EnterCallInfo) -> None\n        \"\"\"\n        Called before a function call begins executing. For typical `def` functions,\n        this is called before the `before_stmt` for to the first statement in the function.\n        \"\"\""
    ],
    [
        "STORE_NAME",
        "    def exit_call(self, exit_info):\n        # type: (ExitCallInfo) -> None\n        \"\"\"\n        Called after a function call finishes executing. For typical `def` functions,\n        this is called after the `after_stmt` for to the last statement to execute.\n        \"\"\""
    ],
    [
        "STORE_NAME",
        "    def parse_extra(self, root, source, filename):\n        # type: (ast.Module, str, str) -> Optional[ast.Module]\n        \"\"\"\n        Called before the AST (root) is modified to let subclasses make additional changes first.\n        \"\"\""
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.stack"
    ],
    [
        "LOAD_GLOBAL",
        "defaultdict"
    ],
    [
        "LOAD_GLOBAL",
        "list"
    ],
    [
        "CALL",
        "defaultdict(list)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.main_to_secondary_frames"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.secondary_to_main_frames"
    ],
    [
        "LOAD_GLOBAL",
        "TracedFile"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_FAST",
        "source"
    ],
    [
        "LOAD_FAST",
        "filename"
    ],
    [
        "LOAD_FAST",
        "flags"
    ],
    [
        "CALL",
        "TracedFile(self, source, filename, flags)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._treetrace_hidden_with_stmt"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._treetrace_hidden_before_expr"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._treetrace_hidden_after_expr"
    ],
    [
        "CALL",
        "{f.__name__: partial(f, traced_file)\n                for f in [\n                    self._treetrace_hidden_with_stmt,\n                    self._treetrace_hidden_before_expr,\n                    self._treetrace_hidden_after_expr,\n                ]}"
    ],
    [
        "LOAD_FAST",
        "{f.__name__: partial(f, traced_file)\n                for f in [\n                    self._treetrace_hidden_with_stmt,\n                    self._treetrace_hidden_before_expr,\n                    self._treetrace_hidden_after_expr,\n                ]}"
    ],
    [
        "STORE_FAST",
        "f"
    ],
    [
        "LOAD_FAST",
        "f"
    ],
    [
        "LOAD_ATTR",
        "f.__name__"
    ],
    [
        "LOAD_GLOBAL",
        "partial"
    ],
    [
        "LOAD_FAST",
        "f"
    ],
    [
        "LOAD_DEREF",
        "traced_file"
    ],
    [
        "CALL",
        "partial(f, traced_file)"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_DEREF",
        "func"
    ],
    [
        "LOAD_GLOBAL",
        "FunctionType"
    ],
    [
        "CALL",
        "isinstance(func, FunctionType)"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "CALL",
        "ValueError('You can only trace user-defined functions. '\n                             'The birdseye decorator must be applied first, '\n                             'at the bottom of the list.')"
    ],
    [
        "LOAD_GLOBAL",
        "inspect"
    ],
    [
        "LOAD_ATTR",
        "inspect.iscoroutinefunction"
    ],
    [
        "LOAD_DEREF",
        "func"
    ],
    [
        "CALL",
        "inspect.iscoroutinefunction(func)"
    ],
    [
        "LOAD_GLOBAL",
        "inspect"
    ],
    [
        "LOAD_ATTR",
        "inspect.isasyncgenfunction"
    ],
    [
        "LOAD_DEREF",
        "func"
    ],
    [
        "CALL",
        "inspect.isasyncgenfunction(func)"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "CALL",
        "ValueError('You cannot trace async functions')"
    ],
    [
        "LOAD_GLOBAL",
        "is_lambda"
    ],
    [
        "LOAD_DEREF",
        "func"
    ],
    [
        "CALL",
        "is_lambda(func)"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "CALL",
        "ValueError('You cannot trace lambdas')"
    ],
    [
        "LOAD_GLOBAL",
        "inspect"
    ],
    [
        "LOAD_ATTR",
        "inspect.getsourcefile"
    ],
    [
        "LOAD_DEREF",
        "func"
    ],
    [
        "CALL",
        "inspect.getsourcefile(func)"
    ],
    [
        "STORE_FAST",
        "filename"
    ],
    [
        "LOAD_GLOBAL",
        "is_ipython_cell"
    ],
    [
        "LOAD_FAST",
        "filename"
    ],
    [
        "CALL",
        "is_ipython_cell(filename)"
    ],
    [
        "STORE_FAST",
        "from IPython import get_ipython"
    ],
    [
        "STORE_FAST",
        "import linecache"
    ],
    [
        "LOAD_FAST",
        "get_ipython"
    ],
    [
        "CALL",
        "get_ipython()"
    ],
    [
        "LOAD_ATTR",
        "get_ipython().compile"
    ],
    [
        "LOAD_ATTR",
        "get_ipython().compile.flags"
    ],
    [
        "STORE_FAST",
        "flags"
    ],
    [
        "LOAD_ATTR",
        "''.join"
    ],
    [
        "LOAD_FAST",
        "linecache"
    ],
    [
        "LOAD_ATTR",
        "linecache.cache"
    ],
    [
        "LOAD_FAST",
        "filename"
    ],
    [
        "BINARY_SUBSCR",
        "linecache.cache[filename]"
    ],
    [
        "BINARY_SUBSCR",
        "linecache.cache[filename][2]"
    ],
    [
        "CALL",
        "''.join(linecache.cache[filename][2])"
    ],
    [
        "STORE_FAST",
        "source"
    ],
    [
        "LOAD_GLOBAL",
        "read_source_file"
    ],
    [
        "LOAD_FAST",
        "filename"
    ],
    [
        "CALL",
        "read_source_file(filename)"
    ],
    [
        "STORE_FAST",
        "source"
    ],
    [
        "STORE_FAST",
        "flags"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.compile"
    ],
    [
        "LOAD_FAST",
        "source"
    ],
    [
        "LOAD_FAST",
        "filename"
    ],
    [
        "LOAD_FAST",
        "flags"
    ],
    [
        "CALL",
        "self.compile(source, filename, flags)"
    ],
    [
        "STORE_FAST",
        "traced_file"
    ],
    [
        "LOAD_DEREF",
        "func"
    ],
    [
        "LOAD_ATTR",
        "func.__dict__"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "CALL",
        "ValueError('The birdseye decorator must be applied first, '\n                             'at the bottom of the list.')"
    ],
    [
        "STORE_DEREF",
        "code_options"
    ],
    [
        "STORE_DEREF",
        "        def find_code(root_code):\n            # type: (CodeType) -> None\n            for const in root_code.co_consts:  # type: CodeType\n                if not inspect.iscode(const):\n                    continue\n                matches = (const.co_firstlineno == func.__code__.co_firstlineno and\n                           const.co_name == func.__code__.co_name)\n                if matches:\n                    code_options.append(const)\n                find_code(const)"
    ],
    [
        "LOAD_DEREF",
        "find_code"
    ],
    [
        "LOAD_FAST",
        "traced_file"
    ],
    [
        "LOAD_ATTR",
        "traced_file.code"
    ],
    [
        "CALL",
        "find_code(traced_file.code)"
    ],
    [
        "LOAD_GLOBAL",
        "len"
    ],
    [
        "LOAD_DEREF",
        "code_options"
    ],
    [
        "CALL",
        "len(code_options)"
    ],
    [
        "COMPARE_OP",
        "len(code_options) > 1"
    ],
    [
        "LOAD_GLOBAL",
        "is_lambda"
    ],
    [
        "LOAD_DEREF",
        "func"
    ],
    [
        "CALL",
        "is_lambda(func)"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "CALL",
        "ValueError(\"Failed to trace lambda. Convert the function to a def.\")"
    ],
    [
        "LOAD_DEREF",
        "code_options"
    ],
    [
        "BINARY_SUBSCR",
        "code_options[0]"
    ],
    [
        "STORE_FAST",
        "new_func_code"
    ],
    [
        "LOAD_DEREF",
        "func"
    ],
    [
        "LOAD_ATTR",
        "func.__globals__"
    ],
    [
        "LOAD_ATTR",
        "func.__globals__.update"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._trace_methods_dict"
    ],
    [
        "LOAD_FAST",
        "traced_file"
    ],
    [
        "CALL",
        "self._trace_methods_dict(traced_file)"
    ],
    [
        "CALL",
        "func.__globals__.update(self._trace_methods_dict(traced_file))"
    ],
    [
        "LOAD_GLOBAL",
        "FunctionType"
    ],
    [
        "LOAD_FAST",
        "new_func_code"
    ],
    [
        "LOAD_DEREF",
        "func"
    ],
    [
        "LOAD_ATTR",
        "func.__globals__"
    ],
    [
        "LOAD_DEREF",
        "func"
    ],
    [
        "LOAD_ATTR",
        "func.__name__"
    ],
    [
        "LOAD_DEREF",
        "func"
    ],
    [
        "LOAD_ATTR",
        "func.__defaults__"
    ],
    [
        "LOAD_DEREF",
        "func"
    ],
    [
        "LOAD_ATTR",
        "func.__closure__"
    ],
    [
        "CALL",
        "FunctionType(new_func_code, func.__globals__, func.__name__, func.__defaults__, func.__closure__)"
    ],
    [
        "STORE_FAST",
        "new_func"
    ],
    [
        "LOAD_GLOBAL",
        "update_wrapper"
    ],
    [
        "LOAD_FAST",
        "new_func"
    ],
    [
        "LOAD_DEREF",
        "func"
    ],
    [
        "CALL",
        "update_wrapper(new_func, func)"
    ],
    [
        "LOAD_GLOBAL",
        "PY3"
    ],
    [
        "LOAD_GLOBAL",
        "getattr"
    ],
    [
        "LOAD_DEREF",
        "func"
    ],
    [
        "CALL",
        "getattr(func, '__kwdefaults__', None)"
    ],
    [
        "LOAD_FAST",
        "new_func"
    ],
    [
        "STORE_ATTR",
        "new_func.__kwdefaults__"
    ],
    [
        "LOAD_FAST",
        "traced_file"
    ],
    [
        "LOAD_FAST",
        "new_func"
    ],
    [
        "STORE_ATTR",
        "new_func.traced_file"
    ],
    [
        "LOAD_FAST",
        "new_func"
    ],
    [
        "LOAD_GLOBAL",
        "AttributeError"
    ],
    [
        "LOAD_FAST",
        "root_code"
    ],
    [
        "LOAD_ATTR",
        "root_code.co_consts"
    ],
    [
        "STORE_FAST",
        "const"
    ],
    [
        "LOAD_GLOBAL",
        "inspect"
    ],
    [
        "LOAD_ATTR",
        "inspect.iscode"
    ],
    [
        "LOAD_FAST",
        "const"
    ],
    [
        "CALL",
        "inspect.iscode(const)"
    ],
    [
        "LOAD_FAST",
        "const"
    ],
    [
        "LOAD_ATTR",
        "const.co_firstlineno"
    ],
    [
        "LOAD_DEREF",
        "func"
    ],
    [
        "LOAD_ATTR",
        "func.__code__"
    ],
    [
        "LOAD_ATTR",
        "func.__code__.co_firstlineno"
    ],
    [
        "COMPARE_OP",
        "const.co_firstlineno == func.__code__.co_firstlineno"
    ],
    [
        "LOAD_FAST",
        "const"
    ],
    [
        "LOAD_ATTR",
        "const.co_name"
    ],
    [
        "LOAD_DEREF",
        "func"
    ],
    [
        "LOAD_ATTR",
        "func.__code__"
    ],
    [
        "LOAD_ATTR",
        "func.__code__.co_name"
    ],
    [
        "COMPARE_OP",
        "const.co_name == func.__code__.co_name"
    ],
    [
        "STORE_FAST",
        "matches"
    ],
    [
        "LOAD_FAST",
        "matches"
    ],
    [
        "LOAD_DEREF",
        "code_options"
    ],
    [
        "LOAD_ATTR",
        "code_options.append"
    ],
    [
        "LOAD_FAST",
        "const"
    ],
    [
        "CALL",
        "code_options.append(const)"
    ],
    [
        "LOAD_DEREF",
        "find_code"
    ],
    [
        "LOAD_FAST",
        "const"
    ],
    [
        "CALL",
        "find_code(const)"
    ],
    [
        "LOAD_GLOBAL",
        "inspect"
    ],
    [
        "LOAD_ATTR",
        "inspect.isclass"
    ],
    [
        "LOAD_FAST",
        "func"
    ],
    [
        "CALL",
        "inspect.isclass(func)"
    ],
    [
        "LOAD_GLOBAL",
        "TypeError"
    ],
    [
        "CALL",
        "TypeError('Decorating classes is no longer supported')"
    ],
    [
        "LOAD_FAST",
        "func"
    ],
    [
        "LOAD_DEREF",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.trace_function"
    ],
    [
        "LOAD_FAST",
        "func"
    ],
    [
        "CALL",
        "self.trace_function(func)"
    ],
    [
        "LOAD_FAST",
        "optional"
    ],
    [
        "LOAD_DEREF",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.trace_function"
    ],
    [
        "STORE_FAST",
        "        def decorator(actual_func):\n\n            traced = self.trace_function(actual_func)\n\n            @wraps(actual_func)\n            def wrapper(*args, **kwargs):\n                trace_call = kwargs.pop('trace_call', False)\n                if trace_call:\n                    f = traced\n                else:\n                    f = actual_func\n                return f(*args, **kwargs)\n\n            return wrapper"
    ],
    [
        "LOAD_FAST",
        "decorator"
    ],
    [
        "LOAD_DEREF",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.trace_function"
    ],
    [
        "LOAD_DEREF",
        "actual_func"
    ],
    [
        "CALL",
        "self.trace_function(actual_func)"
    ],
    [
        "STORE_DEREF",
        "traced"
    ],
    [
        "LOAD_GLOBAL",
        "wraps"
    ],
    [
        "LOAD_DEREF",
        "actual_func"
    ],
    [
        "CALL",
        "wraps(actual_func)"
    ],
    [
        "CALL",
        "wraps(actual_func)"
    ],
    [
        "STORE_FAST",
        "            @wraps(actual_func)\n            def wrapper(*args, **kwargs):\n                trace_call = kwargs.pop('trace_call', False)\n                if trace_call:\n                    f = traced\n                else:\n                    f = actual_func\n                return f(*args, **kwargs)"
    ],
    [
        "LOAD_FAST",
        "wrapper"
    ],
    [
        "LOAD_FAST",
        "kwargs"
    ],
    [
        "LOAD_ATTR",
        "kwargs.pop"
    ],
    [
        "CALL",
        "kwargs.pop('trace_call', False)"
    ],
    [
        "STORE_FAST",
        "trace_call"
    ],
    [
        "LOAD_FAST",
        "trace_call"
    ],
    [
        "LOAD_DEREF",
        "traced"
    ],
    [
        "STORE_FAST",
        "f"
    ],
    [
        "LOAD_DEREF",
        "actual_func"
    ],
    [
        "STORE_FAST",
        "f"
    ],
    [
        "LOAD_FAST",
        "f"
    ],
    [
        "LOAD_FAST",
        "args"
    ],
    [
        "LOAD_FAST",
        "kwargs"
    ],
    [
        "CALL_FUNCTION_EX",
        "f(*args, **kwargs)"
    ],
    [
        "LOAD_GLOBAL",
        "sys"
    ],
    [
        "LOAD_ATTR",
        "sys._getframe"
    ],
    [
        "CALL",
        "sys._getframe(2)"
    ],
    [
        "STORE_FAST",
        "frame"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.secondary_to_main_frames"
    ],
    [
        "LOAD_ATTR",
        "self.secondary_to_main_frames.get"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "CALL",
        "self.secondary_to_main_frames.get(frame)"
    ],
    [
        "STORE_FAST",
        "result"
    ],
    [
        "LOAD_FAST",
        "result"
    ],
    [
        "LOAD_FAST",
        "result"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "STORE_FAST",
        "original_frame"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "LOAD_ATTR",
        "frame.f_code"
    ],
    [
        "LOAD_ATTR",
        "frame.f_code.co_name"
    ],
    [
        "CONTAINS_OP",
        "frame.f_code.co_name in ('<listcomp>', '<dictcomp>', '<setcomp>')"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "LOAD_ATTR",
        "frame.f_back"
    ],
    [
        "STORE_FAST",
        "frame"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "LOAD_ATTR",
        "frame.f_code"
    ],
    [
        "LOAD_ATTR",
        "frame.f_code.co_name"
    ],
    [
        "CONTAINS_OP",
        "frame.f_code.co_name in ('<listcomp>', '<dictcomp>', '<setcomp>')"
    ],
    [
        "LOAD_GLOBAL",
        "ancestors"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "CALL",
        "ancestors(node)"
    ],
    [
        "STORE_FAST",
        "node"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.FunctionDef"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.Lambda"
    ],
    [
        "CALL",
        "isinstance(node, (ast.FunctionDef, ast.Lambda))"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.ClassDef"
    ],
    [
        "CALL",
        "isinstance(node, ast.ClassDef)"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "LOAD_ATTR",
        "frame.f_back"
    ],
    [
        "STORE_FAST",
        "frame"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "LOAD_ATTR",
        "frame.f_code"
    ],
    [
        "LOAD_ATTR",
        "frame.f_code.co_name"
    ],
    [
        "CONTAINS_OP",
        "frame.f_code.co_name in ('<lambda>', '<genexpr>')"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.secondary_to_main_frames"
    ],
    [
        "LOAD_FAST",
        "original_frame"
    ],
    [
        "STORE_SUBSCR",
        "self.secondary_to_main_frames[original_frame]"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.main_to_secondary_frames"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "BINARY_SUBSCR",
        "self.main_to_secondary_frames[frame]"
    ],
    [
        "LOAD_ATTR",
        "self.main_to_secondary_frames[frame].append"
    ],
    [
        "LOAD_FAST",
        "original_frame"
    ],
    [
        "CALL",
        "self.main_to_secondary_frames[frame].append(original_frame)"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "LOAD_FAST",
        "traced_file"
    ],
    [
        "LOAD_ATTR",
        "traced_file.nodes"
    ],
    [
        "LOAD_FAST",
        "_tree_index"
    ],
    [
        "BINARY_SUBSCR",
        "traced_file.nodes[_tree_index]"
    ],
    [
        "STORE_FAST",
        "node"
    ],
    [
        "LOAD_GLOBAL",
        "cast"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.stmt"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "CALL",
        "cast(ast.stmt, node)"
    ],
    [
        "STORE_FAST",
        "node"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._main_frame"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "CALL",
        "self._main_frame(node)"
    ],
    [
        "STORE_FAST",
        "frame"
    ],
    [
        "LOAD_GLOBAL",
        "_StmtContext"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "CALL",
        "_StmtContext(self, node, frame)"
    ],
    [
        "LOAD_FAST",
        "traced_file"
    ],
    [
        "LOAD_ATTR",
        "traced_file.nodes"
    ],
    [
        "LOAD_FAST",
        "_tree_index"
    ],
    [
        "BINARY_SUBSCR",
        "traced_file.nodes[_tree_index]"
    ],
    [
        "STORE_FAST",
        "node"
    ],
    [
        "LOAD_GLOBAL",
        "cast"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.expr"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "CALL",
        "cast(ast.expr, node)"
    ],
    [
        "STORE_FAST",
        "node"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._main_frame"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "CALL",
        "self._main_frame(node)"
    ],
    [
        "STORE_FAST",
        "frame"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.stack"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "BINARY_SUBSCR",
        "self.stack[frame]"
    ],
    [
        "STORE_FAST",
        "frame_info"
    ],
    [
        "LOAD_FAST",
        "frame_info"
    ],
    [
        "LOAD_ATTR",
        "frame_info.expression_stack"
    ],
    [
        "LOAD_ATTR",
        "frame_info.expression_stack.append"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "CALL",
        "frame_info.expression_stack.append(node)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.before_expr"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "CALL",
        "self.before_expr(node, frame)"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._main_frame"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "CALL",
        "self._main_frame(node)"
    ],
    [
        "STORE_FAST",
        "frame"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "LOAD_FAST",
        "value"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._after_expr"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "LOAD_FAST",
        "value"
    ],
    [
        "CALL",
        "self._after_expr(node, frame, value, None, None)"
    ],
    [
        "STORE_FAST",
        "result"
    ],
    [
        "LOAD_FAST",
        "result"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "result"
    ],
    [
        "LOAD_GLOBAL",
        "ChangeValue"
    ],
    [
        "CALL",
        "isinstance(result, ChangeValue)"
    ],
    [
        "LOAD_FAST",
        "result"
    ],
    [
        "LOAD_ATTR",
        "result.value"
    ],
    [
        "STORE_FAST",
        "value"
    ],
    [
        "LOAD_FAST",
        "value"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.stack"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "BINARY_SUBSCR",
        "self.stack[frame]"
    ],
    [
        "STORE_FAST",
        "frame_info"
    ],
    [
        "LOAD_FAST",
        "frame_info"
    ],
    [
        "LOAD_ATTR",
        "frame_info.expression_stack"
    ],
    [
        "LOAD_ATTR",
        "frame_info.expression_stack.pop"
    ],
    [
        "CALL",
        "frame_info.expression_stack.pop()"
    ],
    [
        "LOAD_FAST",
        "value"
    ],
    [
        "LOAD_FAST",
        "frame_info"
    ],
    [
        "LOAD_ATTR",
        "frame_info.expression_values"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "STORE_SUBSCR",
        "frame_info.expression_values[node]"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.after_expr"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "LOAD_FAST",
        "value"
    ],
    [
        "LOAD_FAST",
        "exc_value"
    ],
    [
        "LOAD_FAST",
        "exc_tb"
    ],
    [
        "CALL",
        "self.after_expr(node, frame, value, exc_value, exc_tb)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._get_caller_stuff"
    ],
    [
        "LOAD_FAST",
        "current_frame"
    ],
    [
        "CALL",
        "self._get_caller_stuff(current_frame)"
    ],
    [
        "STORE_FAST",
        "caller_frame"
    ],
    [
        "STORE_FAST",
        "call_node"
    ],
    [
        "LOAD_GLOBAL",
        "FrameInfo"
    ],
    [
        "CALL",
        "FrameInfo()"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.stack"
    ],
    [
        "LOAD_FAST",
        "current_frame"
    ],
    [
        "STORE_SUBSCR",
        "self.stack[current_frame]"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.enter_call"
    ],
    [
        "LOAD_GLOBAL",
        "EnterCallInfo"
    ],
    [
        "LOAD_FAST",
        "call_node"
    ],
    [
        "LOAD_FAST",
        "enter_node"
    ],
    [
        "LOAD_FAST",
        "caller_frame"
    ],
    [
        "LOAD_FAST",
        "current_frame"
    ],
    [
        "CALL",
        "EnterCallInfo(call_node, enter_node, caller_frame, current_frame)"
    ],
    [
        "CALL",
        "self.enter_call(EnterCallInfo(call_node, enter_node, caller_frame, current_frame))"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "LOAD_ATTR",
        "frame.f_back"
    ],
    [
        "STORE_FAST",
        "caller_frame"
    ],
    [
        "STORE_FAST",
        "call_node"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.secondary_to_main_frames"
    ],
    [
        "LOAD_ATTR",
        "self.secondary_to_main_frames.get"
    ],
    [
        "LOAD_FAST",
        "caller_frame"
    ],
    [
        "CALL",
        "self.secondary_to_main_frames.get(caller_frame)"
    ],
    [
        "STORE_FAST",
        "main_frame"
    ],
    [
        "LOAD_FAST",
        "main_frame"
    ],
    [
        "LOAD_FAST",
        "main_frame"
    ],
    [
        "STORE_FAST",
        "caller_frame"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.stack"
    ],
    [
        "LOAD_FAST",
        "caller_frame"
    ],
    [
        "BINARY_SUBSCR",
        "self.stack[caller_frame]"
    ],
    [
        "STORE_FAST",
        "frame_info"
    ],
    [
        "LOAD_FAST",
        "frame_info"
    ],
    [
        "LOAD_ATTR",
        "frame_info.expression_stack"
    ],
    [
        "STORE_FAST",
        "expression_stack"
    ],
    [
        "LOAD_FAST",
        "expression_stack"
    ],
    [
        "LOAD_FAST",
        "expression_stack"
    ],
    [
        "BINARY_SUBSCR",
        "expression_stack[-1]"
    ],
    [
        "STORE_FAST",
        "call_node"
    ],
    [
        "LOAD_FAST",
        "caller_frame"
    ],
    [
        "LOAD_FAST",
        "call_node"
    ],
    [
        "LOAD_FAST",
        "frame_info"
    ],
    [
        "LOAD_ATTR",
        "frame_info.statement_stack"
    ],
    [
        "BINARY_SUBSCR",
        "frame_info.statement_stack[-1]"
    ],
    [
        "STORE_FAST",
        "call_node"
    ],
    [
        "LOAD_FAST",
        "caller_frame"
    ],
    [
        "LOAD_FAST",
        "call_node"
    ],
    [
        "STORE_NAME",
        "\"\"\"\n    This does the AST modifications that call the hooks.\n    \"\"\""
    ],
    [
        "STORE_NAME",
        "    def generic_visit(self, node):\n        # type: (ast.AST) -> ast.AST\n        if not getattr(node, '_visit_ignore', False):\n            if (isinstance(node, ast.expr) and\n                    not (hasattr(node, \"ctx\") and not isinstance(node.ctx, ast.Load)) and\n                    not isinstance(node, getattr(ast, 'Starred', ()))):\n                return self.visit_expr(node)\n            if isinstance(node, ast.stmt):\n                return self.visit_stmt(node)\n        return super(_NodeVisitor, self).generic_visit(node)"
    ],
    [
        "STORE_NAME",
        "    def visit_expr(self, node):\n        # type: (ast.expr) -> ast.Call\n        \"\"\"\n        each expression e gets wrapped like this:\n            _treetrace_hidden_after_expr(_treetrace_hidden_before_expr(_tree_index), e)\n\n        where the _treetrace_* functions are the corresponding methods with the\n        TreeTracerBase and traced_file arguments already filled in (see _trace_methods_dict)\n        \"\"\"\n\n        before_marker = self._create_simple_marker_call(node, TreeTracerBase._treetrace_hidden_before_expr)\n        ast.copy_location(before_marker, node)\n\n        after_marker = ast.Call(\n            func=ast.Name(id=TreeTracerBase._treetrace_hidden_after_expr.__name__,\n                          ctx=ast.Load()),\n            args=[\n                before_marker,\n                super(_NodeVisitor, self).generic_visit(node),\n            ],\n            keywords=[],\n        )\n        ast.copy_location(after_marker, node)\n        ast.fix_missing_locations(after_marker)\n\n        return after_marker"
    ],
    [
        "STORE_NAME",
        "    def visit_stmt(self, node):\n        # type: (ast.stmt) -> ast.With\n        \"\"\"\n        Every statement in the original code becomes:\n\n        with _treetrace_hidden_with_stmt(_tree_index):\n            <statement>\n\n        where the _treetrace_hidden_with_stmt function is the the corresponding method with the\n        TreeTracerBase and traced_file arguments already filled in (see _trace_methods_dict)\n        \"\"\"\n        context_expr = self._create_simple_marker_call(\n            super(_NodeVisitor, self).generic_visit(node),\n            TreeTracerBase._treetrace_hidden_with_stmt)\n\n        if PY3:\n            wrapped = ast.With(\n                items=[ast.withitem(context_expr=context_expr)],\n                body=[node],\n            )\n        else:\n            wrapped = ast.With(\n                context_expr=context_expr,\n                body=[node],\n            )\n        ast.copy_location(wrapped, node)\n        ast.fix_missing_locations(wrapped)\n        return wrapped"
    ],
    [
        "LOAD_NAME",
        "staticmethod"
    ],
    [
        "CALL",
        "staticmethod"
    ],
    [
        "STORE_NAME",
        "    @staticmethod\n    def _create_simple_marker_call(node, func):\n        # type: (ast.AST, Callable) -> ast.Call\n        \"\"\"\n        Returns a Call node representing `func(node._tree_index)`\n        where node._tree_index is a numerical literal which allows the node object\n        to be retrieved later through the nodes attribute of a TracedFile.\n        \"\"\"\n        return ast.Call(\n            func=ast.Name(id=func.__name__,\n                          ctx=ast.Load()),\n            args=[ast.Num(node._tree_index)],\n            keywords=[],\n        )"
    ],
    [
        "LOAD_GLOBAL",
        "getattr"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "CALL",
        "getattr(node, '_visit_ignore', False)"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.expr"
    ],
    [
        "CALL",
        "isinstance(node, ast.expr)"
    ],
    [
        "LOAD_GLOBAL",
        "hasattr"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "CALL",
        "hasattr(node, \"ctx\")"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node.ctx"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.Load"
    ],
    [
        "CALL",
        "isinstance(node.ctx, ast.Load)"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_GLOBAL",
        "getattr"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "CALL",
        "getattr(ast, 'Starred', ())"
    ],
    [
        "CALL",
        "isinstance(node, getattr(ast, 'Starred', ()))"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.visit_expr"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "CALL",
        "self.visit_expr(node)"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.stmt"
    ],
    [
        "CALL",
        "isinstance(node, ast.stmt)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.visit_stmt"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "CALL",
        "self.visit_stmt(node)"
    ],
    [
        "LOAD_GLOBAL",
        "super"
    ],
    [
        "LOAD_GLOBAL",
        "_NodeVisitor"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "CALL",
        "super(_NodeVisitor, self)"
    ],
    [
        "LOAD_ATTR",
        "super(_NodeVisitor, self).generic_visit"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "CALL",
        "super(_NodeVisitor, self).generic_visit(node)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._create_simple_marker_call"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_GLOBAL",
        "TreeTracerBase"
    ],
    [
        "LOAD_ATTR",
        "TreeTracerBase._treetrace_hidden_before_expr"
    ],
    [
        "CALL",
        "self._create_simple_marker_call(node, TreeTracerBase._treetrace_hidden_before_expr)"
    ],
    [
        "STORE_FAST",
        "before_marker"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.copy_location"
    ],
    [
        "LOAD_FAST",
        "before_marker"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "CALL",
        "ast.copy_location(before_marker, node)"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.Call"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.Name"
    ],
    [
        "LOAD_GLOBAL",
        "TreeTracerBase"
    ],
    [
        "LOAD_ATTR",
        "TreeTracerBase._treetrace_hidden_after_expr"
    ],
    [
        "LOAD_ATTR",
        "TreeTracerBase._treetrace_hidden_after_expr.__name__"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.Load"
    ],
    [
        "CALL",
        "ast.Load()"
    ],
    [
        "CALL",
        "ast.Name(id=TreeTracerBase._treetrace_hidden_after_expr.__name__,\n                          ctx=ast.Load())"
    ],
    [
        "LOAD_FAST",
        "before_marker"
    ],
    [
        "LOAD_GLOBAL",
        "super"
    ],
    [
        "LOAD_GLOBAL",
        "_NodeVisitor"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "CALL",
        "super(_NodeVisitor, self)"
    ],
    [
        "LOAD_ATTR",
        "super(_NodeVisitor, self).generic_visit"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "CALL",
        "super(_NodeVisitor, self).generic_visit(node)"
    ],
    [
        "CALL",
        "ast.Call(\n            func=ast.Name(id=TreeTracerBase._treetrace_hidden_after_expr.__name__,\n                          ctx=ast.Load()),\n            args=[\n                before_marker,\n                super(_NodeVisitor, self).generic_visit(node),\n            ],\n            keywords=[],\n        )"
    ],
    [
        "STORE_FAST",
        "after_marker"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.copy_location"
    ],
    [
        "LOAD_FAST",
        "after_marker"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "CALL",
        "ast.copy_location(after_marker, node)"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.fix_missing_locations"
    ],
    [
        "LOAD_FAST",
        "after_marker"
    ],
    [
        "CALL",
        "ast.fix_missing_locations(after_marker)"
    ],
    [
        "LOAD_FAST",
        "after_marker"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._create_simple_marker_call"
    ],
    [
        "LOAD_GLOBAL",
        "super"
    ],
    [
        "LOAD_GLOBAL",
        "_NodeVisitor"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "CALL",
        "super(_NodeVisitor, self)"
    ],
    [
        "LOAD_ATTR",
        "super(_NodeVisitor, self).generic_visit"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "CALL",
        "super(_NodeVisitor, self).generic_visit(node)"
    ],
    [
        "LOAD_GLOBAL",
        "TreeTracerBase"
    ],
    [
        "LOAD_ATTR",
        "TreeTracerBase._treetrace_hidden_with_stmt"
    ],
    [
        "CALL",
        "self._create_simple_marker_call(\n            super(_NodeVisitor, self).generic_visit(node),\n            TreeTracerBase._treetrace_hidden_with_stmt)"
    ],
    [
        "STORE_FAST",
        "context_expr"
    ],
    [
        "LOAD_GLOBAL",
        "PY3"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.With"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.withitem"
    ],
    [
        "LOAD_FAST",
        "context_expr"
    ],
    [
        "CALL",
        "ast.withitem(context_expr=context_expr)"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "CALL",
        "ast.With(\n                items=[ast.withitem(context_expr=context_expr)],\n                body=[node],\n            )"
    ],
    [
        "STORE_FAST",
        "wrapped"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.With"
    ],
    [
        "LOAD_FAST",
        "context_expr"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "CALL",
        "ast.With(\n                context_expr=context_expr,\n                body=[node],\n            )"
    ],
    [
        "STORE_FAST",
        "wrapped"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.copy_location"
    ],
    [
        "LOAD_FAST",
        "wrapped"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "CALL",
        "ast.copy_location(wrapped, node)"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.fix_missing_locations"
    ],
    [
        "LOAD_FAST",
        "wrapped"
    ],
    [
        "CALL",
        "ast.fix_missing_locations(wrapped)"
    ],
    [
        "LOAD_FAST",
        "wrapped"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.Call"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.Name"
    ],
    [
        "LOAD_FAST",
        "func"
    ],
    [
        "LOAD_ATTR",
        "func.__name__"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.Load"
    ],
    [
        "CALL",
        "ast.Load()"
    ],
    [
        "CALL",
        "ast.Name(id=func.__name__,\n                          ctx=ast.Load())"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.Num"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node._tree_index"
    ],
    [
        "CALL",
        "ast.Num(node._tree_index)"
    ],
    [
        "CALL",
        "ast.Call(\n            func=ast.Name(id=func.__name__,\n                          ctx=ast.Load()),\n            args=[ast.Num(node._tree_index)],\n            keywords=[],\n        )"
    ],
    [
        "STORE_NAME",
        "__slots__"
    ],
    [
        "STORE_NAME",
        "    def __init__(self, tracer, node, frame):\n        # type: (TreeTracerBase, ast.stmt, FrameType) -> None\n        self.tracer = tracer\n        self.node = node\n        self.frame = frame"
    ],
    [
        "STORE_NAME",
        "    def __enter__(self):\n        tracer = self.tracer\n        node = self.node\n        frame = self.frame\n        if getattr(node, '_enter_call_node', False):\n            tracer._enter_call(node, frame)\n        frame_info = tracer.stack[frame]\n        frame_info.expression_stack = []\n        frame_info.statement_stack.append(node)\n        tracer.before_stmt(node, frame)"
    ],
    [
        "STORE_NAME",
        "    def __exit__(self, exc_type, exc_val, exc_tb):\n        # type: (Type[Exception], Exception, TracebackType) -> bool\n        node = self.node\n        tracer = self.tracer\n        frame = self.frame\n        frame_info = tracer.stack[frame]\n\n        frame_info.statement_stack.pop()\n\n        exc_node = None  # type: Optional[Union[ast.expr, ast.stmt]]\n        if exc_val and exc_val is not frame_info.exc_value:\n            exc_node = node\n            frame_info.exc_value = exc_val\n\n            # Call the after_expr hook if the exception was raised by an expression\n            expression_stack = frame_info.expression_stack\n            if expression_stack:\n                exc_node = expression_stack[-1]\n                tracer._after_expr(exc_node, frame, None, exc_val, exc_tb)\n\n        result = tracer.after_stmt(node, frame, exc_val, exc_tb, exc_node)\n\n        if isinstance(node, ast.Return):\n            frame_info.return_node = node\n\n        parent = node.parent  # type: ast.AST\n        return_node = frame_info.return_node\n        exiting = (isinstance(parent, (ast.FunctionDef, ast.Module)) and\n                   (node is parent.body[-1] or\n                    exc_val or\n                    return_node))\n        if exiting:\n            caller_frame, call_node = tracer._get_caller_stuff(frame)\n            return_value = None\n            if return_node and return_node.value and not exc_val:\n                return_value = frame_info.expression_values[return_node.value]\n            tracer.exit_call(ExitCallInfo(call_node,\n                                          return_node,\n                                          caller_frame,\n                                          frame,\n                                          return_value,\n                                          exc_val,\n                                          exc_tb\n                                          ))\n\n            del tracer.stack[frame]\n            for secondary_frame in self.tracer.main_to_secondary_frames.pop(frame):\n                del self.tracer.secondary_to_main_frames[secondary_frame]\n\n        return result"
    ],
    [
        "LOAD_FAST",
        "tracer"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.tracer"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.node"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.frame"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.tracer"
    ],
    [
        "STORE_FAST",
        "tracer"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.node"
    ],
    [
        "STORE_FAST",
        "node"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.frame"
    ],
    [
        "STORE_FAST",
        "frame"
    ],
    [
        "LOAD_GLOBAL",
        "getattr"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "CALL",
        "getattr(node, '_enter_call_node', False)"
    ],
    [
        "LOAD_FAST",
        "tracer"
    ],
    [
        "LOAD_ATTR",
        "tracer._enter_call"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "CALL",
        "tracer._enter_call(node, frame)"
    ],
    [
        "LOAD_FAST",
        "tracer"
    ],
    [
        "LOAD_ATTR",
        "tracer.stack"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "BINARY_SUBSCR",
        "tracer.stack[frame]"
    ],
    [
        "STORE_FAST",
        "frame_info"
    ],
    [
        "LOAD_FAST",
        "frame_info"
    ],
    [
        "STORE_ATTR",
        "frame_info.expression_stack"
    ],
    [
        "LOAD_FAST",
        "frame_info"
    ],
    [
        "LOAD_ATTR",
        "frame_info.statement_stack"
    ],
    [
        "LOAD_ATTR",
        "frame_info.statement_stack.append"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "CALL",
        "frame_info.statement_stack.append(node)"
    ],
    [
        "LOAD_FAST",
        "tracer"
    ],
    [
        "LOAD_ATTR",
        "tracer.before_stmt"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "CALL",
        "tracer.before_stmt(node, frame)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.node"
    ],
    [
        "STORE_FAST",
        "node"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.tracer"
    ],
    [
        "STORE_FAST",
        "tracer"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.frame"
    ],
    [
        "STORE_FAST",
        "frame"
    ],
    [
        "LOAD_FAST",
        "tracer"
    ],
    [
        "LOAD_ATTR",
        "tracer.stack"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "BINARY_SUBSCR",
        "tracer.stack[frame]"
    ],
    [
        "STORE_FAST",
        "frame_info"
    ],
    [
        "LOAD_FAST",
        "frame_info"
    ],
    [
        "LOAD_ATTR",
        "frame_info.statement_stack"
    ],
    [
        "LOAD_ATTR",
        "frame_info.statement_stack.pop"
    ],
    [
        "CALL",
        "frame_info.statement_stack.pop()"
    ],
    [
        "STORE_FAST",
        "exc_node"
    ],
    [
        "LOAD_FAST",
        "exc_val"
    ],
    [
        "LOAD_FAST",
        "exc_val"
    ],
    [
        "LOAD_FAST",
        "frame_info"
    ],
    [
        "LOAD_ATTR",
        "frame_info.exc_value"
    ],
    [
        "IS_OP",
        "exc_val is not frame_info.exc_value"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "STORE_FAST",
        "exc_node"
    ],
    [
        "LOAD_FAST",
        "exc_val"
    ],
    [
        "LOAD_FAST",
        "frame_info"
    ],
    [
        "STORE_ATTR",
        "frame_info.exc_value"
    ],
    [
        "LOAD_FAST",
        "frame_info"
    ],
    [
        "LOAD_ATTR",
        "frame_info.expression_stack"
    ],
    [
        "STORE_FAST",
        "expression_stack"
    ],
    [
        "LOAD_FAST",
        "expression_stack"
    ],
    [
        "LOAD_FAST",
        "expression_stack"
    ],
    [
        "BINARY_SUBSCR",
        "expression_stack[-1]"
    ],
    [
        "STORE_FAST",
        "exc_node"
    ],
    [
        "LOAD_FAST",
        "tracer"
    ],
    [
        "LOAD_ATTR",
        "tracer._after_expr"
    ],
    [
        "LOAD_FAST",
        "exc_node"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "LOAD_FAST",
        "exc_val"
    ],
    [
        "LOAD_FAST",
        "exc_tb"
    ],
    [
        "CALL",
        "tracer._after_expr(exc_node, frame, None, exc_val, exc_tb)"
    ],
    [
        "LOAD_FAST",
        "tracer"
    ],
    [
        "LOAD_ATTR",
        "tracer.after_stmt"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "LOAD_FAST",
        "exc_val"
    ],
    [
        "LOAD_FAST",
        "exc_tb"
    ],
    [
        "LOAD_FAST",
        "exc_node"
    ],
    [
        "CALL",
        "tracer.after_stmt(node, frame, exc_val, exc_tb, exc_node)"
    ],
    [
        "STORE_FAST",
        "result"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.Return"
    ],
    [
        "CALL",
        "isinstance(node, ast.Return)"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_FAST",
        "frame_info"
    ],
    [
        "STORE_ATTR",
        "frame_info.return_node"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node.parent"
    ],
    [
        "STORE_FAST",
        "parent"
    ],
    [
        "LOAD_FAST",
        "frame_info"
    ],
    [
        "LOAD_ATTR",
        "frame_info.return_node"
    ],
    [
        "STORE_FAST",
        "return_node"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "parent"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.FunctionDef"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.Module"
    ],
    [
        "CALL",
        "isinstance(parent, (ast.FunctionDef, ast.Module))"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_FAST",
        "parent"
    ],
    [
        "LOAD_ATTR",
        "parent.body"
    ],
    [
        "BINARY_SUBSCR",
        "parent.body[-1]"
    ],
    [
        "IS_OP",
        "node is parent.body[-1]"
    ],
    [
        "LOAD_FAST",
        "exc_val"
    ],
    [
        "LOAD_FAST",
        "return_node"
    ],
    [
        "STORE_FAST",
        "exiting"
    ],
    [
        "LOAD_FAST",
        "exiting"
    ],
    [
        "LOAD_FAST",
        "tracer"
    ],
    [
        "LOAD_ATTR",
        "tracer._get_caller_stuff"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "CALL",
        "tracer._get_caller_stuff(frame)"
    ],
    [
        "STORE_FAST",
        "caller_frame"
    ],
    [
        "STORE_FAST",
        "call_node"
    ],
    [
        "STORE_FAST",
        "return_value"
    ],
    [
        "LOAD_FAST",
        "return_node"
    ],
    [
        "LOAD_FAST",
        "return_node"
    ],
    [
        "LOAD_ATTR",
        "return_node.value"
    ],
    [
        "LOAD_FAST",
        "exc_val"
    ],
    [
        "LOAD_FAST",
        "frame_info"
    ],
    [
        "LOAD_ATTR",
        "frame_info.expression_values"
    ],
    [
        "LOAD_FAST",
        "return_node"
    ],
    [
        "LOAD_ATTR",
        "return_node.value"
    ],
    [
        "BINARY_SUBSCR",
        "frame_info.expression_values[return_node.value]"
    ],
    [
        "STORE_FAST",
        "return_value"
    ],
    [
        "LOAD_FAST",
        "tracer"
    ],
    [
        "LOAD_ATTR",
        "tracer.exit_call"
    ],
    [
        "LOAD_GLOBAL",
        "ExitCallInfo"
    ],
    [
        "LOAD_FAST",
        "call_node"
    ],
    [
        "LOAD_FAST",
        "return_node"
    ],
    [
        "LOAD_FAST",
        "caller_frame"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "LOAD_FAST",
        "return_value"
    ],
    [
        "LOAD_FAST",
        "exc_val"
    ],
    [
        "LOAD_FAST",
        "exc_tb"
    ],
    [
        "CALL",
        "ExitCallInfo(call_node,\n                                          return_node,\n                                          caller_frame,\n                                          frame,\n                                          return_value,\n                                          exc_val,\n                                          exc_tb\n                                          )"
    ],
    [
        "CALL",
        "tracer.exit_call(ExitCallInfo(call_node,\n                                          return_node,\n                                          caller_frame,\n                                          frame,\n                                          return_value,\n                                          exc_val,\n                                          exc_tb\n                                          ))"
    ],
    [
        "LOAD_FAST",
        "tracer"
    ],
    [
        "LOAD_ATTR",
        "tracer.stack"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "DELETE_SUBSCR",
        "tracer.stack[frame]"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.tracer"
    ],
    [
        "LOAD_ATTR",
        "self.tracer.main_to_secondary_frames"
    ],
    [
        "LOAD_ATTR",
        "self.tracer.main_to_secondary_frames.pop"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "CALL",
        "self.tracer.main_to_secondary_frames.pop(frame)"
    ],
    [
        "STORE_FAST",
        "secondary_frame"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.tracer"
    ],
    [
        "LOAD_ATTR",
        "self.tracer.secondary_to_main_frames"
    ],
    [
        "LOAD_FAST",
        "secondary_frame"
    ],
    [
        "DELETE_SUBSCR",
        "self.tracer.secondary_to_main_frames[secondary_frame]"
    ],
    [
        "LOAD_FAST",
        "result"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node.parent"
    ],
    [
        "STORE_FAST",
        "node"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_GLOBAL",
        "AttributeError"
    ],
    [
        "STORE_FAST",
        "result"
    ],
    [
        "LOAD_DEREF",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node.parent"
    ],
    [
        "STORE_FAST",
        "parent"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "parent"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.FunctionDef"
    ],
    [
        "CALL",
        "isinstance(parent, ast.FunctionDef)"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "parent"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.For"
    ],
    [
        "CALL",
        "isinstance(parent, ast.For)"
    ],
    [
        "LOAD_FAST",
        "parent"
    ],
    [
        "LOAD_ATTR",
        "parent.iter"
    ],
    [
        "LOAD_DEREF",
        "node"
    ],
    [
        "IS_OP",
        "parent.iter is not node"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "parent"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.While"
    ],
    [
        "CALL",
        "isinstance(parent, ast.While)"
    ],
    [
        "LOAD_DEREF",
        "node"
    ],
    [
        "LOAD_FAST",
        "parent"
    ],
    [
        "LOAD_ATTR",
        "parent.orelse"
    ],
    [
        "CONTAINS_OP",
        "node not in parent.orelse"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "parent"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.comprehension"
    ],
    [
        "CALL",
        "isinstance(parent, ast.comprehension)"
    ],
    [
        "LOAD_DEREF",
        "node"
    ],
    [
        "LOAD_FAST",
        "parent"
    ],
    [
        "LOAD_ATTR",
        "parent.ifs"
    ],
    [
        "CONTAINS_OP",
        "node in parent.ifs"
    ],
    [
        "STORE_FAST",
        "is_containing_loop"
    ],
    [
        "LOAD_FAST",
        "is_containing_loop"
    ],
    [
        "LOAD_FAST",
        "result"
    ],
    [
        "LOAD_ATTR",
        "result.append"
    ],
    [
        "LOAD_FAST",
        "parent"
    ],
    [
        "CALL",
        "result.append(parent)"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "parent"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.ListComp"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.GeneratorExp"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.DictComp"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.SetComp"
    ],
    [
        "CALL",
        "isinstance(parent, (ast.ListComp,\n                                 ast.GeneratorExp,\n                                 ast.DictComp,\n                                 ast.SetComp))"
    ],
    [
        "LOAD_FAST",
        "parent"
    ],
    [
        "LOAD_ATTR",
        "parent.generators"
    ],
    [
        "STORE_FAST",
        "generators"
    ],
    [
        "LOAD_DEREF",
        "node"
    ],
    [
        "LOAD_FAST",
        "generators"
    ],
    [
        "CONTAINS_OP",
        "node in generators"
    ],
    [
        "LOAD_GLOBAL",
        "list"
    ],
    [
        "LOAD_GLOBAL",
        "takewhile"
    ],
    [
        "LOAD_FAST",
        "generators"
    ],
    [
        "CALL",
        "takewhile(lambda n: n != node, generators)"
    ],
    [
        "CALL",
        "list(takewhile(lambda n: n != node, generators))"
    ],
    [
        "STORE_FAST",
        "generators"
    ],
    [
        "LOAD_FAST",
        "result"
    ],
    [
        "LOAD_ATTR",
        "result.extend"
    ],
    [
        "LOAD_GLOBAL",
        "reversed"
    ],
    [
        "LOAD_FAST",
        "generators"
    ],
    [
        "CALL",
        "reversed(generators)"
    ],
    [
        "CALL",
        "result.extend(reversed(generators))"
    ],
    [
        "LOAD_FAST",
        "parent"
    ],
    [
        "STORE_DEREF",
        "node"
    ],
    [
        "LOAD_FAST",
        "result"
    ],
    [
        "LOAD_ATTR",
        "result.reverse"
    ],
    [
        "CALL",
        "result.reverse()"
    ],
    [
        "LOAD_GLOBAL",
        "tuple"
    ],
    [
        "LOAD_FAST",
        "result"
    ],
    [
        "CALL",
        "tuple(result)"
    ],
    [
        "LOAD_GLOBAL",
        "AttributeError"
    ],
    [
        "LOAD_FAST",
        "n"
    ],
    [
        "LOAD_DEREF",
        "node"
    ],
    [
        "COMPARE_OP",
        "n != node"
    ]
]