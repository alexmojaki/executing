[
    [
        "STORE_NAME",
        "import logging"
    ],
    [
        "STORE_NAME",
        "import sys"
    ],
    [
        "STORE_NAME",
        "from importlib.util import spec_from_loader"
    ],
    [
        "STORE_NAME",
        "import ast"
    ],
    [
        "CALL",
        "class BirdsEyeLoader:\n\n    def __init__(self, spec, source, deep):\n        self._spec = spec\n        self.source = source\n        self.deep = deep\n\n    def create_module(self, spec):\n        pass\n\n    def exec_module(self, module):\n        from birdseye.bird import eye\n        eye.exec_string(\n            source=self.source,\n            filename=self._spec.origin,\n            globs=module.__dict__,\n            locs=module.__dict__,\n            deep=self.deep,\n        )\n\n    def get_filename(self, fullname):\n        return self._spec.loader.get_filename(fullname)\n\n    def is_package(self, fullname):\n        return self._spec.loader.is_package(fullname)"
    ],
    [
        "STORE_NAME",
        "class BirdsEyeLoader:\n\n    def __init__(self, spec, source, deep):\n        self._spec = spec\n        self.source = source\n        self.deep = deep\n\n    def create_module(self, spec):\n        pass\n\n    def exec_module(self, module):\n        from birdseye.bird import eye\n        eye.exec_string(\n            source=self.source,\n            filename=self._spec.origin,\n            globs=module.__dict__,\n            locs=module.__dict__,\n            deep=self.deep,\n        )\n\n    def get_filename(self, fullname):\n        return self._spec.loader.get_filename(fullname)\n\n    def is_package(self, fullname):\n        return self._spec.loader.is_package(fullname)"
    ],
    [
        "LOAD_NAME",
        "object"
    ],
    [
        "CALL",
        "class BirdsEyeFinder(object):\n    \"\"\"Loads a module and looks for tracing inside, only providing a loader\n    if it finds some.\n    \"\"\"\n\n    def _find_plain_spec(self, fullname, path, target):\n        \"\"\"Try to find the original module using all the\n        remaining meta_path finders.\"\"\"\n        spec = None\n        for finder in sys.meta_path:\n            # when testing with pytest, it installs a finder that for\n            # some yet unknown reasons makes birdseye\n            # fail. For now it will just avoid using it and pass to\n            # the next one\n            if finder is self or 'pytest' in finder.__module__:\n                continue\n            if hasattr(finder, 'find_spec'):\n                spec = finder.find_spec(fullname, path, target=target)\n            elif hasattr(finder, 'load_module'):\n                spec = spec_from_loader(fullname, finder)\n\n            if spec is not None and spec.origin != 'builtin':\n                return spec\n\n    def find_spec(self, fullname, path, target=None):\n        spec = self._find_plain_spec(fullname, path, target)\n        if spec is None or not (hasattr(spec.loader, 'get_source') and\n                                callable(spec.loader.get_source)):  # noqa: E128\n            if fullname != 'org':\n                # stdlib pickle.py at line 94 contains a ``from\n                # org.python.core for Jython which is always failing,\n                # of course\n                logging.debug('Failed finding spec for %s', fullname)\n            return\n\n        try:\n            source = spec.loader.get_source(fullname)\n        except ImportError:\n            logging.debug('Loader for %s was unable to find the sources',\n                          fullname)\n            return\n        except Exception:\n            logging.exception('Loader for %s raised an error', fullname)\n            return\n\n        if not source or 'birdseye' not in source:\n            return\n\n        deep, trace_stmt = should_trace(source)\n\n        if not trace_stmt:\n            return\n\n        loader = BirdsEyeLoader(spec, source, deep)\n        return spec_from_loader(fullname, loader)"
    ],
    [
        "STORE_NAME",
        "class BirdsEyeFinder(object):\n    \"\"\"Loads a module and looks for tracing inside, only providing a loader\n    if it finds some.\n    \"\"\"\n\n    def _find_plain_spec(self, fullname, path, target):\n        \"\"\"Try to find the original module using all the\n        remaining meta_path finders.\"\"\"\n        spec = None\n        for finder in sys.meta_path:\n            # when testing with pytest, it installs a finder that for\n            # some yet unknown reasons makes birdseye\n            # fail. For now it will just avoid using it and pass to\n            # the next one\n            if finder is self or 'pytest' in finder.__module__:\n                continue\n            if hasattr(finder, 'find_spec'):\n                spec = finder.find_spec(fullname, path, target=target)\n            elif hasattr(finder, 'load_module'):\n                spec = spec_from_loader(fullname, finder)\n\n            if spec is not None and spec.origin != 'builtin':\n                return spec\n\n    def find_spec(self, fullname, path, target=None):\n        spec = self._find_plain_spec(fullname, path, target)\n        if spec is None or not (hasattr(spec.loader, 'get_source') and\n                                callable(spec.loader.get_source)):  # noqa: E128\n            if fullname != 'org':\n                # stdlib pickle.py at line 94 contains a ``from\n                # org.python.core for Jython which is always failing,\n                # of course\n                logging.debug('Failed finding spec for %s', fullname)\n            return\n\n        try:\n            source = spec.loader.get_source(fullname)\n        except ImportError:\n            logging.debug('Loader for %s was unable to find the sources',\n                          fullname)\n            return\n        except Exception:\n            logging.exception('Loader for %s raised an error', fullname)\n            return\n\n        if not source or 'birdseye' not in source:\n            return\n\n        deep, trace_stmt = should_trace(source)\n\n        if not trace_stmt:\n            return\n\n        loader = BirdsEyeLoader(spec, source, deep)\n        return spec_from_loader(fullname, loader)"
    ],
    [
        "STORE_NAME",
        "def should_trace(source):\n    trace_stmt = None\n    deep = False\n    for stmt in ast.parse(source).body:\n        if isinstance(stmt, ast.Import):\n            for alias in stmt.names:\n                if alias.name.startswith('birdseye.trace_module'):\n                    trace_stmt = stmt\n                    if alias.name.endswith('deep'):\n                        deep = True\n\n        if isinstance(stmt, ast.ImportFrom) and stmt.module == 'birdseye':\n            for alias in stmt.names:\n                if alias.name.startswith('trace_module'):\n                    trace_stmt = stmt\n                    if alias.name.endswith('deep'):\n                        deep = True\n    return deep, trace_stmt"
    ],
    [
        "STORE_NAME",
        "    def __init__(self, spec, source, deep):\n        self._spec = spec\n        self.source = source\n        self.deep = deep"
    ],
    [
        "STORE_NAME",
        "    def create_module(self, spec):\n        pass"
    ],
    [
        "STORE_NAME",
        "    def exec_module(self, module):\n        from birdseye.bird import eye\n        eye.exec_string(\n            source=self.source,\n            filename=self._spec.origin,\n            globs=module.__dict__,\n            locs=module.__dict__,\n            deep=self.deep,\n        )"
    ],
    [
        "STORE_NAME",
        "    def get_filename(self, fullname):\n        return self._spec.loader.get_filename(fullname)"
    ],
    [
        "STORE_NAME",
        "    def is_package(self, fullname):\n        return self._spec.loader.is_package(fullname)"
    ],
    [
        "LOAD_FAST",
        "spec"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._spec"
    ],
    [
        "LOAD_FAST",
        "source"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.source"
    ],
    [
        "LOAD_FAST",
        "deep"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.deep"
    ],
    [
        "STORE_FAST",
        "from birdseye.bird import eye"
    ],
    [
        "LOAD_FAST",
        "eye"
    ],
    [
        "LOAD_ATTR",
        "eye.exec_string"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.source"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._spec"
    ],
    [
        "LOAD_ATTR",
        "self._spec.origin"
    ],
    [
        "LOAD_FAST",
        "module"
    ],
    [
        "LOAD_ATTR",
        "module.__dict__"
    ],
    [
        "LOAD_FAST",
        "module"
    ],
    [
        "LOAD_ATTR",
        "module.__dict__"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.deep"
    ],
    [
        "CALL",
        "eye.exec_string(\n            source=self.source,\n            filename=self._spec.origin,\n            globs=module.__dict__,\n            locs=module.__dict__,\n            deep=self.deep,\n        )"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._spec"
    ],
    [
        "LOAD_ATTR",
        "self._spec.loader"
    ],
    [
        "LOAD_ATTR",
        "self._spec.loader.get_filename"
    ],
    [
        "LOAD_FAST",
        "fullname"
    ],
    [
        "CALL",
        "self._spec.loader.get_filename(fullname)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._spec"
    ],
    [
        "LOAD_ATTR",
        "self._spec.loader"
    ],
    [
        "LOAD_ATTR",
        "self._spec.loader.is_package"
    ],
    [
        "LOAD_FAST",
        "fullname"
    ],
    [
        "CALL",
        "self._spec.loader.is_package(fullname)"
    ],
    [
        "STORE_NAME",
        "\"\"\"Loads a module and looks for tracing inside, only providing a loader\n    if it finds some.\n    \"\"\""
    ],
    [
        "STORE_NAME",
        "    def _find_plain_spec(self, fullname, path, target):\n        \"\"\"Try to find the original module using all the\n        remaining meta_path finders.\"\"\"\n        spec = None\n        for finder in sys.meta_path:\n            # when testing with pytest, it installs a finder that for\n            # some yet unknown reasons makes birdseye\n            # fail. For now it will just avoid using it and pass to\n            # the next one\n            if finder is self or 'pytest' in finder.__module__:\n                continue\n            if hasattr(finder, 'find_spec'):\n                spec = finder.find_spec(fullname, path, target=target)\n            elif hasattr(finder, 'load_module'):\n                spec = spec_from_loader(fullname, finder)\n\n            if spec is not None and spec.origin != 'builtin':\n                return spec"
    ],
    [
        "STORE_NAME",
        "    def find_spec(self, fullname, path, target=None):\n        spec = self._find_plain_spec(fullname, path, target)\n        if spec is None or not (hasattr(spec.loader, 'get_source') and\n                                callable(spec.loader.get_source)):  # noqa: E128\n            if fullname != 'org':\n                # stdlib pickle.py at line 94 contains a ``from\n                # org.python.core for Jython which is always failing,\n                # of course\n                logging.debug('Failed finding spec for %s', fullname)\n            return\n\n        try:\n            source = spec.loader.get_source(fullname)\n        except ImportError:\n            logging.debug('Loader for %s was unable to find the sources',\n                          fullname)\n            return\n        except Exception:\n            logging.exception('Loader for %s raised an error', fullname)\n            return\n\n        if not source or 'birdseye' not in source:\n            return\n\n        deep, trace_stmt = should_trace(source)\n\n        if not trace_stmt:\n            return\n\n        loader = BirdsEyeLoader(spec, source, deep)\n        return spec_from_loader(fullname, loader)"
    ],
    [
        "STORE_FAST",
        "spec"
    ],
    [
        "LOAD_GLOBAL",
        "sys"
    ],
    [
        "LOAD_ATTR",
        "sys.meta_path"
    ],
    [
        "STORE_FAST",
        "finder"
    ],
    [
        "LOAD_FAST",
        "finder"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "IS_OP",
        "finder is self"
    ],
    [
        "LOAD_FAST",
        "finder"
    ],
    [
        "LOAD_ATTR",
        "finder.__module__"
    ],
    [
        "CONTAINS_OP",
        "'pytest' in finder.__module__"
    ],
    [
        "LOAD_GLOBAL",
        "hasattr"
    ],
    [
        "LOAD_FAST",
        "finder"
    ],
    [
        "CALL",
        "hasattr(finder, 'find_spec')"
    ],
    [
        "LOAD_FAST",
        "finder"
    ],
    [
        "LOAD_ATTR",
        "finder.find_spec"
    ],
    [
        "LOAD_FAST",
        "fullname"
    ],
    [
        "LOAD_FAST",
        "path"
    ],
    [
        "LOAD_FAST",
        "target"
    ],
    [
        "CALL",
        "finder.find_spec(fullname, path, target=target)"
    ],
    [
        "STORE_FAST",
        "spec"
    ],
    [
        "LOAD_GLOBAL",
        "hasattr"
    ],
    [
        "LOAD_FAST",
        "finder"
    ],
    [
        "CALL",
        "hasattr(finder, 'load_module')"
    ],
    [
        "LOAD_GLOBAL",
        "spec_from_loader"
    ],
    [
        "LOAD_FAST",
        "fullname"
    ],
    [
        "LOAD_FAST",
        "finder"
    ],
    [
        "CALL",
        "spec_from_loader(fullname, finder)"
    ],
    [
        "STORE_FAST",
        "spec"
    ],
    [
        "LOAD_FAST",
        "spec"
    ],
    [
        "LOAD_FAST",
        "spec"
    ],
    [
        "LOAD_ATTR",
        "spec.origin"
    ],
    [
        "COMPARE_OP",
        "spec.origin != 'builtin'"
    ],
    [
        "LOAD_FAST",
        "spec"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._find_plain_spec"
    ],
    [
        "LOAD_FAST",
        "fullname"
    ],
    [
        "LOAD_FAST",
        "path"
    ],
    [
        "LOAD_FAST",
        "target"
    ],
    [
        "CALL",
        "self._find_plain_spec(fullname, path, target)"
    ],
    [
        "STORE_FAST",
        "spec"
    ],
    [
        "LOAD_FAST",
        "spec"
    ],
    [
        "LOAD_GLOBAL",
        "hasattr"
    ],
    [
        "LOAD_FAST",
        "spec"
    ],
    [
        "LOAD_ATTR",
        "spec.loader"
    ],
    [
        "CALL",
        "hasattr(spec.loader, 'get_source')"
    ],
    [
        "LOAD_GLOBAL",
        "callable"
    ],
    [
        "LOAD_FAST",
        "spec"
    ],
    [
        "LOAD_ATTR",
        "spec.loader"
    ],
    [
        "LOAD_ATTR",
        "spec.loader.get_source"
    ],
    [
        "CALL",
        "callable(spec.loader.get_source)"
    ],
    [
        "LOAD_FAST",
        "fullname"
    ],
    [
        "COMPARE_OP",
        "fullname != 'org'"
    ],
    [
        "LOAD_GLOBAL",
        "logging"
    ],
    [
        "LOAD_ATTR",
        "logging.debug"
    ],
    [
        "LOAD_FAST",
        "fullname"
    ],
    [
        "CALL",
        "logging.debug('Failed finding spec for %s', fullname)"
    ],
    [
        "LOAD_FAST",
        "spec"
    ],
    [
        "LOAD_ATTR",
        "spec.loader"
    ],
    [
        "LOAD_ATTR",
        "spec.loader.get_source"
    ],
    [
        "LOAD_FAST",
        "fullname"
    ],
    [
        "CALL",
        "spec.loader.get_source(fullname)"
    ],
    [
        "STORE_FAST",
        "source"
    ],
    [
        "LOAD_FAST",
        "source"
    ],
    [
        "LOAD_FAST",
        "source"
    ],
    [
        "CONTAINS_OP",
        "'birdseye' not in source"
    ],
    [
        "LOAD_GLOBAL",
        "should_trace"
    ],
    [
        "LOAD_FAST",
        "source"
    ],
    [
        "CALL",
        "should_trace(source)"
    ],
    [
        "STORE_FAST",
        "deep"
    ],
    [
        "STORE_FAST",
        "trace_stmt"
    ],
    [
        "LOAD_FAST",
        "trace_stmt"
    ],
    [
        "LOAD_GLOBAL",
        "BirdsEyeLoader"
    ],
    [
        "LOAD_FAST",
        "spec"
    ],
    [
        "LOAD_FAST",
        "source"
    ],
    [
        "LOAD_FAST",
        "deep"
    ],
    [
        "CALL",
        "BirdsEyeLoader(spec, source, deep)"
    ],
    [
        "STORE_FAST",
        "loader"
    ],
    [
        "LOAD_GLOBAL",
        "spec_from_loader"
    ],
    [
        "LOAD_FAST",
        "fullname"
    ],
    [
        "LOAD_FAST",
        "loader"
    ],
    [
        "CALL",
        "spec_from_loader(fullname, loader)"
    ],
    [
        "LOAD_GLOBAL",
        "ImportError"
    ],
    [
        "LOAD_GLOBAL",
        "logging"
    ],
    [
        "LOAD_ATTR",
        "logging.debug"
    ],
    [
        "LOAD_FAST",
        "fullname"
    ],
    [
        "CALL",
        "logging.debug('Loader for %s was unable to find the sources',\n                          fullname)"
    ],
    [
        "LOAD_GLOBAL",
        "Exception"
    ],
    [
        "LOAD_GLOBAL",
        "logging"
    ],
    [
        "LOAD_ATTR",
        "logging.exception"
    ],
    [
        "LOAD_FAST",
        "fullname"
    ],
    [
        "CALL",
        "logging.exception('Loader for %s raised an error', fullname)"
    ],
    [
        "STORE_FAST",
        "trace_stmt"
    ],
    [
        "STORE_FAST",
        "deep"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.parse"
    ],
    [
        "LOAD_FAST",
        "source"
    ],
    [
        "CALL",
        "ast.parse(source)"
    ],
    [
        "LOAD_ATTR",
        "ast.parse(source).body"
    ],
    [
        "STORE_FAST",
        "stmt"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "stmt"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.Import"
    ],
    [
        "CALL",
        "isinstance(stmt, ast.Import)"
    ],
    [
        "LOAD_FAST",
        "stmt"
    ],
    [
        "LOAD_ATTR",
        "stmt.names"
    ],
    [
        "STORE_FAST",
        "alias"
    ],
    [
        "LOAD_FAST",
        "alias"
    ],
    [
        "LOAD_ATTR",
        "alias.name"
    ],
    [
        "LOAD_ATTR",
        "alias.name.startswith"
    ],
    [
        "CALL",
        "alias.name.startswith('birdseye.trace_module')"
    ],
    [
        "LOAD_FAST",
        "stmt"
    ],
    [
        "STORE_FAST",
        "trace_stmt"
    ],
    [
        "LOAD_FAST",
        "alias"
    ],
    [
        "LOAD_ATTR",
        "alias.name"
    ],
    [
        "LOAD_ATTR",
        "alias.name.endswith"
    ],
    [
        "CALL",
        "alias.name.endswith('deep')"
    ],
    [
        "STORE_FAST",
        "deep"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "stmt"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.ImportFrom"
    ],
    [
        "CALL",
        "isinstance(stmt, ast.ImportFrom)"
    ],
    [
        "LOAD_FAST",
        "stmt"
    ],
    [
        "LOAD_ATTR",
        "stmt.module"
    ],
    [
        "COMPARE_OP",
        "stmt.module == 'birdseye'"
    ],
    [
        "LOAD_FAST",
        "stmt"
    ],
    [
        "LOAD_ATTR",
        "stmt.names"
    ],
    [
        "STORE_FAST",
        "alias"
    ],
    [
        "LOAD_FAST",
        "alias"
    ],
    [
        "LOAD_ATTR",
        "alias.name"
    ],
    [
        "LOAD_ATTR",
        "alias.name.startswith"
    ],
    [
        "CALL",
        "alias.name.startswith('trace_module')"
    ],
    [
        "LOAD_FAST",
        "stmt"
    ],
    [
        "STORE_FAST",
        "trace_stmt"
    ],
    [
        "LOAD_FAST",
        "alias"
    ],
    [
        "LOAD_ATTR",
        "alias.name"
    ],
    [
        "LOAD_ATTR",
        "alias.name.endswith"
    ],
    [
        "CALL",
        "alias.name.endswith('deep')"
    ],
    [
        "STORE_FAST",
        "deep"
    ],
    [
        "LOAD_FAST",
        "deep"
    ],
    [
        "LOAD_FAST",
        "trace_stmt"
    ]
]