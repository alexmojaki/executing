[
    [
        "STORE_NAME",
        "from __future__ import print_function, division"
    ],
    [
        "STORE_NAME",
        "from __future__ import print_function, division"
    ],
    [
        "STORE_NAME",
        "import ast"
    ],
    [
        "STORE_NAME",
        "import inspect"
    ],
    [
        "STORE_NAME",
        "import os"
    ],
    [
        "STORE_NAME",
        "import sys"
    ],
    [
        "STORE_NAME",
        "import tempfile"
    ],
    [
        "STORE_NAME",
        "import time"
    ],
    [
        "STORE_NAME",
        "import unittest"
    ],
    [
        "STORE_NAME",
        "from executing import Source, only, PY3, NotOneValueFound, get_instructions"
    ],
    [
        "STORE_NAME",
        "from executing import Source, only, PY3, NotOneValueFound, get_instructions"
    ],
    [
        "STORE_NAME",
        "from executing import Source, only, PY3, NotOneValueFound, get_instructions"
    ],
    [
        "STORE_NAME",
        "from executing import Source, only, PY3, NotOneValueFound, get_instructions"
    ],
    [
        "STORE_NAME",
        "from executing import Source, only, PY3, NotOneValueFound, get_instructions"
    ],
    [
        "LOAD_NAME",
        "unittest"
    ],
    [
        "LOAD_ATTR",
        "unittest.TestCase"
    ],
    [
        "CALL_FUNCTION",
        "class TestStuff(unittest.TestCase):\n\n    # noinspection PyTrailingSemicolon\n    def test_semicolons(self):\n        # @formatter:off\n        tester(1); tester(2); tester(3)\n        tester(9\n               ); tester(\n            8); tester(\n            99\n        ); tester(33); tester([4,\n                               5, 6, [\n                                7]])\n        # @formatter:on\n\n    def test_decorator(self):\n        @empty_decorator\n        @decorator_with_args(tester('123'), x=int())\n        @tester(list(tuple([1, 2])), returns=empty_decorator)\n        @tester(\n            list(\n                tuple(\n                    [3, 4])),\n            returns=empty_decorator)\n        @empty_decorator\n        @decorator_with_args(\n            str(),\n            x=int())\n        @tester(list(tuple([5, 6])), returns=empty_decorator)\n        @tester(list(tuple([7, 8])), returns=empty_decorator)\n        @empty_decorator\n        @decorator_with_args(tester('sdf'), x=tester('123234'))\n        def foo():\n            pass\n\n    def test_comprehensions(self):\n        # Comprehensions can be separated if they contain different names\n        str([{tester(x) for x in [1]}, {tester(y) for y in [1]}])\n        # or are on different lines\n        str([{tester(x) for x in [1]},\n             {tester(x) for x in [1]}])\n        # or are of different types\n        str([{tester(x) for x in [1]}, list(tester(x) for x in [1])])\n        # but not if everything is the same\n        # noinspection PyTypeChecker\n        # with self.assertRaises((AttributeError, NotOneValueFound)):\n        #     str([{tester(x) for x in [1]}, {tester(x) for x in [2]}])\n\n    def test_lambda(self):\n        self.assertEqual(\n            (lambda x: (tester(x), tester(x)))(tester(3)),\n            (3, 3),\n        )\n        (lambda: (lambda: tester(1))())()\n        self.assertEqual(\n            (lambda: [tester(x) for x in tester([1, 2])])(),\n            [1, 2],\n        )\n\n    def test_closures_and_nested_comprehensions(self):\n        x = 1\n        # @formatter:off\n        str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n\n        def foo():\n            y = 2\n            str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n            str({tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n            str({tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n\n            def bar():\n                z = 3\n                str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+x+y+z): {tester(b+x+y+z): {tester(c+x+y+z) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n\n            bar()\n\n        foo()\n        # @formatter:on\n\n    def test_indirect_call(self):\n        dict(x=tester)['x'](tester)(3, check_func=False)\n\n    def test_compound_statements(self):\n        with self.assertRaises(TypeError):\n            try:\n                for _ in tester([1, 2, 3]):\n                    while tester(0):\n                        pass\n                    else:\n                        tester(4)\n                else:\n                    tester(5)\n                    raise ValueError\n            except tester(ValueError):\n                tester(9)\n                raise TypeError\n            finally:\n                tester(10)\n\n        # PyCharm getting confused somehow?\n        # noinspection PyUnreachableCode\n        str()\n\n        with self.assertRaises(tester(Exception)):\n            if tester(0):\n                pass\n            elif tester(0):\n                pass\n            elif tester(1 / 0):\n                pass\n\n    def test_generator(self):\n        def gen():\n            for x in [1, 2]:\n                yield tester(x)\n\n        gen2 = (tester(x) for x in tester([1, 2]))\n\n        assert list(gen()) == list(gen2) == [1, 2]\n\n    def test_future_import(self):\n        tester(4)\n\n    def test_many_calls(self):\n        node = None\n        start = time.time()\n        for i in range(10000):\n            new_node = Source.executing(inspect.currentframe()).node\n            if node is None:\n                node = new_node\n            else:\n                self.assertIs(node, new_node)\n        self.assertLess(time.time() - start, 1)\n\n    def test_decode_source(self):\n        def check(source, encoding, exception=None, matches=True):\n            encoded = source.encode(encoding)\n            if exception:\n                with self.assertRaises(exception):\n                    Source.decode_source(encoded)\n            else:\n                decoded = Source.decode_source(encoded)\n                if matches:\n                    self.assertEqual(decoded, source)\n                else:\n                    self.assertNotEqual(decoded, source)\n\n        check(u'# coding=utf8\\n\u00e9', 'utf8')\n        check(u'# coding=gbk\\n\u00e9', 'gbk')\n\n        check(u'# coding=utf8\\n\u00e9', 'gbk', exception=UnicodeDecodeError)\n        check(u'# coding=gbk\\n\u00e9', 'utf8', matches=False)\n\n        # In Python 3 the default encoding is assumed to be UTF8\n        if PY3:\n            check(u'\u00e9', 'utf8')\n            check(u'\u00e9', 'gbk', exception=SyntaxError)\n\n    def test_multiline_strings(self):\n        tester('a')\n        tester('''\n            ab''')\n        tester('''\n                    abc\n                    def\n                    '''\n               )\n        str([\n            tester(\n                '''\n                123\n                456\n                '''\n            ),\n            tester(\n                '''\n                345\n                456786\n                '''\n            ),\n        ])\n        tester(\n            [\n                '''\n                123\n                456\n                '''\n                '''\n                345\n                456786\n                '''\n                ,\n                '''\n                123\n                456\n                ''',\n                '''\n                345\n                456786\n                '''\n            ]\n        )\n\n    def test_multiple_statements_on_one_line(self):\n        if tester(1): tester(2)\n        for _ in tester([1, 2]): tester(3)\n\n    def assert_qualname(self, func, qn, check_actual_qualname=True):\n        qualname = Source.for_filename(__file__).code_qualname(func.__code__)\n        self.assertEqual(qn, qualname)\n        if PY3 and check_actual_qualname:\n            self.assertEqual(qn, func.__qualname__)\n        self.assertTrue(qn.endswith(func.__name__))\n\n    def test_qualname(self):\n        self.assert_qualname(C.f, 'C.f')\n        self.assert_qualname(C.D.g, 'C.D.g')\n        self.assert_qualname(f, 'f')\n        self.assert_qualname(f(), 'f.<locals>.g')\n        self.assert_qualname(C.D.h(), 'C.D.h.<locals>.i.<locals>.j')\n        self.assert_qualname(lamb, '<lambda>')\n        foo = lambda_maker()\n        self.assert_qualname(foo, 'lambda_maker.<locals>.foo')\n        self.assert_qualname(foo.x, 'lambda_maker.<locals>.<lambda>')\n        self.assert_qualname(foo(), 'lambda_maker.<locals>.foo.<locals>.<lambda>')\n        self.assert_qualname(foo()(), 'lambda_maker.<locals>.foo.<locals>.<lambda>', check_actual_qualname=False)\n\n    def test_extended_arg(self):\n        source = 'tester(6)\\n%s\\ntester(9)' % list(range(66000))\n        _, filename = tempfile.mkstemp()\n        code = compile(source, filename, 'exec')\n        with open(filename, 'w') as outfile:\n            outfile.write(source)\n        exec(code)\n\n    def test_only(self):\n        for n in range(5):\n            gen = (i for i in range(n))\n            if n == 1:\n                self.assertEqual(only(gen), 0)\n            else:\n                with self.assertRaises(NotOneValueFound):\n                    only(gen)\n\n    def test_invalid_python(self):\n        path = os.path.join(os.path.dirname(__file__), 'not_code.txt', )\n        source = Source.for_filename(path)\n        self.assertIsNone(source.tree)\n\n    def test_executing_methods(self):\n        frame = inspect.currentframe()\n        executing = Source.executing(frame)\n        self.assertEqual(executing.code_qualname(), 'TestStuff.test_executing_methods')\n        if 'pypy' not in sys.version.lower():\n            text = 'Source.executing(frame)'\n            self.assertEqual(executing.text(), text)\n            start, end = executing.text_range()\n            self.assertEqual(executing.source.text[start:end], text)\n\n    def test_attr(self):\n        c = C()\n        c.x = c.y = tester\n        str((c.x.x, c.x.y, c.y.x, c.y.y, c.x.asd, c.y.qwe))"
    ],
    [
        "STORE_NAME",
        "class TestStuff(unittest.TestCase):\n\n    # noinspection PyTrailingSemicolon\n    def test_semicolons(self):\n        # @formatter:off\n        tester(1); tester(2); tester(3)\n        tester(9\n               ); tester(\n            8); tester(\n            99\n        ); tester(33); tester([4,\n                               5, 6, [\n                                7]])\n        # @formatter:on\n\n    def test_decorator(self):\n        @empty_decorator\n        @decorator_with_args(tester('123'), x=int())\n        @tester(list(tuple([1, 2])), returns=empty_decorator)\n        @tester(\n            list(\n                tuple(\n                    [3, 4])),\n            returns=empty_decorator)\n        @empty_decorator\n        @decorator_with_args(\n            str(),\n            x=int())\n        @tester(list(tuple([5, 6])), returns=empty_decorator)\n        @tester(list(tuple([7, 8])), returns=empty_decorator)\n        @empty_decorator\n        @decorator_with_args(tester('sdf'), x=tester('123234'))\n        def foo():\n            pass\n\n    def test_comprehensions(self):\n        # Comprehensions can be separated if they contain different names\n        str([{tester(x) for x in [1]}, {tester(y) for y in [1]}])\n        # or are on different lines\n        str([{tester(x) for x in [1]},\n             {tester(x) for x in [1]}])\n        # or are of different types\n        str([{tester(x) for x in [1]}, list(tester(x) for x in [1])])\n        # but not if everything is the same\n        # noinspection PyTypeChecker\n        # with self.assertRaises((AttributeError, NotOneValueFound)):\n        #     str([{tester(x) for x in [1]}, {tester(x) for x in [2]}])\n\n    def test_lambda(self):\n        self.assertEqual(\n            (lambda x: (tester(x), tester(x)))(tester(3)),\n            (3, 3),\n        )\n        (lambda: (lambda: tester(1))())()\n        self.assertEqual(\n            (lambda: [tester(x) for x in tester([1, 2])])(),\n            [1, 2],\n        )\n\n    def test_closures_and_nested_comprehensions(self):\n        x = 1\n        # @formatter:off\n        str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n\n        def foo():\n            y = 2\n            str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n            str({tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n            str({tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n\n            def bar():\n                z = 3\n                str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+x+y+z): {tester(b+x+y+z): {tester(c+x+y+z) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n\n            bar()\n\n        foo()\n        # @formatter:on\n\n    def test_indirect_call(self):\n        dict(x=tester)['x'](tester)(3, check_func=False)\n\n    def test_compound_statements(self):\n        with self.assertRaises(TypeError):\n            try:\n                for _ in tester([1, 2, 3]):\n                    while tester(0):\n                        pass\n                    else:\n                        tester(4)\n                else:\n                    tester(5)\n                    raise ValueError\n            except tester(ValueError):\n                tester(9)\n                raise TypeError\n            finally:\n                tester(10)\n\n        # PyCharm getting confused somehow?\n        # noinspection PyUnreachableCode\n        str()\n\n        with self.assertRaises(tester(Exception)):\n            if tester(0):\n                pass\n            elif tester(0):\n                pass\n            elif tester(1 / 0):\n                pass\n\n    def test_generator(self):\n        def gen():\n            for x in [1, 2]:\n                yield tester(x)\n\n        gen2 = (tester(x) for x in tester([1, 2]))\n\n        assert list(gen()) == list(gen2) == [1, 2]\n\n    def test_future_import(self):\n        tester(4)\n\n    def test_many_calls(self):\n        node = None\n        start = time.time()\n        for i in range(10000):\n            new_node = Source.executing(inspect.currentframe()).node\n            if node is None:\n                node = new_node\n            else:\n                self.assertIs(node, new_node)\n        self.assertLess(time.time() - start, 1)\n\n    def test_decode_source(self):\n        def check(source, encoding, exception=None, matches=True):\n            encoded = source.encode(encoding)\n            if exception:\n                with self.assertRaises(exception):\n                    Source.decode_source(encoded)\n            else:\n                decoded = Source.decode_source(encoded)\n                if matches:\n                    self.assertEqual(decoded, source)\n                else:\n                    self.assertNotEqual(decoded, source)\n\n        check(u'# coding=utf8\\n\u00e9', 'utf8')\n        check(u'# coding=gbk\\n\u00e9', 'gbk')\n\n        check(u'# coding=utf8\\n\u00e9', 'gbk', exception=UnicodeDecodeError)\n        check(u'# coding=gbk\\n\u00e9', 'utf8', matches=False)\n\n        # In Python 3 the default encoding is assumed to be UTF8\n        if PY3:\n            check(u'\u00e9', 'utf8')\n            check(u'\u00e9', 'gbk', exception=SyntaxError)\n\n    def test_multiline_strings(self):\n        tester('a')\n        tester('''\n            ab''')\n        tester('''\n                    abc\n                    def\n                    '''\n               )\n        str([\n            tester(\n                '''\n                123\n                456\n                '''\n            ),\n            tester(\n                '''\n                345\n                456786\n                '''\n            ),\n        ])\n        tester(\n            [\n                '''\n                123\n                456\n                '''\n                '''\n                345\n                456786\n                '''\n                ,\n                '''\n                123\n                456\n                ''',\n                '''\n                345\n                456786\n                '''\n            ]\n        )\n\n    def test_multiple_statements_on_one_line(self):\n        if tester(1): tester(2)\n        for _ in tester([1, 2]): tester(3)\n\n    def assert_qualname(self, func, qn, check_actual_qualname=True):\n        qualname = Source.for_filename(__file__).code_qualname(func.__code__)\n        self.assertEqual(qn, qualname)\n        if PY3 and check_actual_qualname:\n            self.assertEqual(qn, func.__qualname__)\n        self.assertTrue(qn.endswith(func.__name__))\n\n    def test_qualname(self):\n        self.assert_qualname(C.f, 'C.f')\n        self.assert_qualname(C.D.g, 'C.D.g')\n        self.assert_qualname(f, 'f')\n        self.assert_qualname(f(), 'f.<locals>.g')\n        self.assert_qualname(C.D.h(), 'C.D.h.<locals>.i.<locals>.j')\n        self.assert_qualname(lamb, '<lambda>')\n        foo = lambda_maker()\n        self.assert_qualname(foo, 'lambda_maker.<locals>.foo')\n        self.assert_qualname(foo.x, 'lambda_maker.<locals>.<lambda>')\n        self.assert_qualname(foo(), 'lambda_maker.<locals>.foo.<locals>.<lambda>')\n        self.assert_qualname(foo()(), 'lambda_maker.<locals>.foo.<locals>.<lambda>', check_actual_qualname=False)\n\n    def test_extended_arg(self):\n        source = 'tester(6)\\n%s\\ntester(9)' % list(range(66000))\n        _, filename = tempfile.mkstemp()\n        code = compile(source, filename, 'exec')\n        with open(filename, 'w') as outfile:\n            outfile.write(source)\n        exec(code)\n\n    def test_only(self):\n        for n in range(5):\n            gen = (i for i in range(n))\n            if n == 1:\n                self.assertEqual(only(gen), 0)\n            else:\n                with self.assertRaises(NotOneValueFound):\n                    only(gen)\n\n    def test_invalid_python(self):\n        path = os.path.join(os.path.dirname(__file__), 'not_code.txt', )\n        source = Source.for_filename(path)\n        self.assertIsNone(source.tree)\n\n    def test_executing_methods(self):\n        frame = inspect.currentframe()\n        executing = Source.executing(frame)\n        self.assertEqual(executing.code_qualname(), 'TestStuff.test_executing_methods')\n        if 'pypy' not in sys.version.lower():\n            text = 'Source.executing(frame)'\n            self.assertEqual(executing.text(), text)\n            start, end = executing.text_range()\n            self.assertEqual(executing.source.text[start:end], text)\n\n    def test_attr(self):\n        c = C()\n        c.x = c.y = tester\n        str((c.x.x, c.x.y, c.y.x, c.y.y, c.x.asd, c.y.qwe))"
    ],
    [
        "LOAD_NAME",
        "unittest"
    ],
    [
        "LOAD_ATTR",
        "unittest.TestCase"
    ],
    [
        "CALL_FUNCTION",
        "class TestFile(unittest.TestCase):\n    def test_file(self):\n        source = Source.for_frame(inspect.currentframe())\n        code = compile(source.text, source.filename, 'exec')\n        instructions = get_instructions(code)\n        lineno = None\n        for inst in instructions:\n            if inst.starts_line is not None:\n                lineno = inst.starts_line\n            if not inst.opname.startswith(\n                    ('BINARY_', 'UNARY_', 'LOAD_ATTR', 'LOAD_METHOD', 'LOOKUP_METHOD', 'COMPARE_OP')):\n                continue\n            frame = C()\n            frame.f_lasti = inst.offset\n            frame.f_code = code\n            frame.f_globals = globals()\n            frame.f_lineno = lineno\n            print(inst.opname)\n            assert Source.executing(frame).node is not None"
    ],
    [
        "STORE_NAME",
        "class TestFile(unittest.TestCase):\n    def test_file(self):\n        source = Source.for_frame(inspect.currentframe())\n        code = compile(source.text, source.filename, 'exec')\n        instructions = get_instructions(code)\n        lineno = None\n        for inst in instructions:\n            if inst.starts_line is not None:\n                lineno = inst.starts_line\n            if not inst.opname.startswith(\n                    ('BINARY_', 'UNARY_', 'LOAD_ATTR', 'LOAD_METHOD', 'LOOKUP_METHOD', 'COMPARE_OP')):\n                continue\n            frame = C()\n            frame.f_lasti = inst.offset\n            frame.f_code = code\n            frame.f_globals = globals()\n            frame.f_lineno = lineno\n            print(inst.opname)\n            assert Source.executing(frame).node is not None"
    ],
    [
        "LOAD_NAME",
        "object"
    ],
    [
        "CALL_FUNCTION",
        "class C(object):\n    @staticmethod\n    def f():\n        pass\n\n    class D(object):\n        @staticmethod\n        def g():\n            pass\n\n        @staticmethod\n        def h():\n            def i():\n                def j():\n                    pass\n\n                return j\n\n            return i()"
    ],
    [
        "STORE_NAME",
        "class C(object):\n    @staticmethod\n    def f():\n        pass\n\n    class D(object):\n        @staticmethod\n        def g():\n            pass\n\n        @staticmethod\n        def h():\n            def i():\n                def j():\n                    pass\n\n                return j\n\n            return i()"
    ],
    [
        "LOAD_NAME",
        "TestFile"
    ],
    [
        "CALL_FUNCTION",
        "TestFile()"
    ],
    [
        "LOAD_METHOD",
        "TestFile().test_file"
    ],
    [
        "CALL_METHOD",
        "TestFile().test_file()"
    ],
    [
        "STORE_NAME",
        "def f():\n    def g():\n        pass\n\n    return g"
    ],
    [
        "STORE_NAME",
        "def lambda_maker():\n    def assign(x):\n        def decorator(func):\n            func.x = x\n            return func\n\n        return decorator\n\n    @assign(lambda: 1)\n    def foo():\n        return lambda: lambda: 3\n\n    return foo"
    ],
    [
        "STORE_NAME",
        "lamb"
    ],
    [
        "LOAD_NAME",
        "object"
    ],
    [
        "CALL_FUNCTION",
        "class Tester(object):\n    def get_node(self, typ):\n        frame = inspect.currentframe().f_back.f_back\n        Source.lazycache(frame)\n        node = Source.executing(frame).node\n        assert isinstance(node, typ), (node, typ)\n        return node\n\n    def check(self, node, value):\n        frame = inspect.currentframe().f_back.f_back\n        result = eval(\n            compile(ast.Expression(node), frame.f_code.co_filename, 'eval'),\n            frame.f_globals,\n            frame.f_locals,\n        )\n        assert result == value, (result, value)\n\n    def __call__(self, arg, check_func=True, returns=None):\n        call = self.get_node(ast.Call)\n        self.check(call.args[0], arg)\n        if check_func:\n            self.check(call.func, self)\n        if returns is None:\n            return arg\n        return returns\n\n    def __getattr__(self, item):\n        node = self.get_node(ast.Attribute)\n        self.check(node.value, self)\n        assert node.attr == item\n        return self\n\n    def __getitem__(self, item):\n        node = self.get_node(ast.Subscript)\n        self.check(node.value, self)\n        self.check(node.slice.value, item)\n        return self\n\n    def __add__(self, other):\n        node = self.get_node(ast.BinOp)\n        self.check(node.left, self)\n        self.check(node.right, other)\n        return self\n\n    __pow__ = __mul__ = __sub__ = __add__\n\n    def __invert__(self):\n        node = self.get_node(ast.UnaryOp)\n        self.check(node.operand, self)\n        return self\n\n    __neg__ = __pos__ = __invert__\n\n    def __lt__(self, other):\n        node = self.get_node(ast.Compare)\n        self.check(node.left, self)\n        self.check(node.comparators[0], other)\n        return self\n\n    __ne__ = __ge__ = __lt__"
    ],
    [
        "STORE_NAME",
        "class Tester(object):\n    def get_node(self, typ):\n        frame = inspect.currentframe().f_back.f_back\n        Source.lazycache(frame)\n        node = Source.executing(frame).node\n        assert isinstance(node, typ), (node, typ)\n        return node\n\n    def check(self, node, value):\n        frame = inspect.currentframe().f_back.f_back\n        result = eval(\n            compile(ast.Expression(node), frame.f_code.co_filename, 'eval'),\n            frame.f_globals,\n            frame.f_locals,\n        )\n        assert result == value, (result, value)\n\n    def __call__(self, arg, check_func=True, returns=None):\n        call = self.get_node(ast.Call)\n        self.check(call.args[0], arg)\n        if check_func:\n            self.check(call.func, self)\n        if returns is None:\n            return arg\n        return returns\n\n    def __getattr__(self, item):\n        node = self.get_node(ast.Attribute)\n        self.check(node.value, self)\n        assert node.attr == item\n        return self\n\n    def __getitem__(self, item):\n        node = self.get_node(ast.Subscript)\n        self.check(node.value, self)\n        self.check(node.slice.value, item)\n        return self\n\n    def __add__(self, other):\n        node = self.get_node(ast.BinOp)\n        self.check(node.left, self)\n        self.check(node.right, other)\n        return self\n\n    __pow__ = __mul__ = __sub__ = __add__\n\n    def __invert__(self):\n        node = self.get_node(ast.UnaryOp)\n        self.check(node.operand, self)\n        return self\n\n    __neg__ = __pos__ = __invert__\n\n    def __lt__(self, other):\n        node = self.get_node(ast.Compare)\n        self.check(node.left, self)\n        self.check(node.comparators[0], other)\n        return self\n\n    __ne__ = __ge__ = __lt__"
    ],
    [
        "LOAD_NAME",
        "Tester"
    ],
    [
        "CALL_FUNCTION",
        "Tester()"
    ],
    [
        "STORE_NAME",
        "tester"
    ],
    [
        "LOAD_NAME",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester([1, 2, 3])"
    ],
    [
        "COMPARE_OP",
        "tester([1, 2, 3]) == [1, 2, 3]"
    ],
    [
        "LOAD_NAME",
        "tester"
    ],
    [
        "LOAD_ATTR",
        "tester.asd"
    ],
    [
        "LOAD_NAME",
        "tester"
    ],
    [
        "IS_OP",
        "tester.asd is tester"
    ],
    [
        "LOAD_NAME",
        "tester"
    ],
    [
        "BINARY_SUBSCR",
        "tester[19]"
    ],
    [
        "LOAD_NAME",
        "tester"
    ],
    [
        "IS_OP",
        "tester[19] is tester"
    ],
    [
        "LOAD_NAME",
        "tester"
    ],
    [
        "BINARY_POWER",
        "tester ** 4"
    ],
    [
        "LOAD_NAME",
        "tester"
    ],
    [
        "IS_OP",
        "tester ** 4 is tester"
    ],
    [
        "LOAD_NAME",
        "tester"
    ],
    [
        "BINARY_MULTIPLY",
        "tester * 3"
    ],
    [
        "LOAD_NAME",
        "tester"
    ],
    [
        "IS_OP",
        "tester * 3 is tester"
    ],
    [
        "LOAD_NAME",
        "tester"
    ],
    [
        "BINARY_SUBTRACT",
        "tester - 2"
    ],
    [
        "LOAD_NAME",
        "tester"
    ],
    [
        "IS_OP",
        "tester - 2 is tester"
    ],
    [
        "LOAD_NAME",
        "tester"
    ],
    [
        "BINARY_ADD",
        "tester + 1"
    ],
    [
        "LOAD_NAME",
        "tester"
    ],
    [
        "IS_OP",
        "tester + 1 is tester"
    ],
    [
        "LOAD_NAME",
        "tester"
    ],
    [
        "UNARY_NEGATIVE",
        "-tester"
    ],
    [
        "LOAD_NAME",
        "tester"
    ],
    [
        "IS_OP",
        "-tester is tester"
    ],
    [
        "LOAD_NAME",
        "tester"
    ],
    [
        "UNARY_POSITIVE",
        "+tester"
    ],
    [
        "LOAD_NAME",
        "tester"
    ],
    [
        "IS_OP",
        "+tester is tester"
    ],
    [
        "LOAD_NAME",
        "tester"
    ],
    [
        "UNARY_INVERT",
        "~tester"
    ],
    [
        "LOAD_NAME",
        "tester"
    ],
    [
        "IS_OP",
        "~tester is tester"
    ],
    [
        "LOAD_NAME",
        "tester"
    ],
    [
        "COMPARE_OP",
        "tester < 7"
    ],
    [
        "LOAD_NAME",
        "tester"
    ],
    [
        "IS_OP",
        "(tester < 7) is tester"
    ],
    [
        "LOAD_NAME",
        "tester"
    ],
    [
        "COMPARE_OP",
        "tester >= 78"
    ],
    [
        "LOAD_NAME",
        "tester"
    ],
    [
        "IS_OP",
        "(tester >= 78) is tester"
    ],
    [
        "LOAD_NAME",
        "tester"
    ],
    [
        "COMPARE_OP",
        "tester != 79"
    ],
    [
        "LOAD_NAME",
        "tester"
    ],
    [
        "IS_OP",
        "(tester != 79) is tester"
    ],
    [
        "LOAD_NAME",
        "tester"
    ],
    [
        "LOAD_METHOD",
        "tester.foo"
    ],
    [
        "CALL_METHOD",
        "tester.foo(45, False)"
    ],
    [
        "COMPARE_OP",
        "tester.foo(45, False) == 45"
    ],
    [
        "STORE_NAME",
        "def empty_decorator(func):\n    return func"
    ],
    [
        "STORE_NAME",
        "def decorator_with_args(*_, **__):\n    return empty_decorator"
    ],
    [
        "LOAD_NAME",
        "__name__"
    ],
    [
        "COMPARE_OP",
        "__name__ == '__main__'"
    ],
    [
        "LOAD_NAME",
        "unittest"
    ],
    [
        "LOAD_METHOD",
        "unittest.main"
    ],
    [
        "CALL_METHOD",
        "unittest.main()"
    ],
    [
        "LOAD_NAME",
        "class TestStuff(unittest.TestCase):\n\n    # noinspection PyTrailingSemicolon\n    def test_semicolons(self):\n        # @formatter:off\n        tester(1); tester(2); tester(3)\n        tester(9\n               ); tester(\n            8); tester(\n            99\n        ); tester(33); tester([4,\n                               5, 6, [\n                                7]])\n        # @formatter:on\n\n    def test_decorator(self):\n        @empty_decorator\n        @decorator_with_args(tester('123'), x=int())\n        @tester(list(tuple([1, 2])), returns=empty_decorator)\n        @tester(\n            list(\n                tuple(\n                    [3, 4])),\n            returns=empty_decorator)\n        @empty_decorator\n        @decorator_with_args(\n            str(),\n            x=int())\n        @tester(list(tuple([5, 6])), returns=empty_decorator)\n        @tester(list(tuple([7, 8])), returns=empty_decorator)\n        @empty_decorator\n        @decorator_with_args(tester('sdf'), x=tester('123234'))\n        def foo():\n            pass\n\n    def test_comprehensions(self):\n        # Comprehensions can be separated if they contain different names\n        str([{tester(x) for x in [1]}, {tester(y) for y in [1]}])\n        # or are on different lines\n        str([{tester(x) for x in [1]},\n             {tester(x) for x in [1]}])\n        # or are of different types\n        str([{tester(x) for x in [1]}, list(tester(x) for x in [1])])\n        # but not if everything is the same\n        # noinspection PyTypeChecker\n        # with self.assertRaises((AttributeError, NotOneValueFound)):\n        #     str([{tester(x) for x in [1]}, {tester(x) for x in [2]}])\n\n    def test_lambda(self):\n        self.assertEqual(\n            (lambda x: (tester(x), tester(x)))(tester(3)),\n            (3, 3),\n        )\n        (lambda: (lambda: tester(1))())()\n        self.assertEqual(\n            (lambda: [tester(x) for x in tester([1, 2])])(),\n            [1, 2],\n        )\n\n    def test_closures_and_nested_comprehensions(self):\n        x = 1\n        # @formatter:off\n        str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n\n        def foo():\n            y = 2\n            str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n            str({tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n            str({tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n\n            def bar():\n                z = 3\n                str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+x+y+z): {tester(b+x+y+z): {tester(c+x+y+z) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n\n            bar()\n\n        foo()\n        # @formatter:on\n\n    def test_indirect_call(self):\n        dict(x=tester)['x'](tester)(3, check_func=False)\n\n    def test_compound_statements(self):\n        with self.assertRaises(TypeError):\n            try:\n                for _ in tester([1, 2, 3]):\n                    while tester(0):\n                        pass\n                    else:\n                        tester(4)\n                else:\n                    tester(5)\n                    raise ValueError\n            except tester(ValueError):\n                tester(9)\n                raise TypeError\n            finally:\n                tester(10)\n\n        # PyCharm getting confused somehow?\n        # noinspection PyUnreachableCode\n        str()\n\n        with self.assertRaises(tester(Exception)):\n            if tester(0):\n                pass\n            elif tester(0):\n                pass\n            elif tester(1 / 0):\n                pass\n\n    def test_generator(self):\n        def gen():\n            for x in [1, 2]:\n                yield tester(x)\n\n        gen2 = (tester(x) for x in tester([1, 2]))\n\n        assert list(gen()) == list(gen2) == [1, 2]\n\n    def test_future_import(self):\n        tester(4)\n\n    def test_many_calls(self):\n        node = None\n        start = time.time()\n        for i in range(10000):\n            new_node = Source.executing(inspect.currentframe()).node\n            if node is None:\n                node = new_node\n            else:\n                self.assertIs(node, new_node)\n        self.assertLess(time.time() - start, 1)\n\n    def test_decode_source(self):\n        def check(source, encoding, exception=None, matches=True):\n            encoded = source.encode(encoding)\n            if exception:\n                with self.assertRaises(exception):\n                    Source.decode_source(encoded)\n            else:\n                decoded = Source.decode_source(encoded)\n                if matches:\n                    self.assertEqual(decoded, source)\n                else:\n                    self.assertNotEqual(decoded, source)\n\n        check(u'# coding=utf8\\n\u00e9', 'utf8')\n        check(u'# coding=gbk\\n\u00e9', 'gbk')\n\n        check(u'# coding=utf8\\n\u00e9', 'gbk', exception=UnicodeDecodeError)\n        check(u'# coding=gbk\\n\u00e9', 'utf8', matches=False)\n\n        # In Python 3 the default encoding is assumed to be UTF8\n        if PY3:\n            check(u'\u00e9', 'utf8')\n            check(u'\u00e9', 'gbk', exception=SyntaxError)\n\n    def test_multiline_strings(self):\n        tester('a')\n        tester('''\n            ab''')\n        tester('''\n                    abc\n                    def\n                    '''\n               )\n        str([\n            tester(\n                '''\n                123\n                456\n                '''\n            ),\n            tester(\n                '''\n                345\n                456786\n                '''\n            ),\n        ])\n        tester(\n            [\n                '''\n                123\n                456\n                '''\n                '''\n                345\n                456786\n                '''\n                ,\n                '''\n                123\n                456\n                ''',\n                '''\n                345\n                456786\n                '''\n            ]\n        )\n\n    def test_multiple_statements_on_one_line(self):\n        if tester(1): tester(2)\n        for _ in tester([1, 2]): tester(3)\n\n    def assert_qualname(self, func, qn, check_actual_qualname=True):\n        qualname = Source.for_filename(__file__).code_qualname(func.__code__)\n        self.assertEqual(qn, qualname)\n        if PY3 and check_actual_qualname:\n            self.assertEqual(qn, func.__qualname__)\n        self.assertTrue(qn.endswith(func.__name__))\n\n    def test_qualname(self):\n        self.assert_qualname(C.f, 'C.f')\n        self.assert_qualname(C.D.g, 'C.D.g')\n        self.assert_qualname(f, 'f')\n        self.assert_qualname(f(), 'f.<locals>.g')\n        self.assert_qualname(C.D.h(), 'C.D.h.<locals>.i.<locals>.j')\n        self.assert_qualname(lamb, '<lambda>')\n        foo = lambda_maker()\n        self.assert_qualname(foo, 'lambda_maker.<locals>.foo')\n        self.assert_qualname(foo.x, 'lambda_maker.<locals>.<lambda>')\n        self.assert_qualname(foo(), 'lambda_maker.<locals>.foo.<locals>.<lambda>')\n        self.assert_qualname(foo()(), 'lambda_maker.<locals>.foo.<locals>.<lambda>', check_actual_qualname=False)\n\n    def test_extended_arg(self):\n        source = 'tester(6)\\n%s\\ntester(9)' % list(range(66000))\n        _, filename = tempfile.mkstemp()\n        code = compile(source, filename, 'exec')\n        with open(filename, 'w') as outfile:\n            outfile.write(source)\n        exec(code)\n\n    def test_only(self):\n        for n in range(5):\n            gen = (i for i in range(n))\n            if n == 1:\n                self.assertEqual(only(gen), 0)\n            else:\n                with self.assertRaises(NotOneValueFound):\n                    only(gen)\n\n    def test_invalid_python(self):\n        path = os.path.join(os.path.dirname(__file__), 'not_code.txt', )\n        source = Source.for_filename(path)\n        self.assertIsNone(source.tree)\n\n    def test_executing_methods(self):\n        frame = inspect.currentframe()\n        executing = Source.executing(frame)\n        self.assertEqual(executing.code_qualname(), 'TestStuff.test_executing_methods')\n        if 'pypy' not in sys.version.lower():\n            text = 'Source.executing(frame)'\n            self.assertEqual(executing.text(), text)\n            start, end = executing.text_range()\n            self.assertEqual(executing.source.text[start:end], text)\n\n    def test_attr(self):\n        c = C()\n        c.x = c.y = tester\n        str((c.x.x, c.x.y, c.y.x, c.y.y, c.x.asd, c.y.qwe))"
    ],
    [
        "STORE_NAME",
        "class TestStuff(unittest.TestCase):\n\n    # noinspection PyTrailingSemicolon\n    def test_semicolons(self):\n        # @formatter:off\n        tester(1); tester(2); tester(3)\n        tester(9\n               ); tester(\n            8); tester(\n            99\n        ); tester(33); tester([4,\n                               5, 6, [\n                                7]])\n        # @formatter:on\n\n    def test_decorator(self):\n        @empty_decorator\n        @decorator_with_args(tester('123'), x=int())\n        @tester(list(tuple([1, 2])), returns=empty_decorator)\n        @tester(\n            list(\n                tuple(\n                    [3, 4])),\n            returns=empty_decorator)\n        @empty_decorator\n        @decorator_with_args(\n            str(),\n            x=int())\n        @tester(list(tuple([5, 6])), returns=empty_decorator)\n        @tester(list(tuple([7, 8])), returns=empty_decorator)\n        @empty_decorator\n        @decorator_with_args(tester('sdf'), x=tester('123234'))\n        def foo():\n            pass\n\n    def test_comprehensions(self):\n        # Comprehensions can be separated if they contain different names\n        str([{tester(x) for x in [1]}, {tester(y) for y in [1]}])\n        # or are on different lines\n        str([{tester(x) for x in [1]},\n             {tester(x) for x in [1]}])\n        # or are of different types\n        str([{tester(x) for x in [1]}, list(tester(x) for x in [1])])\n        # but not if everything is the same\n        # noinspection PyTypeChecker\n        # with self.assertRaises((AttributeError, NotOneValueFound)):\n        #     str([{tester(x) for x in [1]}, {tester(x) for x in [2]}])\n\n    def test_lambda(self):\n        self.assertEqual(\n            (lambda x: (tester(x), tester(x)))(tester(3)),\n            (3, 3),\n        )\n        (lambda: (lambda: tester(1))())()\n        self.assertEqual(\n            (lambda: [tester(x) for x in tester([1, 2])])(),\n            [1, 2],\n        )\n\n    def test_closures_and_nested_comprehensions(self):\n        x = 1\n        # @formatter:off\n        str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n\n        def foo():\n            y = 2\n            str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n            str({tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n            str({tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n\n            def bar():\n                z = 3\n                str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+x+y+z): {tester(b+x+y+z): {tester(c+x+y+z) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n\n            bar()\n\n        foo()\n        # @formatter:on\n\n    def test_indirect_call(self):\n        dict(x=tester)['x'](tester)(3, check_func=False)\n\n    def test_compound_statements(self):\n        with self.assertRaises(TypeError):\n            try:\n                for _ in tester([1, 2, 3]):\n                    while tester(0):\n                        pass\n                    else:\n                        tester(4)\n                else:\n                    tester(5)\n                    raise ValueError\n            except tester(ValueError):\n                tester(9)\n                raise TypeError\n            finally:\n                tester(10)\n\n        # PyCharm getting confused somehow?\n        # noinspection PyUnreachableCode\n        str()\n\n        with self.assertRaises(tester(Exception)):\n            if tester(0):\n                pass\n            elif tester(0):\n                pass\n            elif tester(1 / 0):\n                pass\n\n    def test_generator(self):\n        def gen():\n            for x in [1, 2]:\n                yield tester(x)\n\n        gen2 = (tester(x) for x in tester([1, 2]))\n\n        assert list(gen()) == list(gen2) == [1, 2]\n\n    def test_future_import(self):\n        tester(4)\n\n    def test_many_calls(self):\n        node = None\n        start = time.time()\n        for i in range(10000):\n            new_node = Source.executing(inspect.currentframe()).node\n            if node is None:\n                node = new_node\n            else:\n                self.assertIs(node, new_node)\n        self.assertLess(time.time() - start, 1)\n\n    def test_decode_source(self):\n        def check(source, encoding, exception=None, matches=True):\n            encoded = source.encode(encoding)\n            if exception:\n                with self.assertRaises(exception):\n                    Source.decode_source(encoded)\n            else:\n                decoded = Source.decode_source(encoded)\n                if matches:\n                    self.assertEqual(decoded, source)\n                else:\n                    self.assertNotEqual(decoded, source)\n\n        check(u'# coding=utf8\\n\u00e9', 'utf8')\n        check(u'# coding=gbk\\n\u00e9', 'gbk')\n\n        check(u'# coding=utf8\\n\u00e9', 'gbk', exception=UnicodeDecodeError)\n        check(u'# coding=gbk\\n\u00e9', 'utf8', matches=False)\n\n        # In Python 3 the default encoding is assumed to be UTF8\n        if PY3:\n            check(u'\u00e9', 'utf8')\n            check(u'\u00e9', 'gbk', exception=SyntaxError)\n\n    def test_multiline_strings(self):\n        tester('a')\n        tester('''\n            ab''')\n        tester('''\n                    abc\n                    def\n                    '''\n               )\n        str([\n            tester(\n                '''\n                123\n                456\n                '''\n            ),\n            tester(\n                '''\n                345\n                456786\n                '''\n            ),\n        ])\n        tester(\n            [\n                '''\n                123\n                456\n                '''\n                '''\n                345\n                456786\n                '''\n                ,\n                '''\n                123\n                456\n                ''',\n                '''\n                345\n                456786\n                '''\n            ]\n        )\n\n    def test_multiple_statements_on_one_line(self):\n        if tester(1): tester(2)\n        for _ in tester([1, 2]): tester(3)\n\n    def assert_qualname(self, func, qn, check_actual_qualname=True):\n        qualname = Source.for_filename(__file__).code_qualname(func.__code__)\n        self.assertEqual(qn, qualname)\n        if PY3 and check_actual_qualname:\n            self.assertEqual(qn, func.__qualname__)\n        self.assertTrue(qn.endswith(func.__name__))\n\n    def test_qualname(self):\n        self.assert_qualname(C.f, 'C.f')\n        self.assert_qualname(C.D.g, 'C.D.g')\n        self.assert_qualname(f, 'f')\n        self.assert_qualname(f(), 'f.<locals>.g')\n        self.assert_qualname(C.D.h(), 'C.D.h.<locals>.i.<locals>.j')\n        self.assert_qualname(lamb, '<lambda>')\n        foo = lambda_maker()\n        self.assert_qualname(foo, 'lambda_maker.<locals>.foo')\n        self.assert_qualname(foo.x, 'lambda_maker.<locals>.<lambda>')\n        self.assert_qualname(foo(), 'lambda_maker.<locals>.foo.<locals>.<lambda>')\n        self.assert_qualname(foo()(), 'lambda_maker.<locals>.foo.<locals>.<lambda>', check_actual_qualname=False)\n\n    def test_extended_arg(self):\n        source = 'tester(6)\\n%s\\ntester(9)' % list(range(66000))\n        _, filename = tempfile.mkstemp()\n        code = compile(source, filename, 'exec')\n        with open(filename, 'w') as outfile:\n            outfile.write(source)\n        exec(code)\n\n    def test_only(self):\n        for n in range(5):\n            gen = (i for i in range(n))\n            if n == 1:\n                self.assertEqual(only(gen), 0)\n            else:\n                with self.assertRaises(NotOneValueFound):\n                    only(gen)\n\n    def test_invalid_python(self):\n        path = os.path.join(os.path.dirname(__file__), 'not_code.txt', )\n        source = Source.for_filename(path)\n        self.assertIsNone(source.tree)\n\n    def test_executing_methods(self):\n        frame = inspect.currentframe()\n        executing = Source.executing(frame)\n        self.assertEqual(executing.code_qualname(), 'TestStuff.test_executing_methods')\n        if 'pypy' not in sys.version.lower():\n            text = 'Source.executing(frame)'\n            self.assertEqual(executing.text(), text)\n            start, end = executing.text_range()\n            self.assertEqual(executing.source.text[start:end], text)\n\n    def test_attr(self):\n        c = C()\n        c.x = c.y = tester\n        str((c.x.x, c.x.y, c.y.x, c.y.y, c.x.asd, c.y.qwe))"
    ],
    [
        "STORE_NAME",
        "class TestStuff(unittest.TestCase):\n\n    # noinspection PyTrailingSemicolon\n    def test_semicolons(self):\n        # @formatter:off\n        tester(1); tester(2); tester(3)\n        tester(9\n               ); tester(\n            8); tester(\n            99\n        ); tester(33); tester([4,\n                               5, 6, [\n                                7]])\n        # @formatter:on\n\n    def test_decorator(self):\n        @empty_decorator\n        @decorator_with_args(tester('123'), x=int())\n        @tester(list(tuple([1, 2])), returns=empty_decorator)\n        @tester(\n            list(\n                tuple(\n                    [3, 4])),\n            returns=empty_decorator)\n        @empty_decorator\n        @decorator_with_args(\n            str(),\n            x=int())\n        @tester(list(tuple([5, 6])), returns=empty_decorator)\n        @tester(list(tuple([7, 8])), returns=empty_decorator)\n        @empty_decorator\n        @decorator_with_args(tester('sdf'), x=tester('123234'))\n        def foo():\n            pass\n\n    def test_comprehensions(self):\n        # Comprehensions can be separated if they contain different names\n        str([{tester(x) for x in [1]}, {tester(y) for y in [1]}])\n        # or are on different lines\n        str([{tester(x) for x in [1]},\n             {tester(x) for x in [1]}])\n        # or are of different types\n        str([{tester(x) for x in [1]}, list(tester(x) for x in [1])])\n        # but not if everything is the same\n        # noinspection PyTypeChecker\n        # with self.assertRaises((AttributeError, NotOneValueFound)):\n        #     str([{tester(x) for x in [1]}, {tester(x) for x in [2]}])\n\n    def test_lambda(self):\n        self.assertEqual(\n            (lambda x: (tester(x), tester(x)))(tester(3)),\n            (3, 3),\n        )\n        (lambda: (lambda: tester(1))())()\n        self.assertEqual(\n            (lambda: [tester(x) for x in tester([1, 2])])(),\n            [1, 2],\n        )\n\n    def test_closures_and_nested_comprehensions(self):\n        x = 1\n        # @formatter:off\n        str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n\n        def foo():\n            y = 2\n            str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n            str({tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n            str({tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n\n            def bar():\n                z = 3\n                str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+x+y+z): {tester(b+x+y+z): {tester(c+x+y+z) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n\n            bar()\n\n        foo()\n        # @formatter:on\n\n    def test_indirect_call(self):\n        dict(x=tester)['x'](tester)(3, check_func=False)\n\n    def test_compound_statements(self):\n        with self.assertRaises(TypeError):\n            try:\n                for _ in tester([1, 2, 3]):\n                    while tester(0):\n                        pass\n                    else:\n                        tester(4)\n                else:\n                    tester(5)\n                    raise ValueError\n            except tester(ValueError):\n                tester(9)\n                raise TypeError\n            finally:\n                tester(10)\n\n        # PyCharm getting confused somehow?\n        # noinspection PyUnreachableCode\n        str()\n\n        with self.assertRaises(tester(Exception)):\n            if tester(0):\n                pass\n            elif tester(0):\n                pass\n            elif tester(1 / 0):\n                pass\n\n    def test_generator(self):\n        def gen():\n            for x in [1, 2]:\n                yield tester(x)\n\n        gen2 = (tester(x) for x in tester([1, 2]))\n\n        assert list(gen()) == list(gen2) == [1, 2]\n\n    def test_future_import(self):\n        tester(4)\n\n    def test_many_calls(self):\n        node = None\n        start = time.time()\n        for i in range(10000):\n            new_node = Source.executing(inspect.currentframe()).node\n            if node is None:\n                node = new_node\n            else:\n                self.assertIs(node, new_node)\n        self.assertLess(time.time() - start, 1)\n\n    def test_decode_source(self):\n        def check(source, encoding, exception=None, matches=True):\n            encoded = source.encode(encoding)\n            if exception:\n                with self.assertRaises(exception):\n                    Source.decode_source(encoded)\n            else:\n                decoded = Source.decode_source(encoded)\n                if matches:\n                    self.assertEqual(decoded, source)\n                else:\n                    self.assertNotEqual(decoded, source)\n\n        check(u'# coding=utf8\\n\u00e9', 'utf8')\n        check(u'# coding=gbk\\n\u00e9', 'gbk')\n\n        check(u'# coding=utf8\\n\u00e9', 'gbk', exception=UnicodeDecodeError)\n        check(u'# coding=gbk\\n\u00e9', 'utf8', matches=False)\n\n        # In Python 3 the default encoding is assumed to be UTF8\n        if PY3:\n            check(u'\u00e9', 'utf8')\n            check(u'\u00e9', 'gbk', exception=SyntaxError)\n\n    def test_multiline_strings(self):\n        tester('a')\n        tester('''\n            ab''')\n        tester('''\n                    abc\n                    def\n                    '''\n               )\n        str([\n            tester(\n                '''\n                123\n                456\n                '''\n            ),\n            tester(\n                '''\n                345\n                456786\n                '''\n            ),\n        ])\n        tester(\n            [\n                '''\n                123\n                456\n                '''\n                '''\n                345\n                456786\n                '''\n                ,\n                '''\n                123\n                456\n                ''',\n                '''\n                345\n                456786\n                '''\n            ]\n        )\n\n    def test_multiple_statements_on_one_line(self):\n        if tester(1): tester(2)\n        for _ in tester([1, 2]): tester(3)\n\n    def assert_qualname(self, func, qn, check_actual_qualname=True):\n        qualname = Source.for_filename(__file__).code_qualname(func.__code__)\n        self.assertEqual(qn, qualname)\n        if PY3 and check_actual_qualname:\n            self.assertEqual(qn, func.__qualname__)\n        self.assertTrue(qn.endswith(func.__name__))\n\n    def test_qualname(self):\n        self.assert_qualname(C.f, 'C.f')\n        self.assert_qualname(C.D.g, 'C.D.g')\n        self.assert_qualname(f, 'f')\n        self.assert_qualname(f(), 'f.<locals>.g')\n        self.assert_qualname(C.D.h(), 'C.D.h.<locals>.i.<locals>.j')\n        self.assert_qualname(lamb, '<lambda>')\n        foo = lambda_maker()\n        self.assert_qualname(foo, 'lambda_maker.<locals>.foo')\n        self.assert_qualname(foo.x, 'lambda_maker.<locals>.<lambda>')\n        self.assert_qualname(foo(), 'lambda_maker.<locals>.foo.<locals>.<lambda>')\n        self.assert_qualname(foo()(), 'lambda_maker.<locals>.foo.<locals>.<lambda>', check_actual_qualname=False)\n\n    def test_extended_arg(self):\n        source = 'tester(6)\\n%s\\ntester(9)' % list(range(66000))\n        _, filename = tempfile.mkstemp()\n        code = compile(source, filename, 'exec')\n        with open(filename, 'w') as outfile:\n            outfile.write(source)\n        exec(code)\n\n    def test_only(self):\n        for n in range(5):\n            gen = (i for i in range(n))\n            if n == 1:\n                self.assertEqual(only(gen), 0)\n            else:\n                with self.assertRaises(NotOneValueFound):\n                    only(gen)\n\n    def test_invalid_python(self):\n        path = os.path.join(os.path.dirname(__file__), 'not_code.txt', )\n        source = Source.for_filename(path)\n        self.assertIsNone(source.tree)\n\n    def test_executing_methods(self):\n        frame = inspect.currentframe()\n        executing = Source.executing(frame)\n        self.assertEqual(executing.code_qualname(), 'TestStuff.test_executing_methods')\n        if 'pypy' not in sys.version.lower():\n            text = 'Source.executing(frame)'\n            self.assertEqual(executing.text(), text)\n            start, end = executing.text_range()\n            self.assertEqual(executing.source.text[start:end], text)\n\n    def test_attr(self):\n        c = C()\n        c.x = c.y = tester\n        str((c.x.x, c.x.y, c.y.x, c.y.y, c.x.asd, c.y.qwe))"
    ],
    [
        "STORE_NAME",
        "    def test_semicolons(self):\n        # @formatter:off\n        tester(1); tester(2); tester(3)\n        tester(9\n               ); tester(\n            8); tester(\n            99\n        ); tester(33); tester([4,\n                               5, 6, [\n                                7]])"
    ],
    [
        "STORE_NAME",
        "    def test_decorator(self):\n        @empty_decorator\n        @decorator_with_args(tester('123'), x=int())\n        @tester(list(tuple([1, 2])), returns=empty_decorator)\n        @tester(\n            list(\n                tuple(\n                    [3, 4])),\n            returns=empty_decorator)\n        @empty_decorator\n        @decorator_with_args(\n            str(),\n            x=int())\n        @tester(list(tuple([5, 6])), returns=empty_decorator)\n        @tester(list(tuple([7, 8])), returns=empty_decorator)\n        @empty_decorator\n        @decorator_with_args(tester('sdf'), x=tester('123234'))\n        def foo():\n            pass"
    ],
    [
        "STORE_NAME",
        "    def test_comprehensions(self):\n        # Comprehensions can be separated if they contain different names\n        str([{tester(x) for x in [1]}, {tester(y) for y in [1]}])\n        # or are on different lines\n        str([{tester(x) for x in [1]},\n             {tester(x) for x in [1]}])\n        # or are of different types\n        str([{tester(x) for x in [1]}, list(tester(x) for x in [1])])"
    ],
    [
        "STORE_NAME",
        "    def test_lambda(self):\n        self.assertEqual(\n            (lambda x: (tester(x), tester(x)))(tester(3)),\n            (3, 3),\n        )\n        (lambda: (lambda: tester(1))())()\n        self.assertEqual(\n            (lambda: [tester(x) for x in tester([1, 2])])(),\n            [1, 2],\n        )"
    ],
    [
        "STORE_NAME",
        "    def test_closures_and_nested_comprehensions(self):\n        x = 1\n        # @formatter:off\n        str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n\n        def foo():\n            y = 2\n            str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n            str({tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n            str({tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n\n            def bar():\n                z = 3\n                str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+x+y+z): {tester(b+x+y+z): {tester(c+x+y+z) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n\n            bar()\n\n        foo()"
    ],
    [
        "STORE_NAME",
        "    def test_indirect_call(self):\n        dict(x=tester)['x'](tester)(3, check_func=False)"
    ],
    [
        "STORE_NAME",
        "    def test_compound_statements(self):\n        with self.assertRaises(TypeError):\n            try:\n                for _ in tester([1, 2, 3]):\n                    while tester(0):\n                        pass\n                    else:\n                        tester(4)\n                else:\n                    tester(5)\n                    raise ValueError\n            except tester(ValueError):\n                tester(9)\n                raise TypeError\n            finally:\n                tester(10)\n\n        # PyCharm getting confused somehow?\n        # noinspection PyUnreachableCode\n        str()\n\n        with self.assertRaises(tester(Exception)):\n            if tester(0):\n                pass\n            elif tester(0):\n                pass\n            elif tester(1 / 0):\n                pass"
    ],
    [
        "STORE_NAME",
        "    def test_generator(self):\n        def gen():\n            for x in [1, 2]:\n                yield tester(x)\n\n        gen2 = (tester(x) for x in tester([1, 2]))\n\n        assert list(gen()) == list(gen2) == [1, 2]"
    ],
    [
        "STORE_NAME",
        "    def test_future_import(self):\n        tester(4)"
    ],
    [
        "STORE_NAME",
        "    def test_many_calls(self):\n        node = None\n        start = time.time()\n        for i in range(10000):\n            new_node = Source.executing(inspect.currentframe()).node\n            if node is None:\n                node = new_node\n            else:\n                self.assertIs(node, new_node)\n        self.assertLess(time.time() - start, 1)"
    ],
    [
        "STORE_NAME",
        "    def test_decode_source(self):\n        def check(source, encoding, exception=None, matches=True):\n            encoded = source.encode(encoding)\n            if exception:\n                with self.assertRaises(exception):\n                    Source.decode_source(encoded)\n            else:\n                decoded = Source.decode_source(encoded)\n                if matches:\n                    self.assertEqual(decoded, source)\n                else:\n                    self.assertNotEqual(decoded, source)\n\n        check(u'# coding=utf8\\n\u00e9', 'utf8')\n        check(u'# coding=gbk\\n\u00e9', 'gbk')\n\n        check(u'# coding=utf8\\n\u00e9', 'gbk', exception=UnicodeDecodeError)\n        check(u'# coding=gbk\\n\u00e9', 'utf8', matches=False)\n\n        # In Python 3 the default encoding is assumed to be UTF8\n        if PY3:\n            check(u'\u00e9', 'utf8')\n            check(u'\u00e9', 'gbk', exception=SyntaxError)"
    ],
    [
        "STORE_NAME",
        "    def test_multiline_strings(self):\n        tester('a')\n        tester('''\n            ab''')\n        tester('''\n                    abc\n                    def\n                    '''\n               )\n        str([\n            tester(\n                '''\n                123\n                456\n                '''\n            ),\n            tester(\n                '''\n                345\n                456786\n                '''\n            ),\n        ])\n        tester(\n            [\n                '''\n                123\n                456\n                '''\n                '''\n                345\n                456786\n                '''\n                ,\n                '''\n                123\n                456\n                ''',\n                '''\n                345\n                456786\n                '''\n            ]\n        )"
    ],
    [
        "STORE_NAME",
        "    def test_multiple_statements_on_one_line(self):\n        if tester(1): tester(2)\n        for _ in tester([1, 2]): tester(3)"
    ],
    [
        "STORE_NAME",
        "    def assert_qualname(self, func, qn, check_actual_qualname=True):\n        qualname = Source.for_filename(__file__).code_qualname(func.__code__)\n        self.assertEqual(qn, qualname)\n        if PY3 and check_actual_qualname:\n            self.assertEqual(qn, func.__qualname__)\n        self.assertTrue(qn.endswith(func.__name__))"
    ],
    [
        "STORE_NAME",
        "    def test_qualname(self):\n        self.assert_qualname(C.f, 'C.f')\n        self.assert_qualname(C.D.g, 'C.D.g')\n        self.assert_qualname(f, 'f')\n        self.assert_qualname(f(), 'f.<locals>.g')\n        self.assert_qualname(C.D.h(), 'C.D.h.<locals>.i.<locals>.j')\n        self.assert_qualname(lamb, '<lambda>')\n        foo = lambda_maker()\n        self.assert_qualname(foo, 'lambda_maker.<locals>.foo')\n        self.assert_qualname(foo.x, 'lambda_maker.<locals>.<lambda>')\n        self.assert_qualname(foo(), 'lambda_maker.<locals>.foo.<locals>.<lambda>')\n        self.assert_qualname(foo()(), 'lambda_maker.<locals>.foo.<locals>.<lambda>', check_actual_qualname=False)"
    ],
    [
        "STORE_NAME",
        "    def test_extended_arg(self):\n        source = 'tester(6)\\n%s\\ntester(9)' % list(range(66000))\n        _, filename = tempfile.mkstemp()\n        code = compile(source, filename, 'exec')\n        with open(filename, 'w') as outfile:\n            outfile.write(source)\n        exec(code)"
    ],
    [
        "STORE_NAME",
        "    def test_only(self):\n        for n in range(5):\n            gen = (i for i in range(n))\n            if n == 1:\n                self.assertEqual(only(gen), 0)\n            else:\n                with self.assertRaises(NotOneValueFound):\n                    only(gen)"
    ],
    [
        "STORE_NAME",
        "    def test_invalid_python(self):\n        path = os.path.join(os.path.dirname(__file__), 'not_code.txt', )\n        source = Source.for_filename(path)\n        self.assertIsNone(source.tree)"
    ],
    [
        "STORE_NAME",
        "    def test_executing_methods(self):\n        frame = inspect.currentframe()\n        executing = Source.executing(frame)\n        self.assertEqual(executing.code_qualname(), 'TestStuff.test_executing_methods')\n        if 'pypy' not in sys.version.lower():\n            text = 'Source.executing(frame)'\n            self.assertEqual(executing.text(), text)\n            start, end = executing.text_range()\n            self.assertEqual(executing.source.text[start:end], text)"
    ],
    [
        "STORE_NAME",
        "    def test_attr(self):\n        c = C()\n        c.x = c.y = tester\n        str((c.x.x, c.x.y, c.y.x, c.y.y, c.x.asd, c.y.qwe))"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester(1)"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester(2)"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester(3)"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester(9\n               )"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester(\n            8)"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester(\n            99\n        )"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester(33)"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester([4,\n                               5, 6, [\n                                7]])"
    ],
    [
        "LOAD_GLOBAL",
        "empty_decorator"
    ],
    [
        "LOAD_GLOBAL",
        "decorator_with_args"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester('123')"
    ],
    [
        "LOAD_GLOBAL",
        "int"
    ],
    [
        "CALL_FUNCTION",
        "int()"
    ],
    [
        "CALL_FUNCTION_KW",
        "decorator_with_args(tester('123'), x=int())"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "LOAD_GLOBAL",
        "list"
    ],
    [
        "LOAD_GLOBAL",
        "tuple"
    ],
    [
        "CALL_FUNCTION",
        "tuple([1, 2])"
    ],
    [
        "CALL_FUNCTION",
        "list(tuple([1, 2]))"
    ],
    [
        "LOAD_GLOBAL",
        "empty_decorator"
    ],
    [
        "CALL_FUNCTION_KW",
        "tester(list(tuple([1, 2])), returns=empty_decorator)"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "LOAD_GLOBAL",
        "list"
    ],
    [
        "LOAD_GLOBAL",
        "tuple"
    ],
    [
        "CALL_FUNCTION",
        "tuple(\n                    [3, 4])"
    ],
    [
        "CALL_FUNCTION",
        "list(\n                tuple(\n                    [3, 4]))"
    ],
    [
        "LOAD_GLOBAL",
        "empty_decorator"
    ],
    [
        "CALL_FUNCTION_KW",
        "tester(\n            list(\n                tuple(\n                    [3, 4])),\n            returns=empty_decorator)"
    ],
    [
        "LOAD_GLOBAL",
        "empty_decorator"
    ],
    [
        "LOAD_GLOBAL",
        "decorator_with_args"
    ],
    [
        "LOAD_GLOBAL",
        "str"
    ],
    [
        "CALL_FUNCTION",
        "str()"
    ],
    [
        "LOAD_GLOBAL",
        "int"
    ],
    [
        "CALL_FUNCTION",
        "int()"
    ],
    [
        "CALL_FUNCTION_KW",
        "decorator_with_args(\n            str(),\n            x=int())"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "LOAD_GLOBAL",
        "list"
    ],
    [
        "LOAD_GLOBAL",
        "tuple"
    ],
    [
        "CALL_FUNCTION",
        "tuple([5, 6])"
    ],
    [
        "CALL_FUNCTION",
        "list(tuple([5, 6]))"
    ],
    [
        "LOAD_GLOBAL",
        "empty_decorator"
    ],
    [
        "CALL_FUNCTION_KW",
        "tester(list(tuple([5, 6])), returns=empty_decorator)"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "LOAD_GLOBAL",
        "list"
    ],
    [
        "LOAD_GLOBAL",
        "tuple"
    ],
    [
        "CALL_FUNCTION",
        "tuple([7, 8])"
    ],
    [
        "CALL_FUNCTION",
        "list(tuple([7, 8]))"
    ],
    [
        "LOAD_GLOBAL",
        "empty_decorator"
    ],
    [
        "CALL_FUNCTION_KW",
        "tester(list(tuple([7, 8])), returns=empty_decorator)"
    ],
    [
        "LOAD_GLOBAL",
        "empty_decorator"
    ],
    [
        "LOAD_GLOBAL",
        "decorator_with_args"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester('sdf')"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester('123234')"
    ],
    [
        "CALL_FUNCTION_KW",
        "decorator_with_args(tester('sdf'), x=tester('123234'))"
    ],
    [
        "CALL_FUNCTION",
        "decorator_with_args(tester('sdf'), x=tester('123234'))"
    ],
    [
        "CALL_FUNCTION",
        "empty_decorator"
    ],
    [
        "CALL_FUNCTION",
        "tester(list(tuple([7, 8])), returns=empty_decorator)"
    ],
    [
        "CALL_FUNCTION",
        "tester(list(tuple([5, 6])), returns=empty_decorator)"
    ],
    [
        "CALL_FUNCTION",
        "decorator_with_args(\n            str(),\n            x=int())"
    ],
    [
        "CALL_FUNCTION",
        "empty_decorator"
    ],
    [
        "CALL_FUNCTION",
        "tester(\n            list(\n                tuple(\n                    [3, 4])),\n            returns=empty_decorator)"
    ],
    [
        "CALL_FUNCTION",
        "tester(list(tuple([1, 2])), returns=empty_decorator)"
    ],
    [
        "CALL_FUNCTION",
        "decorator_with_args(tester('123'), x=int())"
    ],
    [
        "CALL_FUNCTION",
        "empty_decorator"
    ],
    [
        "STORE_FAST",
        "        @empty_decorator\n        @decorator_with_args(tester('123'), x=int())\n        @tester(list(tuple([1, 2])), returns=empty_decorator)\n        @tester(\n            list(\n                tuple(\n                    [3, 4])),\n            returns=empty_decorator)\n        @empty_decorator\n        @decorator_with_args(\n            str(),\n            x=int())\n        @tester(list(tuple([5, 6])), returns=empty_decorator)\n        @tester(list(tuple([7, 8])), returns=empty_decorator)\n        @empty_decorator\n        @decorator_with_args(tester('sdf'), x=tester('123234'))\n        def foo():\n            pass"
    ],
    [
        "LOAD_GLOBAL",
        "str"
    ],
    [
        "CALL_FUNCTION",
        "{tester(x) for x in [1]}"
    ],
    [
        "CALL_FUNCTION",
        "{tester(y) for y in [1]}"
    ],
    [
        "CALL_FUNCTION",
        "str([{tester(x) for x in [1]}, {tester(y) for y in [1]}])"
    ],
    [
        "LOAD_GLOBAL",
        "str"
    ],
    [
        "CALL_FUNCTION",
        "{tester(x) for x in [1]}"
    ],
    [
        "CALL_FUNCTION",
        "{tester(x) for x in [1]}"
    ],
    [
        "CALL_FUNCTION",
        "str([{tester(x) for x in [1]},\n             {tester(x) for x in [1]}])"
    ],
    [
        "LOAD_GLOBAL",
        "str"
    ],
    [
        "CALL_FUNCTION",
        "{tester(x) for x in [1]}"
    ],
    [
        "LOAD_GLOBAL",
        "list"
    ],
    [
        "CALL_FUNCTION",
        "(tester(x) for x in [1])"
    ],
    [
        "CALL_FUNCTION",
        "list(tester(x) for x in [1])"
    ],
    [
        "CALL_FUNCTION",
        "str([{tester(x) for x in [1]}, list(tester(x) for x in [1])])"
    ],
    [
        "LOAD_FAST",
        "{tester(x) for x in [1]}"
    ],
    [
        "STORE_FAST",
        "x"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "LOAD_FAST",
        "x"
    ],
    [
        "CALL_FUNCTION",
        "tester(x)"
    ],
    [
        "LOAD_FAST",
        "{tester(y) for y in [1]}"
    ],
    [
        "STORE_FAST",
        "y"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "LOAD_FAST",
        "y"
    ],
    [
        "CALL_FUNCTION",
        "tester(y)"
    ],
    [
        "LOAD_FAST",
        "{tester(x) for x in [1]}"
    ],
    [
        "STORE_FAST",
        "x"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "LOAD_FAST",
        "x"
    ],
    [
        "CALL_FUNCTION",
        "tester(x)"
    ],
    [
        "LOAD_FAST",
        "{tester(x) for x in [1]}"
    ],
    [
        "STORE_FAST",
        "x"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "LOAD_FAST",
        "x"
    ],
    [
        "CALL_FUNCTION",
        "tester(x)"
    ],
    [
        "LOAD_FAST",
        "{tester(x) for x in [1]}"
    ],
    [
        "STORE_FAST",
        "x"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "LOAD_FAST",
        "x"
    ],
    [
        "CALL_FUNCTION",
        "tester(x)"
    ],
    [
        "LOAD_FAST",
        "(tester(x) for x in [1])"
    ],
    [
        "STORE_FAST",
        "x"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "LOAD_FAST",
        "x"
    ],
    [
        "CALL_FUNCTION",
        "tester(x)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.assertEqual"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester(3)"
    ],
    [
        "CALL_FUNCTION",
        "(lambda x: (tester(x), tester(x)))(tester(3))"
    ],
    [
        "CALL_METHOD",
        "self.assertEqual(\n            (lambda x: (tester(x), tester(x)))(tester(3)),\n            (3, 3),\n        )"
    ],
    [
        "CALL_FUNCTION",
        "(lambda: (lambda: tester(1))())()"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.assertEqual"
    ],
    [
        "CALL_FUNCTION",
        "(lambda: [tester(x) for x in tester([1, 2])])()"
    ],
    [
        "CALL_METHOD",
        "self.assertEqual(\n            (lambda: [tester(x) for x in tester([1, 2])])(),\n            [1, 2],\n        )"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "LOAD_FAST",
        "x"
    ],
    [
        "CALL_FUNCTION",
        "tester(x)"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "LOAD_FAST",
        "x"
    ],
    [
        "CALL_FUNCTION",
        "tester(x)"
    ],
    [
        "CALL_FUNCTION",
        "(lambda: tester(1))()"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester(1)"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester([1, 2])"
    ],
    [
        "CALL_FUNCTION",
        "[tester(x) for x in tester([1, 2])]"
    ],
    [
        "LOAD_FAST",
        "[tester(x) for x in tester([1, 2])]"
    ],
    [
        "STORE_FAST",
        "x"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "LOAD_FAST",
        "x"
    ],
    [
        "CALL_FUNCTION",
        "tester(x)"
    ],
    [
        "STORE_DEREF",
        "x"
    ],
    [
        "LOAD_GLOBAL",
        "str"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester([5, 6])"
    ],
    [
        "CALL_FUNCTION",
        "{tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
    ],
    [
        "CALL_FUNCTION",
        "str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})"
    ],
    [
        "STORE_FAST",
        "        def foo():\n            y = 2\n            str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n            str({tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n            str({tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n\n            def bar():\n                z = 3\n                str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+x+y+z): {tester(b+x+y+z): {tester(c+x+y+z) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n\n            bar()"
    ],
    [
        "LOAD_FAST",
        "foo"
    ],
    [
        "CALL_FUNCTION",
        "foo()"
    ],
    [
        "LOAD_FAST",
        "{tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
    ],
    [
        "STORE_FAST",
        "a"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "LOAD_FAST",
        "a"
    ],
    [
        "LOAD_DEREF",
        "x"
    ],
    [
        "BINARY_ADD",
        "a+x"
    ],
    [
        "CALL_FUNCTION",
        "tester(a+x)"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester([3, 4])"
    ],
    [
        "CALL_FUNCTION",
        "{tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])}"
    ],
    [
        "LOAD_FAST",
        "{tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])}"
    ],
    [
        "STORE_FAST",
        "b"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "LOAD_FAST",
        "b"
    ],
    [
        "LOAD_DEREF",
        "x"
    ],
    [
        "BINARY_ADD",
        "b+x"
    ],
    [
        "CALL_FUNCTION",
        "tester(b+x)"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester([1, 2])"
    ],
    [
        "CALL_FUNCTION",
        "{tester(c+x) for c in tester([1, 2])}"
    ],
    [
        "LOAD_FAST",
        "{tester(c+x) for c in tester([1, 2])}"
    ],
    [
        "STORE_FAST",
        "c"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "LOAD_FAST",
        "c"
    ],
    [
        "LOAD_DEREF",
        "x"
    ],
    [
        "BINARY_ADD",
        "c+x"
    ],
    [
        "CALL_FUNCTION",
        "tester(c+x)"
    ],
    [
        "STORE_DEREF",
        "y"
    ],
    [
        "LOAD_GLOBAL",
        "str"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester([5, 6])"
    ],
    [
        "CALL_FUNCTION",
        "{tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
    ],
    [
        "CALL_FUNCTION",
        "str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})"
    ],
    [
        "LOAD_GLOBAL",
        "str"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester([5, 6])"
    ],
    [
        "CALL_FUNCTION",
        "{tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
    ],
    [
        "CALL_FUNCTION",
        "str({tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})"
    ],
    [
        "LOAD_GLOBAL",
        "str"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester([5, 6])"
    ],
    [
        "CALL_FUNCTION",
        "{tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
    ],
    [
        "CALL_FUNCTION",
        "str({tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})"
    ],
    [
        "STORE_FAST",
        "            def bar():\n                z = 3\n                str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})\n                str({tester(a+x+y+z): {tester(b+x+y+z): {tester(c+x+y+z) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})"
    ],
    [
        "LOAD_FAST",
        "bar"
    ],
    [
        "CALL_FUNCTION",
        "bar()"
    ],
    [
        "LOAD_FAST",
        "{tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
    ],
    [
        "STORE_FAST",
        "a"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "LOAD_FAST",
        "a"
    ],
    [
        "LOAD_DEREF",
        "x"
    ],
    [
        "BINARY_ADD",
        "a+x"
    ],
    [
        "CALL_FUNCTION",
        "tester(a+x)"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester([3, 4])"
    ],
    [
        "CALL_FUNCTION",
        "{tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])}"
    ],
    [
        "LOAD_FAST",
        "{tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])}"
    ],
    [
        "STORE_FAST",
        "b"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "LOAD_FAST",
        "b"
    ],
    [
        "LOAD_DEREF",
        "x"
    ],
    [
        "BINARY_ADD",
        "b+x"
    ],
    [
        "CALL_FUNCTION",
        "tester(b+x)"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester([1, 2])"
    ],
    [
        "CALL_FUNCTION",
        "{tester(c+x) for c in tester([1, 2])}"
    ],
    [
        "LOAD_FAST",
        "{tester(c+x) for c in tester([1, 2])}"
    ],
    [
        "STORE_FAST",
        "c"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "LOAD_FAST",
        "c"
    ],
    [
        "LOAD_DEREF",
        "x"
    ],
    [
        "BINARY_ADD",
        "c+x"
    ],
    [
        "CALL_FUNCTION",
        "tester(c+x)"
    ],
    [
        "LOAD_FAST",
        "{tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
    ],
    [
        "STORE_FAST",
        "a"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "LOAD_FAST",
        "a"
    ],
    [
        "LOAD_DEREF",
        "y"
    ],
    [
        "BINARY_ADD",
        "a+y"
    ],
    [
        "CALL_FUNCTION",
        "tester(a+y)"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester([3, 4])"
    ],
    [
        "CALL_FUNCTION",
        "{tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])}"
    ],
    [
        "LOAD_FAST",
        "{tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])}"
    ],
    [
        "STORE_FAST",
        "b"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "LOAD_FAST",
        "b"
    ],
    [
        "LOAD_DEREF",
        "y"
    ],
    [
        "BINARY_ADD",
        "b+y"
    ],
    [
        "CALL_FUNCTION",
        "tester(b+y)"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester([1, 2])"
    ],
    [
        "CALL_FUNCTION",
        "{tester(c+y) for c in tester([1, 2])}"
    ],
    [
        "LOAD_FAST",
        "{tester(c+y) for c in tester([1, 2])}"
    ],
    [
        "STORE_FAST",
        "c"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "LOAD_FAST",
        "c"
    ],
    [
        "LOAD_DEREF",
        "y"
    ],
    [
        "BINARY_ADD",
        "c+y"
    ],
    [
        "CALL_FUNCTION",
        "tester(c+y)"
    ],
    [
        "LOAD_FAST",
        "{tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
    ],
    [
        "STORE_FAST",
        "a"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "LOAD_FAST",
        "a"
    ],
    [
        "LOAD_DEREF",
        "x"
    ],
    [
        "BINARY_ADD",
        "a+x"
    ],
    [
        "LOAD_DEREF",
        "y"
    ],
    [
        "BINARY_ADD",
        "a+x+y"
    ],
    [
        "CALL_FUNCTION",
        "tester(a+x+y)"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester([3, 4])"
    ],
    [
        "CALL_FUNCTION",
        "{tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])}"
    ],
    [
        "LOAD_FAST",
        "{tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])}"
    ],
    [
        "STORE_FAST",
        "b"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "LOAD_FAST",
        "b"
    ],
    [
        "LOAD_DEREF",
        "x"
    ],
    [
        "BINARY_ADD",
        "b+x"
    ],
    [
        "LOAD_DEREF",
        "y"
    ],
    [
        "BINARY_ADD",
        "b+x+y"
    ],
    [
        "CALL_FUNCTION",
        "tester(b+x+y)"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester([1, 2])"
    ],
    [
        "CALL_FUNCTION",
        "{tester(c+x+y) for c in tester([1, 2])}"
    ],
    [
        "LOAD_FAST",
        "{tester(c+x+y) for c in tester([1, 2])}"
    ],
    [
        "STORE_FAST",
        "c"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "LOAD_FAST",
        "c"
    ],
    [
        "LOAD_DEREF",
        "x"
    ],
    [
        "BINARY_ADD",
        "c+x"
    ],
    [
        "LOAD_DEREF",
        "y"
    ],
    [
        "BINARY_ADD",
        "c+x+y"
    ],
    [
        "CALL_FUNCTION",
        "tester(c+x+y)"
    ],
    [
        "STORE_DEREF",
        "z"
    ],
    [
        "LOAD_GLOBAL",
        "str"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester([5, 6])"
    ],
    [
        "CALL_FUNCTION",
        "{tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
    ],
    [
        "CALL_FUNCTION",
        "str({tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})"
    ],
    [
        "LOAD_GLOBAL",
        "str"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester([5, 6])"
    ],
    [
        "CALL_FUNCTION",
        "{tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
    ],
    [
        "CALL_FUNCTION",
        "str({tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})"
    ],
    [
        "LOAD_GLOBAL",
        "str"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester([5, 6])"
    ],
    [
        "CALL_FUNCTION",
        "{tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
    ],
    [
        "CALL_FUNCTION",
        "str({tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})"
    ],
    [
        "LOAD_GLOBAL",
        "str"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester([5, 6])"
    ],
    [
        "CALL_FUNCTION",
        "{tester(a+x+y+z): {tester(b+x+y+z): {tester(c+x+y+z) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
    ],
    [
        "CALL_FUNCTION",
        "str({tester(a+x+y+z): {tester(b+x+y+z): {tester(c+x+y+z) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])})"
    ],
    [
        "LOAD_FAST",
        "{tester(a+x): {tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
    ],
    [
        "STORE_FAST",
        "a"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "LOAD_FAST",
        "a"
    ],
    [
        "LOAD_DEREF",
        "x"
    ],
    [
        "BINARY_ADD",
        "a+x"
    ],
    [
        "CALL_FUNCTION",
        "tester(a+x)"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester([3, 4])"
    ],
    [
        "CALL_FUNCTION",
        "{tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])}"
    ],
    [
        "LOAD_FAST",
        "{tester(b+x): {tester(c+x) for c in tester([1, 2])} for b in tester([3, 4])}"
    ],
    [
        "STORE_FAST",
        "b"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "LOAD_FAST",
        "b"
    ],
    [
        "LOAD_DEREF",
        "x"
    ],
    [
        "BINARY_ADD",
        "b+x"
    ],
    [
        "CALL_FUNCTION",
        "tester(b+x)"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester([1, 2])"
    ],
    [
        "CALL_FUNCTION",
        "{tester(c+x) for c in tester([1, 2])}"
    ],
    [
        "LOAD_FAST",
        "{tester(c+x) for c in tester([1, 2])}"
    ],
    [
        "STORE_FAST",
        "c"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "LOAD_FAST",
        "c"
    ],
    [
        "LOAD_DEREF",
        "x"
    ],
    [
        "BINARY_ADD",
        "c+x"
    ],
    [
        "CALL_FUNCTION",
        "tester(c+x)"
    ],
    [
        "LOAD_FAST",
        "{tester(a+y): {tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
    ],
    [
        "STORE_FAST",
        "a"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "LOAD_FAST",
        "a"
    ],
    [
        "LOAD_DEREF",
        "y"
    ],
    [
        "BINARY_ADD",
        "a+y"
    ],
    [
        "CALL_FUNCTION",
        "tester(a+y)"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester([3, 4])"
    ],
    [
        "CALL_FUNCTION",
        "{tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])}"
    ],
    [
        "LOAD_FAST",
        "{tester(b+y): {tester(c+y) for c in tester([1, 2])} for b in tester([3, 4])}"
    ],
    [
        "STORE_FAST",
        "b"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "LOAD_FAST",
        "b"
    ],
    [
        "LOAD_DEREF",
        "y"
    ],
    [
        "BINARY_ADD",
        "b+y"
    ],
    [
        "CALL_FUNCTION",
        "tester(b+y)"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester([1, 2])"
    ],
    [
        "CALL_FUNCTION",
        "{tester(c+y) for c in tester([1, 2])}"
    ],
    [
        "LOAD_FAST",
        "{tester(c+y) for c in tester([1, 2])}"
    ],
    [
        "STORE_FAST",
        "c"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "LOAD_FAST",
        "c"
    ],
    [
        "LOAD_DEREF",
        "y"
    ],
    [
        "BINARY_ADD",
        "c+y"
    ],
    [
        "CALL_FUNCTION",
        "tester(c+y)"
    ],
    [
        "LOAD_FAST",
        "{tester(a+x+y): {tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
    ],
    [
        "STORE_FAST",
        "a"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "LOAD_FAST",
        "a"
    ],
    [
        "LOAD_DEREF",
        "x"
    ],
    [
        "BINARY_ADD",
        "a+x"
    ],
    [
        "LOAD_DEREF",
        "y"
    ],
    [
        "BINARY_ADD",
        "a+x+y"
    ],
    [
        "CALL_FUNCTION",
        "tester(a+x+y)"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester([3, 4])"
    ],
    [
        "CALL_FUNCTION",
        "{tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])}"
    ],
    [
        "LOAD_FAST",
        "{tester(b+x+y): {tester(c+x+y) for c in tester([1, 2])} for b in tester([3, 4])}"
    ],
    [
        "STORE_FAST",
        "b"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "LOAD_FAST",
        "b"
    ],
    [
        "LOAD_DEREF",
        "x"
    ],
    [
        "BINARY_ADD",
        "b+x"
    ],
    [
        "LOAD_DEREF",
        "y"
    ],
    [
        "BINARY_ADD",
        "b+x+y"
    ],
    [
        "CALL_FUNCTION",
        "tester(b+x+y)"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester([1, 2])"
    ],
    [
        "CALL_FUNCTION",
        "{tester(c+x+y) for c in tester([1, 2])}"
    ],
    [
        "LOAD_FAST",
        "{tester(c+x+y) for c in tester([1, 2])}"
    ],
    [
        "STORE_FAST",
        "c"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "LOAD_FAST",
        "c"
    ],
    [
        "LOAD_DEREF",
        "x"
    ],
    [
        "BINARY_ADD",
        "c+x"
    ],
    [
        "LOAD_DEREF",
        "y"
    ],
    [
        "BINARY_ADD",
        "c+x+y"
    ],
    [
        "CALL_FUNCTION",
        "tester(c+x+y)"
    ],
    [
        "LOAD_FAST",
        "{tester(a+x+y+z): {tester(b+x+y+z): {tester(c+x+y+z) for c in tester([1, 2])} for b in tester([3, 4])} for a in tester([5, 6])}"
    ],
    [
        "STORE_FAST",
        "a"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "LOAD_FAST",
        "a"
    ],
    [
        "LOAD_DEREF",
        "x"
    ],
    [
        "BINARY_ADD",
        "a+x"
    ],
    [
        "LOAD_DEREF",
        "y"
    ],
    [
        "BINARY_ADD",
        "a+x+y"
    ],
    [
        "LOAD_DEREF",
        "z"
    ],
    [
        "BINARY_ADD",
        "a+x+y+z"
    ],
    [
        "CALL_FUNCTION",
        "tester(a+x+y+z)"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester([3, 4])"
    ],
    [
        "CALL_FUNCTION",
        "{tester(b+x+y+z): {tester(c+x+y+z) for c in tester([1, 2])} for b in tester([3, 4])}"
    ],
    [
        "LOAD_FAST",
        "{tester(b+x+y+z): {tester(c+x+y+z) for c in tester([1, 2])} for b in tester([3, 4])}"
    ],
    [
        "STORE_FAST",
        "b"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "LOAD_FAST",
        "b"
    ],
    [
        "LOAD_DEREF",
        "x"
    ],
    [
        "BINARY_ADD",
        "b+x"
    ],
    [
        "LOAD_DEREF",
        "y"
    ],
    [
        "BINARY_ADD",
        "b+x+y"
    ],
    [
        "LOAD_DEREF",
        "z"
    ],
    [
        "BINARY_ADD",
        "b+x+y+z"
    ],
    [
        "CALL_FUNCTION",
        "tester(b+x+y+z)"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester([1, 2])"
    ],
    [
        "CALL_FUNCTION",
        "{tester(c+x+y+z) for c in tester([1, 2])}"
    ],
    [
        "LOAD_FAST",
        "{tester(c+x+y+z) for c in tester([1, 2])}"
    ],
    [
        "STORE_FAST",
        "c"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "LOAD_FAST",
        "c"
    ],
    [
        "LOAD_DEREF",
        "x"
    ],
    [
        "BINARY_ADD",
        "c+x"
    ],
    [
        "LOAD_DEREF",
        "y"
    ],
    [
        "BINARY_ADD",
        "c+x+y"
    ],
    [
        "LOAD_DEREF",
        "z"
    ],
    [
        "BINARY_ADD",
        "c+x+y+z"
    ],
    [
        "CALL_FUNCTION",
        "tester(c+x+y+z)"
    ],
    [
        "LOAD_GLOBAL",
        "dict"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION_KW",
        "dict(x=tester)"
    ],
    [
        "BINARY_SUBSCR",
        "dict(x=tester)['x']"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "dict(x=tester)['x'](tester)"
    ],
    [
        "CALL_FUNCTION_KW",
        "dict(x=tester)['x'](tester)(3, check_func=False)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.assertRaises"
    ],
    [
        "LOAD_GLOBAL",
        "TypeError"
    ],
    [
        "CALL_METHOD",
        "self.assertRaises(TypeError)"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester([1, 2, 3])"
    ],
    [
        "STORE_FAST",
        "_"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester(0)"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester(0)"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester(4)"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester(5)"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "CALL_FUNCTION",
        "tester(ValueError)"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester(9)"
    ],
    [
        "LOAD_GLOBAL",
        "TypeError"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester(10)"
    ],
    [
        "LOAD_GLOBAL",
        "str"
    ],
    [
        "CALL_FUNCTION",
        "str()"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.assertRaises"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "LOAD_GLOBAL",
        "Exception"
    ],
    [
        "CALL_FUNCTION",
        "tester(Exception)"
    ],
    [
        "CALL_METHOD",
        "self.assertRaises(tester(Exception))"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester(0)"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester(0)"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "BINARY_TRUE_DIVIDE",
        "1 / 0"
    ],
    [
        "CALL_FUNCTION",
        "tester(1 / 0)"
    ],
    [
        "CALL_FUNCTION",
        "        with self.assertRaises(tester(Exception)):\n            if tester(0):\n                pass\n            elif tester(0):\n                pass\n            elif tester(1 / 0):\n                pass"
    ],
    [
        "CALL_FUNCTION",
        "        with self.assertRaises(tester(Exception)):\n            if tester(0):\n                pass\n            elif tester(0):\n                pass\n            elif tester(1 / 0):\n                pass"
    ],
    [
        "CALL_FUNCTION",
        "        with self.assertRaises(tester(Exception)):\n            if tester(0):\n                pass\n            elif tester(0):\n                pass\n            elif tester(1 / 0):\n                pass"
    ],
    [
        "CALL_FUNCTION",
        "        with self.assertRaises(tester(Exception)):\n            if tester(0):\n                pass\n            elif tester(0):\n                pass\n            elif tester(1 / 0):\n                pass"
    ],
    [
        "STORE_FAST",
        "        def gen():\n            for x in [1, 2]:\n                yield tester(x)"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester([1, 2])"
    ],
    [
        "CALL_FUNCTION",
        "(tester(x) for x in tester([1, 2]))"
    ],
    [
        "STORE_FAST",
        "gen2"
    ],
    [
        "LOAD_GLOBAL",
        "list"
    ],
    [
        "LOAD_FAST",
        "gen"
    ],
    [
        "CALL_FUNCTION",
        "gen()"
    ],
    [
        "CALL_FUNCTION",
        "list(gen())"
    ],
    [
        "LOAD_GLOBAL",
        "list"
    ],
    [
        "LOAD_FAST",
        "gen2"
    ],
    [
        "CALL_FUNCTION",
        "list(gen2)"
    ],
    [
        "COMPARE_OP",
        "list(gen()) == list(gen2) == [1, 2]"
    ],
    [
        "COMPARE_OP",
        "list(gen()) == list(gen2) == [1, 2]"
    ],
    [
        "STORE_FAST",
        "x"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "LOAD_FAST",
        "x"
    ],
    [
        "CALL_FUNCTION",
        "tester(x)"
    ],
    [
        "LOAD_FAST",
        "(tester(x) for x in tester([1, 2]))"
    ],
    [
        "STORE_FAST",
        "x"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "LOAD_FAST",
        "x"
    ],
    [
        "CALL_FUNCTION",
        "tester(x)"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester(4)"
    ],
    [
        "STORE_FAST",
        "node"
    ],
    [
        "LOAD_GLOBAL",
        "time"
    ],
    [
        "LOAD_METHOD",
        "time.time"
    ],
    [
        "CALL_METHOD",
        "time.time()"
    ],
    [
        "STORE_FAST",
        "start"
    ],
    [
        "LOAD_GLOBAL",
        "range"
    ],
    [
        "CALL_FUNCTION",
        "range(10000)"
    ],
    [
        "STORE_FAST",
        "i"
    ],
    [
        "LOAD_GLOBAL",
        "Source"
    ],
    [
        "LOAD_METHOD",
        "Source.executing"
    ],
    [
        "LOAD_GLOBAL",
        "inspect"
    ],
    [
        "LOAD_METHOD",
        "inspect.currentframe"
    ],
    [
        "CALL_METHOD",
        "inspect.currentframe()"
    ],
    [
        "CALL_METHOD",
        "Source.executing(inspect.currentframe())"
    ],
    [
        "LOAD_ATTR",
        "Source.executing(inspect.currentframe()).node"
    ],
    [
        "STORE_FAST",
        "new_node"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "IS_OP",
        "node is None"
    ],
    [
        "LOAD_FAST",
        "new_node"
    ],
    [
        "STORE_FAST",
        "node"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.assertIs"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_FAST",
        "new_node"
    ],
    [
        "CALL_METHOD",
        "self.assertIs(node, new_node)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.assertLess"
    ],
    [
        "LOAD_GLOBAL",
        "time"
    ],
    [
        "LOAD_METHOD",
        "time.time"
    ],
    [
        "CALL_METHOD",
        "time.time()"
    ],
    [
        "LOAD_FAST",
        "start"
    ],
    [
        "BINARY_SUBTRACT",
        "time.time() - start"
    ],
    [
        "CALL_METHOD",
        "self.assertLess(time.time() - start, 1)"
    ],
    [
        "STORE_FAST",
        "        def check(source, encoding, exception=None, matches=True):\n            encoded = source.encode(encoding)\n            if exception:\n                with self.assertRaises(exception):\n                    Source.decode_source(encoded)\n            else:\n                decoded = Source.decode_source(encoded)\n                if matches:\n                    self.assertEqual(decoded, source)\n                else:\n                    self.assertNotEqual(decoded, source)"
    ],
    [
        "LOAD_FAST",
        "check"
    ],
    [
        "CALL_FUNCTION",
        "check(u'# coding=utf8\\n\u00e9', 'utf8')"
    ],
    [
        "LOAD_FAST",
        "check"
    ],
    [
        "CALL_FUNCTION",
        "check(u'# coding=gbk\\n\u00e9', 'gbk')"
    ],
    [
        "LOAD_FAST",
        "check"
    ],
    [
        "LOAD_GLOBAL",
        "UnicodeDecodeError"
    ],
    [
        "CALL_FUNCTION_KW",
        "check(u'# coding=utf8\\n\u00e9', 'gbk', exception=UnicodeDecodeError)"
    ],
    [
        "LOAD_FAST",
        "check"
    ],
    [
        "CALL_FUNCTION_KW",
        "check(u'# coding=gbk\\n\u00e9', 'utf8', matches=False)"
    ],
    [
        "LOAD_GLOBAL",
        "PY3"
    ],
    [
        "LOAD_FAST",
        "check"
    ],
    [
        "CALL_FUNCTION",
        "check(u'\u00e9', 'utf8')"
    ],
    [
        "LOAD_FAST",
        "check"
    ],
    [
        "LOAD_GLOBAL",
        "SyntaxError"
    ],
    [
        "CALL_FUNCTION_KW",
        "check(u'\u00e9', 'gbk', exception=SyntaxError)"
    ],
    [
        "LOAD_FAST",
        "source"
    ],
    [
        "LOAD_METHOD",
        "source.encode"
    ],
    [
        "LOAD_FAST",
        "encoding"
    ],
    [
        "CALL_METHOD",
        "source.encode(encoding)"
    ],
    [
        "STORE_FAST",
        "encoded"
    ],
    [
        "LOAD_FAST",
        "exception"
    ],
    [
        "LOAD_DEREF",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.assertRaises"
    ],
    [
        "LOAD_FAST",
        "exception"
    ],
    [
        "CALL_METHOD",
        "self.assertRaises(exception)"
    ],
    [
        "LOAD_GLOBAL",
        "Source"
    ],
    [
        "LOAD_METHOD",
        "Source.decode_source"
    ],
    [
        "LOAD_FAST",
        "encoded"
    ],
    [
        "CALL_METHOD",
        "Source.decode_source(encoded)"
    ],
    [
        "CALL_FUNCTION",
        "                with self.assertRaises(exception):\n                    Source.decode_source(encoded)"
    ],
    [
        "LOAD_GLOBAL",
        "Source"
    ],
    [
        "LOAD_METHOD",
        "Source.decode_source"
    ],
    [
        "LOAD_FAST",
        "encoded"
    ],
    [
        "CALL_METHOD",
        "Source.decode_source(encoded)"
    ],
    [
        "STORE_FAST",
        "decoded"
    ],
    [
        "LOAD_FAST",
        "matches"
    ],
    [
        "LOAD_DEREF",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.assertEqual"
    ],
    [
        "LOAD_FAST",
        "decoded"
    ],
    [
        "LOAD_FAST",
        "source"
    ],
    [
        "CALL_METHOD",
        "self.assertEqual(decoded, source)"
    ],
    [
        "LOAD_DEREF",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.assertNotEqual"
    ],
    [
        "LOAD_FAST",
        "decoded"
    ],
    [
        "LOAD_FAST",
        "source"
    ],
    [
        "CALL_METHOD",
        "self.assertNotEqual(decoded, source)"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester('a')"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester('''\n            ab''')"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester('''\n                    abc\n                    def\n                    '''\n               )"
    ],
    [
        "LOAD_GLOBAL",
        "str"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester(\n                '''\n                123\n                456\n                '''\n            )"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester(\n                '''\n                345\n                456786\n                '''\n            )"
    ],
    [
        "CALL_FUNCTION",
        "str([\n            tester(\n                '''\n                123\n                456\n                '''\n            ),\n            tester(\n                '''\n                345\n                456786\n                '''\n            ),\n        ])"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester(\n            [\n                '''\n                123\n                456\n                '''\n                '''\n                345\n                456786\n                '''\n                ,\n                '''\n                123\n                456\n                ''',\n                '''\n                345\n                456786\n                '''\n            ]\n        )"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester(1)"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester(2)"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester([1, 2])"
    ],
    [
        "STORE_FAST",
        "_"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "CALL_FUNCTION",
        "tester(3)"
    ],
    [
        "LOAD_GLOBAL",
        "Source"
    ],
    [
        "LOAD_METHOD",
        "Source.for_filename"
    ],
    [
        "LOAD_GLOBAL",
        "__file__"
    ],
    [
        "CALL_METHOD",
        "Source.for_filename(__file__)"
    ],
    [
        "LOAD_METHOD",
        "Source.for_filename(__file__).code_qualname"
    ],
    [
        "LOAD_FAST",
        "func"
    ],
    [
        "LOAD_ATTR",
        "func.__code__"
    ],
    [
        "CALL_METHOD",
        "Source.for_filename(__file__).code_qualname(func.__code__)"
    ],
    [
        "STORE_FAST",
        "qualname"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.assertEqual"
    ],
    [
        "LOAD_FAST",
        "qn"
    ],
    [
        "LOAD_FAST",
        "qualname"
    ],
    [
        "CALL_METHOD",
        "self.assertEqual(qn, qualname)"
    ],
    [
        "LOAD_GLOBAL",
        "PY3"
    ],
    [
        "LOAD_FAST",
        "check_actual_qualname"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.assertEqual"
    ],
    [
        "LOAD_FAST",
        "qn"
    ],
    [
        "LOAD_FAST",
        "func"
    ],
    [
        "LOAD_ATTR",
        "func.__qualname__"
    ],
    [
        "CALL_METHOD",
        "self.assertEqual(qn, func.__qualname__)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.assertTrue"
    ],
    [
        "LOAD_FAST",
        "qn"
    ],
    [
        "LOAD_METHOD",
        "qn.endswith"
    ],
    [
        "LOAD_FAST",
        "func"
    ],
    [
        "LOAD_ATTR",
        "func.__name__"
    ],
    [
        "CALL_METHOD",
        "qn.endswith(func.__name__)"
    ],
    [
        "CALL_METHOD",
        "self.assertTrue(qn.endswith(func.__name__))"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.assert_qualname"
    ],
    [
        "LOAD_GLOBAL",
        "C"
    ],
    [
        "LOAD_ATTR",
        "C.f"
    ],
    [
        "CALL_METHOD",
        "self.assert_qualname(C.f, 'C.f')"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.assert_qualname"
    ],
    [
        "LOAD_GLOBAL",
        "C"
    ],
    [
        "LOAD_ATTR",
        "C.D"
    ],
    [
        "LOAD_ATTR",
        "C.D.g"
    ],
    [
        "CALL_METHOD",
        "self.assert_qualname(C.D.g, 'C.D.g')"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.assert_qualname"
    ],
    [
        "LOAD_GLOBAL",
        "f"
    ],
    [
        "CALL_METHOD",
        "self.assert_qualname(f, 'f')"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.assert_qualname"
    ],
    [
        "LOAD_GLOBAL",
        "f"
    ],
    [
        "CALL_FUNCTION",
        "f()"
    ],
    [
        "CALL_METHOD",
        "self.assert_qualname(f(), 'f.<locals>.g')"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.assert_qualname"
    ],
    [
        "LOAD_GLOBAL",
        "C"
    ],
    [
        "LOAD_ATTR",
        "C.D"
    ],
    [
        "LOAD_METHOD",
        "C.D.h"
    ],
    [
        "CALL_METHOD",
        "C.D.h()"
    ],
    [
        "CALL_METHOD",
        "self.assert_qualname(C.D.h(), 'C.D.h.<locals>.i.<locals>.j')"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.assert_qualname"
    ],
    [
        "LOAD_GLOBAL",
        "lamb"
    ],
    [
        "CALL_METHOD",
        "self.assert_qualname(lamb, '<lambda>')"
    ],
    [
        "LOAD_GLOBAL",
        "lambda_maker"
    ],
    [
        "CALL_FUNCTION",
        "lambda_maker()"
    ],
    [
        "STORE_FAST",
        "foo"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.assert_qualname"
    ],
    [
        "LOAD_FAST",
        "foo"
    ],
    [
        "CALL_METHOD",
        "self.assert_qualname(foo, 'lambda_maker.<locals>.foo')"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.assert_qualname"
    ],
    [
        "LOAD_FAST",
        "foo"
    ],
    [
        "LOAD_ATTR",
        "foo.x"
    ],
    [
        "CALL_METHOD",
        "self.assert_qualname(foo.x, 'lambda_maker.<locals>.<lambda>')"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.assert_qualname"
    ],
    [
        "LOAD_FAST",
        "foo"
    ],
    [
        "CALL_FUNCTION",
        "foo()"
    ],
    [
        "CALL_METHOD",
        "self.assert_qualname(foo(), 'lambda_maker.<locals>.foo.<locals>.<lambda>')"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.assert_qualname"
    ],
    [
        "LOAD_FAST",
        "foo"
    ],
    [
        "CALL_FUNCTION",
        "foo()"
    ],
    [
        "CALL_FUNCTION",
        "foo()()"
    ],
    [
        "CALL_FUNCTION_KW",
        "self.assert_qualname(foo()(), 'lambda_maker.<locals>.foo.<locals>.<lambda>', check_actual_qualname=False)"
    ],
    [
        "LOAD_GLOBAL",
        "list"
    ],
    [
        "LOAD_GLOBAL",
        "range"
    ],
    [
        "CALL_FUNCTION",
        "range(66000)"
    ],
    [
        "CALL_FUNCTION",
        "list(range(66000))"
    ],
    [
        "BINARY_MODULO",
        "'tester(6)\\n%s\\ntester(9)' % list(range(66000))"
    ],
    [
        "STORE_FAST",
        "source"
    ],
    [
        "LOAD_GLOBAL",
        "tempfile"
    ],
    [
        "LOAD_METHOD",
        "tempfile.mkstemp"
    ],
    [
        "CALL_METHOD",
        "tempfile.mkstemp()"
    ],
    [
        "STORE_FAST",
        "_"
    ],
    [
        "STORE_FAST",
        "filename"
    ],
    [
        "LOAD_GLOBAL",
        "compile"
    ],
    [
        "LOAD_FAST",
        "source"
    ],
    [
        "LOAD_FAST",
        "filename"
    ],
    [
        "CALL_FUNCTION",
        "compile(source, filename, 'exec')"
    ],
    [
        "STORE_FAST",
        "code"
    ],
    [
        "LOAD_GLOBAL",
        "open"
    ],
    [
        "LOAD_FAST",
        "filename"
    ],
    [
        "CALL_FUNCTION",
        "open(filename, 'w')"
    ],
    [
        "STORE_FAST",
        "outfile"
    ],
    [
        "LOAD_FAST",
        "outfile"
    ],
    [
        "LOAD_METHOD",
        "outfile.write"
    ],
    [
        "LOAD_FAST",
        "source"
    ],
    [
        "CALL_METHOD",
        "outfile.write(source)"
    ],
    [
        "CALL_FUNCTION",
        "        with open(filename, 'w') as outfile:\n            outfile.write(source)"
    ],
    [
        "LOAD_GLOBAL",
        "exec"
    ],
    [
        "LOAD_FAST",
        "code"
    ],
    [
        "CALL_FUNCTION",
        "exec(code)"
    ],
    [
        "LOAD_GLOBAL",
        "range"
    ],
    [
        "CALL_FUNCTION",
        "range(5)"
    ],
    [
        "STORE_FAST",
        "n"
    ],
    [
        "LOAD_GLOBAL",
        "range"
    ],
    [
        "LOAD_FAST",
        "n"
    ],
    [
        "CALL_FUNCTION",
        "range(n)"
    ],
    [
        "CALL_FUNCTION",
        "(i for i in range(n))"
    ],
    [
        "STORE_FAST",
        "gen"
    ],
    [
        "LOAD_FAST",
        "n"
    ],
    [
        "COMPARE_OP",
        "n == 1"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.assertEqual"
    ],
    [
        "LOAD_GLOBAL",
        "only"
    ],
    [
        "LOAD_FAST",
        "gen"
    ],
    [
        "CALL_FUNCTION",
        "only(gen)"
    ],
    [
        "CALL_METHOD",
        "self.assertEqual(only(gen), 0)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.assertRaises"
    ],
    [
        "LOAD_GLOBAL",
        "NotOneValueFound"
    ],
    [
        "CALL_METHOD",
        "self.assertRaises(NotOneValueFound)"
    ],
    [
        "LOAD_GLOBAL",
        "only"
    ],
    [
        "LOAD_FAST",
        "gen"
    ],
    [
        "CALL_FUNCTION",
        "only(gen)"
    ],
    [
        "CALL_FUNCTION",
        "                with self.assertRaises(NotOneValueFound):\n                    only(gen)"
    ],
    [
        "LOAD_FAST",
        "(i for i in range(n))"
    ],
    [
        "STORE_FAST",
        "i"
    ],
    [
        "LOAD_FAST",
        "i"
    ],
    [
        "LOAD_GLOBAL",
        "os"
    ],
    [
        "LOAD_ATTR",
        "os.path"
    ],
    [
        "LOAD_METHOD",
        "os.path.join"
    ],
    [
        "LOAD_GLOBAL",
        "os"
    ],
    [
        "LOAD_ATTR",
        "os.path"
    ],
    [
        "LOAD_METHOD",
        "os.path.dirname"
    ],
    [
        "LOAD_GLOBAL",
        "__file__"
    ],
    [
        "CALL_METHOD",
        "os.path.dirname(__file__)"
    ],
    [
        "CALL_METHOD",
        "os.path.join(os.path.dirname(__file__), 'not_code.txt', )"
    ],
    [
        "STORE_FAST",
        "path"
    ],
    [
        "LOAD_GLOBAL",
        "Source"
    ],
    [
        "LOAD_METHOD",
        "Source.for_filename"
    ],
    [
        "LOAD_FAST",
        "path"
    ],
    [
        "CALL_METHOD",
        "Source.for_filename(path)"
    ],
    [
        "STORE_FAST",
        "source"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.assertIsNone"
    ],
    [
        "LOAD_FAST",
        "source"
    ],
    [
        "LOAD_ATTR",
        "source.tree"
    ],
    [
        "CALL_METHOD",
        "self.assertIsNone(source.tree)"
    ],
    [
        "LOAD_GLOBAL",
        "inspect"
    ],
    [
        "LOAD_METHOD",
        "inspect.currentframe"
    ],
    [
        "CALL_METHOD",
        "inspect.currentframe()"
    ],
    [
        "STORE_FAST",
        "frame"
    ],
    [
        "LOAD_GLOBAL",
        "Source"
    ],
    [
        "LOAD_METHOD",
        "Source.executing"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "CALL_METHOD",
        "Source.executing(frame)"
    ],
    [
        "STORE_FAST",
        "executing"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.assertEqual"
    ],
    [
        "LOAD_FAST",
        "executing"
    ],
    [
        "LOAD_METHOD",
        "executing.code_qualname"
    ],
    [
        "CALL_METHOD",
        "executing.code_qualname()"
    ],
    [
        "CALL_METHOD",
        "self.assertEqual(executing.code_qualname(), 'TestStuff.test_executing_methods')"
    ],
    [
        "LOAD_GLOBAL",
        "sys"
    ],
    [
        "LOAD_ATTR",
        "sys.version"
    ],
    [
        "LOAD_METHOD",
        "sys.version.lower"
    ],
    [
        "CALL_METHOD",
        "sys.version.lower()"
    ],
    [
        "CONTAINS_OP",
        "'pypy' not in sys.version.lower()"
    ],
    [
        "STORE_FAST",
        "text"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.assertEqual"
    ],
    [
        "LOAD_FAST",
        "executing"
    ],
    [
        "LOAD_METHOD",
        "executing.text"
    ],
    [
        "CALL_METHOD",
        "executing.text()"
    ],
    [
        "LOAD_FAST",
        "text"
    ],
    [
        "CALL_METHOD",
        "self.assertEqual(executing.text(), text)"
    ],
    [
        "LOAD_FAST",
        "executing"
    ],
    [
        "LOAD_METHOD",
        "executing.text_range"
    ],
    [
        "CALL_METHOD",
        "executing.text_range()"
    ],
    [
        "STORE_FAST",
        "start"
    ],
    [
        "STORE_FAST",
        "end"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.assertEqual"
    ],
    [
        "LOAD_FAST",
        "executing"
    ],
    [
        "LOAD_ATTR",
        "executing.source"
    ],
    [
        "LOAD_ATTR",
        "executing.source.text"
    ],
    [
        "LOAD_FAST",
        "start"
    ],
    [
        "LOAD_FAST",
        "end"
    ],
    [
        "BINARY_SUBSCR",
        "executing.source.text[start:end]"
    ],
    [
        "LOAD_FAST",
        "text"
    ],
    [
        "CALL_METHOD",
        "self.assertEqual(executing.source.text[start:end], text)"
    ],
    [
        "LOAD_GLOBAL",
        "C"
    ],
    [
        "CALL_FUNCTION",
        "C()"
    ],
    [
        "STORE_FAST",
        "c"
    ],
    [
        "LOAD_GLOBAL",
        "tester"
    ],
    [
        "LOAD_FAST",
        "c"
    ],
    [
        "STORE_ATTR",
        "c.x"
    ],
    [
        "LOAD_FAST",
        "c"
    ],
    [
        "STORE_ATTR",
        "c.y"
    ],
    [
        "LOAD_GLOBAL",
        "str"
    ],
    [
        "LOAD_FAST",
        "c"
    ],
    [
        "LOAD_ATTR",
        "c.x"
    ],
    [
        "LOAD_ATTR",
        "c.x.x"
    ],
    [
        "LOAD_FAST",
        "c"
    ],
    [
        "LOAD_ATTR",
        "c.x"
    ],
    [
        "LOAD_ATTR",
        "c.x.y"
    ],
    [
        "LOAD_FAST",
        "c"
    ],
    [
        "LOAD_ATTR",
        "c.y"
    ],
    [
        "LOAD_ATTR",
        "c.y.x"
    ],
    [
        "LOAD_FAST",
        "c"
    ],
    [
        "LOAD_ATTR",
        "c.y"
    ],
    [
        "LOAD_ATTR",
        "c.y.y"
    ],
    [
        "LOAD_FAST",
        "c"
    ],
    [
        "LOAD_ATTR",
        "c.x"
    ],
    [
        "LOAD_ATTR",
        "c.x.asd"
    ],
    [
        "LOAD_FAST",
        "c"
    ],
    [
        "LOAD_ATTR",
        "c.y"
    ],
    [
        "LOAD_ATTR",
        "c.y.qwe"
    ],
    [
        "CALL_FUNCTION",
        "str((c.x.x, c.x.y, c.y.x, c.y.y, c.x.asd, c.y.qwe))"
    ],
    [
        "LOAD_NAME",
        "class TestFile(unittest.TestCase):\n    def test_file(self):\n        source = Source.for_frame(inspect.currentframe())\n        code = compile(source.text, source.filename, 'exec')\n        instructions = get_instructions(code)\n        lineno = None\n        for inst in instructions:\n            if inst.starts_line is not None:\n                lineno = inst.starts_line\n            if not inst.opname.startswith(\n                    ('BINARY_', 'UNARY_', 'LOAD_ATTR', 'LOAD_METHOD', 'LOOKUP_METHOD', 'COMPARE_OP')):\n                continue\n            frame = C()\n            frame.f_lasti = inst.offset\n            frame.f_code = code\n            frame.f_globals = globals()\n            frame.f_lineno = lineno\n            print(inst.opname)\n            assert Source.executing(frame).node is not None"
    ],
    [
        "STORE_NAME",
        "class TestFile(unittest.TestCase):\n    def test_file(self):\n        source = Source.for_frame(inspect.currentframe())\n        code = compile(source.text, source.filename, 'exec')\n        instructions = get_instructions(code)\n        lineno = None\n        for inst in instructions:\n            if inst.starts_line is not None:\n                lineno = inst.starts_line\n            if not inst.opname.startswith(\n                    ('BINARY_', 'UNARY_', 'LOAD_ATTR', 'LOAD_METHOD', 'LOOKUP_METHOD', 'COMPARE_OP')):\n                continue\n            frame = C()\n            frame.f_lasti = inst.offset\n            frame.f_code = code\n            frame.f_globals = globals()\n            frame.f_lineno = lineno\n            print(inst.opname)\n            assert Source.executing(frame).node is not None"
    ],
    [
        "STORE_NAME",
        "class TestFile(unittest.TestCase):\n    def test_file(self):\n        source = Source.for_frame(inspect.currentframe())\n        code = compile(source.text, source.filename, 'exec')\n        instructions = get_instructions(code)\n        lineno = None\n        for inst in instructions:\n            if inst.starts_line is not None:\n                lineno = inst.starts_line\n            if not inst.opname.startswith(\n                    ('BINARY_', 'UNARY_', 'LOAD_ATTR', 'LOAD_METHOD', 'LOOKUP_METHOD', 'COMPARE_OP')):\n                continue\n            frame = C()\n            frame.f_lasti = inst.offset\n            frame.f_code = code\n            frame.f_globals = globals()\n            frame.f_lineno = lineno\n            print(inst.opname)\n            assert Source.executing(frame).node is not None"
    ],
    [
        "STORE_NAME",
        "    def test_file(self):\n        source = Source.for_frame(inspect.currentframe())\n        code = compile(source.text, source.filename, 'exec')\n        instructions = get_instructions(code)\n        lineno = None\n        for inst in instructions:\n            if inst.starts_line is not None:\n                lineno = inst.starts_line\n            if not inst.opname.startswith(\n                    ('BINARY_', 'UNARY_', 'LOAD_ATTR', 'LOAD_METHOD', 'LOOKUP_METHOD', 'COMPARE_OP')):\n                continue\n            frame = C()\n            frame.f_lasti = inst.offset\n            frame.f_code = code\n            frame.f_globals = globals()\n            frame.f_lineno = lineno\n            print(inst.opname)\n            assert Source.executing(frame).node is not None"
    ],
    [
        "LOAD_GLOBAL",
        "Source"
    ],
    [
        "LOAD_METHOD",
        "Source.for_frame"
    ],
    [
        "LOAD_GLOBAL",
        "inspect"
    ],
    [
        "LOAD_METHOD",
        "inspect.currentframe"
    ],
    [
        "CALL_METHOD",
        "inspect.currentframe()"
    ],
    [
        "CALL_METHOD",
        "Source.for_frame(inspect.currentframe())"
    ],
    [
        "STORE_FAST",
        "source"
    ],
    [
        "LOAD_GLOBAL",
        "compile"
    ],
    [
        "LOAD_FAST",
        "source"
    ],
    [
        "LOAD_ATTR",
        "source.text"
    ],
    [
        "LOAD_FAST",
        "source"
    ],
    [
        "LOAD_ATTR",
        "source.filename"
    ],
    [
        "CALL_FUNCTION",
        "compile(source.text, source.filename, 'exec')"
    ],
    [
        "STORE_FAST",
        "code"
    ],
    [
        "LOAD_GLOBAL",
        "get_instructions"
    ],
    [
        "LOAD_FAST",
        "code"
    ],
    [
        "CALL_FUNCTION",
        "get_instructions(code)"
    ],
    [
        "STORE_FAST",
        "instructions"
    ],
    [
        "STORE_FAST",
        "lineno"
    ],
    [
        "LOAD_FAST",
        "instructions"
    ],
    [
        "STORE_FAST",
        "inst"
    ],
    [
        "LOAD_FAST",
        "inst"
    ],
    [
        "LOAD_ATTR",
        "inst.starts_line"
    ],
    [
        "IS_OP",
        "inst.starts_line is not None"
    ],
    [
        "LOAD_FAST",
        "inst"
    ],
    [
        "LOAD_ATTR",
        "inst.starts_line"
    ],
    [
        "STORE_FAST",
        "lineno"
    ],
    [
        "LOAD_FAST",
        "inst"
    ],
    [
        "LOAD_ATTR",
        "inst.opname"
    ],
    [
        "LOAD_METHOD",
        "inst.opname.startswith"
    ],
    [
        "CALL_METHOD",
        "inst.opname.startswith(\n                    ('BINARY_', 'UNARY_', 'LOAD_ATTR', 'LOAD_METHOD', 'LOOKUP_METHOD', 'COMPARE_OP'))"
    ],
    [
        "LOAD_GLOBAL",
        "C"
    ],
    [
        "CALL_FUNCTION",
        "C()"
    ],
    [
        "STORE_FAST",
        "frame"
    ],
    [
        "LOAD_FAST",
        "inst"
    ],
    [
        "LOAD_ATTR",
        "inst.offset"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "STORE_ATTR",
        "frame.f_lasti"
    ],
    [
        "LOAD_FAST",
        "code"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "STORE_ATTR",
        "frame.f_code"
    ],
    [
        "LOAD_GLOBAL",
        "globals"
    ],
    [
        "CALL_FUNCTION",
        "globals()"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "STORE_ATTR",
        "frame.f_globals"
    ],
    [
        "LOAD_FAST",
        "lineno"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "STORE_ATTR",
        "frame.f_lineno"
    ],
    [
        "LOAD_GLOBAL",
        "print"
    ],
    [
        "LOAD_FAST",
        "inst"
    ],
    [
        "LOAD_ATTR",
        "inst.opname"
    ],
    [
        "CALL_FUNCTION",
        "print(inst.opname)"
    ],
    [
        "LOAD_GLOBAL",
        "Source"
    ],
    [
        "LOAD_METHOD",
        "Source.executing"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "CALL_METHOD",
        "Source.executing(frame)"
    ],
    [
        "LOAD_ATTR",
        "Source.executing(frame).node"
    ],
    [
        "IS_OP",
        "Source.executing(frame).node is not None"
    ],
    [
        "LOAD_NAME",
        "class C(object):\n    @staticmethod\n    def f():\n        pass\n\n    class D(object):\n        @staticmethod\n        def g():\n            pass\n\n        @staticmethod\n        def h():\n            def i():\n                def j():\n                    pass\n\n                return j\n\n            return i()"
    ],
    [
        "STORE_NAME",
        "class C(object):\n    @staticmethod\n    def f():\n        pass\n\n    class D(object):\n        @staticmethod\n        def g():\n            pass\n\n        @staticmethod\n        def h():\n            def i():\n                def j():\n                    pass\n\n                return j\n\n            return i()"
    ],
    [
        "STORE_NAME",
        "class C(object):\n    @staticmethod\n    def f():\n        pass\n\n    class D(object):\n        @staticmethod\n        def g():\n            pass\n\n        @staticmethod\n        def h():\n            def i():\n                def j():\n                    pass\n\n                return j\n\n            return i()"
    ],
    [
        "LOAD_NAME",
        "staticmethod"
    ],
    [
        "CALL_FUNCTION",
        "staticmethod"
    ],
    [
        "STORE_NAME",
        "    @staticmethod\n    def f():\n        pass"
    ],
    [
        "LOAD_NAME",
        "object"
    ],
    [
        "CALL_FUNCTION",
        "    class D(object):\n        @staticmethod\n        def g():\n            pass\n\n        @staticmethod\n        def h():\n            def i():\n                def j():\n                    pass\n\n                return j\n\n            return i()"
    ],
    [
        "STORE_NAME",
        "    class D(object):\n        @staticmethod\n        def g():\n            pass\n\n        @staticmethod\n        def h():\n            def i():\n                def j():\n                    pass\n\n                return j\n\n            return i()"
    ],
    [
        "LOAD_NAME",
        "    class D(object):\n        @staticmethod\n        def g():\n            pass\n\n        @staticmethod\n        def h():\n            def i():\n                def j():\n                    pass\n\n                return j\n\n            return i()"
    ],
    [
        "STORE_NAME",
        "    class D(object):\n        @staticmethod\n        def g():\n            pass\n\n        @staticmethod\n        def h():\n            def i():\n                def j():\n                    pass\n\n                return j\n\n            return i()"
    ],
    [
        "STORE_NAME",
        "    class D(object):\n        @staticmethod\n        def g():\n            pass\n\n        @staticmethod\n        def h():\n            def i():\n                def j():\n                    pass\n\n                return j\n\n            return i()"
    ],
    [
        "LOAD_NAME",
        "staticmethod"
    ],
    [
        "CALL_FUNCTION",
        "staticmethod"
    ],
    [
        "STORE_NAME",
        "        @staticmethod\n        def g():\n            pass"
    ],
    [
        "LOAD_NAME",
        "staticmethod"
    ],
    [
        "CALL_FUNCTION",
        "staticmethod"
    ],
    [
        "STORE_NAME",
        "        @staticmethod\n        def h():\n            def i():\n                def j():\n                    pass\n\n                return j\n\n            return i()"
    ],
    [
        "STORE_FAST",
        "            def i():\n                def j():\n                    pass\n\n                return j"
    ],
    [
        "LOAD_FAST",
        "i"
    ],
    [
        "CALL_FUNCTION",
        "i()"
    ],
    [
        "STORE_FAST",
        "                def j():\n                    pass"
    ],
    [
        "LOAD_FAST",
        "j"
    ],
    [
        "STORE_FAST",
        "    def g():\n        pass"
    ],
    [
        "LOAD_FAST",
        "g"
    ],
    [
        "STORE_FAST",
        "    def assign(x):\n        def decorator(func):\n            func.x = x\n            return func\n\n        return decorator"
    ],
    [
        "LOAD_FAST",
        "assign"
    ],
    [
        "CALL_FUNCTION",
        "assign(lambda: 1)"
    ],
    [
        "CALL_FUNCTION",
        "assign(lambda: 1)"
    ],
    [
        "STORE_FAST",
        "    @assign(lambda: 1)\n    def foo():\n        return lambda: lambda: 3"
    ],
    [
        "LOAD_FAST",
        "foo"
    ],
    [
        "STORE_FAST",
        "        def decorator(func):\n            func.x = x\n            return func"
    ],
    [
        "LOAD_FAST",
        "decorator"
    ],
    [
        "LOAD_DEREF",
        "x"
    ],
    [
        "LOAD_FAST",
        "func"
    ],
    [
        "STORE_ATTR",
        "func.x"
    ],
    [
        "LOAD_FAST",
        "func"
    ],
    [
        "LOAD_NAME",
        "class Tester(object):\n    def get_node(self, typ):\n        frame = inspect.currentframe().f_back.f_back\n        Source.lazycache(frame)\n        node = Source.executing(frame).node\n        assert isinstance(node, typ), (node, typ)\n        return node\n\n    def check(self, node, value):\n        frame = inspect.currentframe().f_back.f_back\n        result = eval(\n            compile(ast.Expression(node), frame.f_code.co_filename, 'eval'),\n            frame.f_globals,\n            frame.f_locals,\n        )\n        assert result == value, (result, value)\n\n    def __call__(self, arg, check_func=True, returns=None):\n        call = self.get_node(ast.Call)\n        self.check(call.args[0], arg)\n        if check_func:\n            self.check(call.func, self)\n        if returns is None:\n            return arg\n        return returns\n\n    def __getattr__(self, item):\n        node = self.get_node(ast.Attribute)\n        self.check(node.value, self)\n        assert node.attr == item\n        return self\n\n    def __getitem__(self, item):\n        node = self.get_node(ast.Subscript)\n        self.check(node.value, self)\n        self.check(node.slice.value, item)\n        return self\n\n    def __add__(self, other):\n        node = self.get_node(ast.BinOp)\n        self.check(node.left, self)\n        self.check(node.right, other)\n        return self\n\n    __pow__ = __mul__ = __sub__ = __add__\n\n    def __invert__(self):\n        node = self.get_node(ast.UnaryOp)\n        self.check(node.operand, self)\n        return self\n\n    __neg__ = __pos__ = __invert__\n\n    def __lt__(self, other):\n        node = self.get_node(ast.Compare)\n        self.check(node.left, self)\n        self.check(node.comparators[0], other)\n        return self\n\n    __ne__ = __ge__ = __lt__"
    ],
    [
        "STORE_NAME",
        "class Tester(object):\n    def get_node(self, typ):\n        frame = inspect.currentframe().f_back.f_back\n        Source.lazycache(frame)\n        node = Source.executing(frame).node\n        assert isinstance(node, typ), (node, typ)\n        return node\n\n    def check(self, node, value):\n        frame = inspect.currentframe().f_back.f_back\n        result = eval(\n            compile(ast.Expression(node), frame.f_code.co_filename, 'eval'),\n            frame.f_globals,\n            frame.f_locals,\n        )\n        assert result == value, (result, value)\n\n    def __call__(self, arg, check_func=True, returns=None):\n        call = self.get_node(ast.Call)\n        self.check(call.args[0], arg)\n        if check_func:\n            self.check(call.func, self)\n        if returns is None:\n            return arg\n        return returns\n\n    def __getattr__(self, item):\n        node = self.get_node(ast.Attribute)\n        self.check(node.value, self)\n        assert node.attr == item\n        return self\n\n    def __getitem__(self, item):\n        node = self.get_node(ast.Subscript)\n        self.check(node.value, self)\n        self.check(node.slice.value, item)\n        return self\n\n    def __add__(self, other):\n        node = self.get_node(ast.BinOp)\n        self.check(node.left, self)\n        self.check(node.right, other)\n        return self\n\n    __pow__ = __mul__ = __sub__ = __add__\n\n    def __invert__(self):\n        node = self.get_node(ast.UnaryOp)\n        self.check(node.operand, self)\n        return self\n\n    __neg__ = __pos__ = __invert__\n\n    def __lt__(self, other):\n        node = self.get_node(ast.Compare)\n        self.check(node.left, self)\n        self.check(node.comparators[0], other)\n        return self\n\n    __ne__ = __ge__ = __lt__"
    ],
    [
        "STORE_NAME",
        "class Tester(object):\n    def get_node(self, typ):\n        frame = inspect.currentframe().f_back.f_back\n        Source.lazycache(frame)\n        node = Source.executing(frame).node\n        assert isinstance(node, typ), (node, typ)\n        return node\n\n    def check(self, node, value):\n        frame = inspect.currentframe().f_back.f_back\n        result = eval(\n            compile(ast.Expression(node), frame.f_code.co_filename, 'eval'),\n            frame.f_globals,\n            frame.f_locals,\n        )\n        assert result == value, (result, value)\n\n    def __call__(self, arg, check_func=True, returns=None):\n        call = self.get_node(ast.Call)\n        self.check(call.args[0], arg)\n        if check_func:\n            self.check(call.func, self)\n        if returns is None:\n            return arg\n        return returns\n\n    def __getattr__(self, item):\n        node = self.get_node(ast.Attribute)\n        self.check(node.value, self)\n        assert node.attr == item\n        return self\n\n    def __getitem__(self, item):\n        node = self.get_node(ast.Subscript)\n        self.check(node.value, self)\n        self.check(node.slice.value, item)\n        return self\n\n    def __add__(self, other):\n        node = self.get_node(ast.BinOp)\n        self.check(node.left, self)\n        self.check(node.right, other)\n        return self\n\n    __pow__ = __mul__ = __sub__ = __add__\n\n    def __invert__(self):\n        node = self.get_node(ast.UnaryOp)\n        self.check(node.operand, self)\n        return self\n\n    __neg__ = __pos__ = __invert__\n\n    def __lt__(self, other):\n        node = self.get_node(ast.Compare)\n        self.check(node.left, self)\n        self.check(node.comparators[0], other)\n        return self\n\n    __ne__ = __ge__ = __lt__"
    ],
    [
        "STORE_NAME",
        "    def get_node(self, typ):\n        frame = inspect.currentframe().f_back.f_back\n        Source.lazycache(frame)\n        node = Source.executing(frame).node\n        assert isinstance(node, typ), (node, typ)\n        return node"
    ],
    [
        "STORE_NAME",
        "    def check(self, node, value):\n        frame = inspect.currentframe().f_back.f_back\n        result = eval(\n            compile(ast.Expression(node), frame.f_code.co_filename, 'eval'),\n            frame.f_globals,\n            frame.f_locals,\n        )\n        assert result == value, (result, value)"
    ],
    [
        "STORE_NAME",
        "    def __call__(self, arg, check_func=True, returns=None):\n        call = self.get_node(ast.Call)\n        self.check(call.args[0], arg)\n        if check_func:\n            self.check(call.func, self)\n        if returns is None:\n            return arg\n        return returns"
    ],
    [
        "STORE_NAME",
        "    def __getattr__(self, item):\n        node = self.get_node(ast.Attribute)\n        self.check(node.value, self)\n        assert node.attr == item\n        return self"
    ],
    [
        "STORE_NAME",
        "    def __getitem__(self, item):\n        node = self.get_node(ast.Subscript)\n        self.check(node.value, self)\n        self.check(node.slice.value, item)\n        return self"
    ],
    [
        "STORE_NAME",
        "    def __add__(self, other):\n        node = self.get_node(ast.BinOp)\n        self.check(node.left, self)\n        self.check(node.right, other)\n        return self"
    ],
    [
        "LOAD_NAME",
        "__add__"
    ],
    [
        "STORE_NAME",
        "__pow__"
    ],
    [
        "STORE_NAME",
        "__mul__"
    ],
    [
        "STORE_NAME",
        "__sub__"
    ],
    [
        "STORE_NAME",
        "    def __invert__(self):\n        node = self.get_node(ast.UnaryOp)\n        self.check(node.operand, self)\n        return self"
    ],
    [
        "LOAD_NAME",
        "__invert__"
    ],
    [
        "STORE_NAME",
        "__neg__"
    ],
    [
        "STORE_NAME",
        "__pos__"
    ],
    [
        "STORE_NAME",
        "    def __lt__(self, other):\n        node = self.get_node(ast.Compare)\n        self.check(node.left, self)\n        self.check(node.comparators[0], other)\n        return self"
    ],
    [
        "LOAD_NAME",
        "__lt__"
    ],
    [
        "STORE_NAME",
        "__ne__"
    ],
    [
        "STORE_NAME",
        "__ge__"
    ],
    [
        "LOAD_GLOBAL",
        "inspect"
    ],
    [
        "LOAD_METHOD",
        "inspect.currentframe"
    ],
    [
        "CALL_METHOD",
        "inspect.currentframe()"
    ],
    [
        "LOAD_ATTR",
        "inspect.currentframe().f_back"
    ],
    [
        "LOAD_ATTR",
        "inspect.currentframe().f_back.f_back"
    ],
    [
        "STORE_FAST",
        "frame"
    ],
    [
        "LOAD_GLOBAL",
        "Source"
    ],
    [
        "LOAD_METHOD",
        "Source.lazycache"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "CALL_METHOD",
        "Source.lazycache(frame)"
    ],
    [
        "LOAD_GLOBAL",
        "Source"
    ],
    [
        "LOAD_METHOD",
        "Source.executing"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "CALL_METHOD",
        "Source.executing(frame)"
    ],
    [
        "LOAD_ATTR",
        "Source.executing(frame).node"
    ],
    [
        "STORE_FAST",
        "node"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_FAST",
        "typ"
    ],
    [
        "CALL_FUNCTION",
        "isinstance(node, typ)"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_FAST",
        "typ"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_GLOBAL",
        "inspect"
    ],
    [
        "LOAD_METHOD",
        "inspect.currentframe"
    ],
    [
        "CALL_METHOD",
        "inspect.currentframe()"
    ],
    [
        "LOAD_ATTR",
        "inspect.currentframe().f_back"
    ],
    [
        "LOAD_ATTR",
        "inspect.currentframe().f_back.f_back"
    ],
    [
        "STORE_FAST",
        "frame"
    ],
    [
        "LOAD_GLOBAL",
        "eval"
    ],
    [
        "LOAD_GLOBAL",
        "compile"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_METHOD",
        "ast.Expression"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "CALL_METHOD",
        "ast.Expression(node)"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "LOAD_ATTR",
        "frame.f_code"
    ],
    [
        "LOAD_ATTR",
        "frame.f_code.co_filename"
    ],
    [
        "CALL_FUNCTION",
        "compile(ast.Expression(node), frame.f_code.co_filename, 'eval')"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "LOAD_ATTR",
        "frame.f_globals"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "LOAD_ATTR",
        "frame.f_locals"
    ],
    [
        "CALL_FUNCTION",
        "eval(\n            compile(ast.Expression(node), frame.f_code.co_filename, 'eval'),\n            frame.f_globals,\n            frame.f_locals,\n        )"
    ],
    [
        "STORE_FAST",
        "result"
    ],
    [
        "LOAD_FAST",
        "result"
    ],
    [
        "LOAD_FAST",
        "value"
    ],
    [
        "COMPARE_OP",
        "result == value"
    ],
    [
        "LOAD_FAST",
        "result"
    ],
    [
        "LOAD_FAST",
        "value"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.get_node"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.Call"
    ],
    [
        "CALL_METHOD",
        "self.get_node(ast.Call)"
    ],
    [
        "STORE_FAST",
        "call"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.check"
    ],
    [
        "LOAD_FAST",
        "call"
    ],
    [
        "LOAD_ATTR",
        "call.args"
    ],
    [
        "BINARY_SUBSCR",
        "call.args[0]"
    ],
    [
        "LOAD_FAST",
        "arg"
    ],
    [
        "CALL_METHOD",
        "self.check(call.args[0], arg)"
    ],
    [
        "LOAD_FAST",
        "check_func"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.check"
    ],
    [
        "LOAD_FAST",
        "call"
    ],
    [
        "LOAD_ATTR",
        "call.func"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "CALL_METHOD",
        "self.check(call.func, self)"
    ],
    [
        "LOAD_FAST",
        "returns"
    ],
    [
        "IS_OP",
        "returns is None"
    ],
    [
        "LOAD_FAST",
        "arg"
    ],
    [
        "LOAD_FAST",
        "returns"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.get_node"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.Attribute"
    ],
    [
        "CALL_METHOD",
        "self.get_node(ast.Attribute)"
    ],
    [
        "STORE_FAST",
        "node"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.check"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node.value"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "CALL_METHOD",
        "self.check(node.value, self)"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node.attr"
    ],
    [
        "LOAD_FAST",
        "item"
    ],
    [
        "COMPARE_OP",
        "node.attr == item"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.get_node"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.Subscript"
    ],
    [
        "CALL_METHOD",
        "self.get_node(ast.Subscript)"
    ],
    [
        "STORE_FAST",
        "node"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.check"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node.value"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "CALL_METHOD",
        "self.check(node.value, self)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.check"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node.slice"
    ],
    [
        "LOAD_ATTR",
        "node.slice.value"
    ],
    [
        "LOAD_FAST",
        "item"
    ],
    [
        "CALL_METHOD",
        "self.check(node.slice.value, item)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.get_node"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.BinOp"
    ],
    [
        "CALL_METHOD",
        "self.get_node(ast.BinOp)"
    ],
    [
        "STORE_FAST",
        "node"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.check"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node.left"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "CALL_METHOD",
        "self.check(node.left, self)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.check"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node.right"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "CALL_METHOD",
        "self.check(node.right, other)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.get_node"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.UnaryOp"
    ],
    [
        "CALL_METHOD",
        "self.get_node(ast.UnaryOp)"
    ],
    [
        "STORE_FAST",
        "node"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.check"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node.operand"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "CALL_METHOD",
        "self.check(node.operand, self)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.get_node"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.Compare"
    ],
    [
        "CALL_METHOD",
        "self.get_node(ast.Compare)"
    ],
    [
        "STORE_FAST",
        "node"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.check"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node.left"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "CALL_METHOD",
        "self.check(node.left, self)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.check"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node.comparators"
    ],
    [
        "BINARY_SUBSCR",
        "node.comparators[0]"
    ],
    [
        "LOAD_FAST",
        "other"
    ],
    [
        "CALL_METHOD",
        "self.check(node.comparators[0], other)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_FAST",
        "func"
    ],
    [
        "LOAD_GLOBAL",
        "empty_decorator"
    ]
]