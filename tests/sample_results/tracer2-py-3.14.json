[
    [
        "STORE_NAME",
        "import functools"
    ],
    [
        "STORE_NAME",
        "import inspect"
    ],
    [
        "STORE_NAME",
        "import os"
    ],
    [
        "STORE_NAME",
        "import re"
    ],
    [
        "STORE_NAME",
        "import sys"
    ],
    [
        "STORE_NAME",
        "import threading"
    ],
    [
        "STORE_NAME",
        "from collections import OrderedDict"
    ],
    [
        "STORE_NAME",
        "import six"
    ],
    [
        "STORE_NAME",
        "from cheap_repr import cheap_repr, find_repr_function"
    ],
    [
        "STORE_NAME",
        "from cheap_repr import cheap_repr, find_repr_function"
    ],
    [
        "STORE_NAME",
        "from snoop.utils import my_cheap_repr, NO_ASTTOKENS, ArgDefaultDict, iscoroutinefunction, \\\n    truncate_list, ensure_tuple, is_comprehension_frame, no_args_decorator"
    ],
    [
        "STORE_NAME",
        "from snoop.utils import my_cheap_repr, NO_ASTTOKENS, ArgDefaultDict, iscoroutinefunction, \\\n    truncate_list, ensure_tuple, is_comprehension_frame, no_args_decorator"
    ],
    [
        "STORE_NAME",
        "from snoop.utils import my_cheap_repr, NO_ASTTOKENS, ArgDefaultDict, iscoroutinefunction, \\\n    truncate_list, ensure_tuple, is_comprehension_frame, no_args_decorator"
    ],
    [
        "STORE_NAME",
        "from snoop.utils import my_cheap_repr, NO_ASTTOKENS, ArgDefaultDict, iscoroutinefunction, \\\n    truncate_list, ensure_tuple, is_comprehension_frame, no_args_decorator"
    ],
    [
        "STORE_NAME",
        "from snoop.utils import my_cheap_repr, NO_ASTTOKENS, ArgDefaultDict, iscoroutinefunction, \\\n    truncate_list, ensure_tuple, is_comprehension_frame, no_args_decorator"
    ],
    [
        "STORE_NAME",
        "from snoop.utils import my_cheap_repr, NO_ASTTOKENS, ArgDefaultDict, iscoroutinefunction, \\\n    truncate_list, ensure_tuple, is_comprehension_frame, no_args_decorator"
    ],
    [
        "STORE_NAME",
        "from snoop.utils import my_cheap_repr, NO_ASTTOKENS, ArgDefaultDict, iscoroutinefunction, \\\n    truncate_list, ensure_tuple, is_comprehension_frame, no_args_decorator"
    ],
    [
        "STORE_NAME",
        "from snoop.utils import my_cheap_repr, NO_ASTTOKENS, ArgDefaultDict, iscoroutinefunction, \\\n    truncate_list, ensure_tuple, is_comprehension_frame, no_args_decorator"
    ],
    [
        "STORE_NAME",
        "from .formatting import Event, Source"
    ],
    [
        "STORE_NAME",
        "from .formatting import Event, Source"
    ],
    [
        "STORE_NAME",
        "from .variables import CommonVariable, Exploding, BaseVariable"
    ],
    [
        "STORE_NAME",
        "from .variables import CommonVariable, Exploding, BaseVariable"
    ],
    [
        "STORE_NAME",
        "from .variables import CommonVariable, Exploding, BaseVariable"
    ],
    [
        "LOAD_NAME",
        "find_repr_function"
    ],
    [
        "LOAD_NAME",
        "six"
    ],
    [
        "LOAD_ATTR",
        "six.text_type"
    ],
    [
        "CALL",
        "find_repr_function(six.text_type)"
    ],
    [
        "STORE_ATTR",
        "find_repr_function(six.text_type).maxparts"
    ],
    [
        "LOAD_NAME",
        "find_repr_function"
    ],
    [
        "LOAD_NAME",
        "six"
    ],
    [
        "LOAD_ATTR",
        "six.binary_type"
    ],
    [
        "CALL",
        "find_repr_function(six.binary_type)"
    ],
    [
        "STORE_ATTR",
        "find_repr_function(six.binary_type).maxparts"
    ],
    [
        "LOAD_NAME",
        "find_repr_function"
    ],
    [
        "LOAD_NAME",
        "object"
    ],
    [
        "CALL",
        "find_repr_function(object)"
    ],
    [
        "STORE_ATTR",
        "find_repr_function(object).maxparts"
    ],
    [
        "LOAD_NAME",
        "find_repr_function"
    ],
    [
        "LOAD_NAME",
        "int"
    ],
    [
        "CALL",
        "find_repr_function(int)"
    ],
    [
        "STORE_ATTR",
        "find_repr_function(int).maxparts"
    ],
    [
        "LOAD_NAME",
        "cheap_repr"
    ],
    [
        "STORE_ATTR",
        "cheap_repr.suppression_threshold"
    ],
    [
        "LOAD_NAME",
        "object"
    ],
    [
        "CALL",
        "class FrameInfo(object):\n    def __init__(self, frame):\n        self.frame = frame\n        self.local_reprs = {}\n        self.last_line_no = frame.f_lineno\n        self.comprehension_variables = OrderedDict()\n        self.source = Source.for_frame(frame)\n        self.is_generator = frame.f_code.co_flags & inspect.CO_GENERATOR\n        self.had_exception = False\n        if is_comprehension_frame(frame):\n            self.comprehension_type = (\n                    re.match(r'<(\\w+)comp>', frame.f_code.co_name).group(1).title()\n                    + u' comprehension'\n            )\n        else:\n            self.comprehension_type = ''\n\n    def update_variables(self, watch, watch_extras, event):\n        self.last_line_no = self.frame.f_lineno\n        old_local_reprs = self.local_reprs\n        self.local_reprs = OrderedDict(\n            (source, my_cheap_repr(value))\n            for source, value in\n            self.get_local_reprs(watch, watch_extras)\n        )\n\n        if self.comprehension_type:\n            for name, value_repr in self.local_reprs.items():\n                values = self.comprehension_variables.setdefault(name, [])\n                if not values or values[-1] != value_repr:\n                    values.append(value_repr)\n                    values[:] = truncate_list(values, 11)\n            if event in ('return', 'exception'):\n                return [\n                    (name, ', '.join(values))\n                    for name, values in self.comprehension_variables.items()\n                ]\n            else:\n                return []\n\n        variables = []\n        for name, value_repr in self.local_reprs.items():\n            if name not in old_local_reprs or old_local_reprs[name] != value_repr:\n                variables.append((name, value_repr))\n        return variables\n\n    def get_local_reprs(self, watch, watch_extras):\n        frame = self.frame\n        code = frame.f_code\n        vars_order = code.co_varnames + code.co_cellvars + code.co_freevars + tuple(frame.f_locals.keys())\n\n        result_items = sorted(\n            frame.f_locals.items(),\n            key=lambda key_value: vars_order.index(key_value[0])\n        )\n\n        for variable in watch:\n            result_items += sorted(variable.items(frame))\n\n        for source, value in result_items:\n            yield source, value\n            for extra in watch_extras:\n                try:\n                    pair = extra(source, value)\n                except Exception:\n                    pass\n                else:\n                    if pair is not None:\n                        assert len(pair) == 2, \"Watch extra must return pair or None\"\n                        yield pair"
    ],
    [
        "STORE_NAME",
        "class FrameInfo(object):\n    def __init__(self, frame):\n        self.frame = frame\n        self.local_reprs = {}\n        self.last_line_no = frame.f_lineno\n        self.comprehension_variables = OrderedDict()\n        self.source = Source.for_frame(frame)\n        self.is_generator = frame.f_code.co_flags & inspect.CO_GENERATOR\n        self.had_exception = False\n        if is_comprehension_frame(frame):\n            self.comprehension_type = (\n                    re.match(r'<(\\w+)comp>', frame.f_code.co_name).group(1).title()\n                    + u' comprehension'\n            )\n        else:\n            self.comprehension_type = ''\n\n    def update_variables(self, watch, watch_extras, event):\n        self.last_line_no = self.frame.f_lineno\n        old_local_reprs = self.local_reprs\n        self.local_reprs = OrderedDict(\n            (source, my_cheap_repr(value))\n            for source, value in\n            self.get_local_reprs(watch, watch_extras)\n        )\n\n        if self.comprehension_type:\n            for name, value_repr in self.local_reprs.items():\n                values = self.comprehension_variables.setdefault(name, [])\n                if not values or values[-1] != value_repr:\n                    values.append(value_repr)\n                    values[:] = truncate_list(values, 11)\n            if event in ('return', 'exception'):\n                return [\n                    (name, ', '.join(values))\n                    for name, values in self.comprehension_variables.items()\n                ]\n            else:\n                return []\n\n        variables = []\n        for name, value_repr in self.local_reprs.items():\n            if name not in old_local_reprs or old_local_reprs[name] != value_repr:\n                variables.append((name, value_repr))\n        return variables\n\n    def get_local_reprs(self, watch, watch_extras):\n        frame = self.frame\n        code = frame.f_code\n        vars_order = code.co_varnames + code.co_cellvars + code.co_freevars + tuple(frame.f_locals.keys())\n\n        result_items = sorted(\n            frame.f_locals.items(),\n            key=lambda key_value: vars_order.index(key_value[0])\n        )\n\n        for variable in watch:\n            result_items += sorted(variable.items(frame))\n\n        for source, value in result_items:\n            yield source, value\n            for extra in watch_extras:\n                try:\n                    pair = extra(source, value)\n                except Exception:\n                    pass\n                else:\n                    if pair is not None:\n                        assert len(pair) == 2, \"Watch extra must return pair or None\"\n                        yield pair"
    ],
    [
        "LOAD_NAME",
        "threading"
    ],
    [
        "LOAD_ATTR",
        "threading.local"
    ],
    [
        "CALL",
        "threading.local()"
    ],
    [
        "STORE_NAME",
        "thread_global"
    ],
    [
        "LOAD_NAME",
        "os"
    ],
    [
        "LOAD_ATTR",
        "os.path"
    ],
    [
        "LOAD_ATTR",
        "os.path.dirname"
    ],
    [
        "LOAD_ATTR",
        "(lambda: 0).__code__"
    ],
    [
        "LOAD_ATTR",
        "(lambda: 0).__code__.co_filename"
    ],
    [
        "CALL",
        "os.path.dirname((lambda: 0).__code__.co_filename)"
    ],
    [
        "STORE_NAME",
        "internal_directories"
    ],
    [
        "STORE_NAME",
        "import birdseye"
    ],
    [
        "LOAD_NAME",
        "internal_directories"
    ],
    [
        "LOAD_NAME",
        "os"
    ],
    [
        "LOAD_ATTR",
        "os.path"
    ],
    [
        "LOAD_ATTR",
        "os.path.dirname"
    ],
    [
        "LOAD_NAME",
        "birdseye"
    ],
    [
        "LOAD_ATTR",
        "birdseye.__file__"
    ],
    [
        "CALL",
        "os.path.dirname(birdseye.__file__)"
    ],
    [
        "BINARY_OP",
        "internal_directories += (os.path.dirname(birdseye.__file__),)"
    ],
    [
        "STORE_NAME",
        "internal_directories"
    ],
    [
        "LOAD_NAME",
        "type"
    ],
    [
        "CALL",
        "class TracerMeta(type):\n    def __new__(mcs, *args, **kwargs):\n        result = super(TracerMeta, mcs).__new__(mcs, *args, **kwargs)\n        result.default = result()\n        return result\n\n    def __call__(cls, *args, **kwargs):\n        if no_args_decorator(args, kwargs):\n            return cls.default(args[0])\n        else:\n            return super(TracerMeta, cls).__call__(*args, **kwargs)\n\n    def __enter__(self):\n        return self.default.__enter__(context=1)\n\n    def __exit__(self, *args):\n        return self.default.__exit__(*args, context=1)"
    ],
    [
        "STORE_NAME",
        "class TracerMeta(type):\n    def __new__(mcs, *args, **kwargs):\n        result = super(TracerMeta, mcs).__new__(mcs, *args, **kwargs)\n        result.default = result()\n        return result\n\n    def __call__(cls, *args, **kwargs):\n        if no_args_decorator(args, kwargs):\n            return cls.default(args[0])\n        else:\n            return super(TracerMeta, cls).__call__(*args, **kwargs)\n\n    def __enter__(self):\n        return self.default.__enter__(context=1)\n\n    def __exit__(self, *args):\n        return self.default.__exit__(*args, context=1)"
    ],
    [
        "LOAD_NAME",
        "six"
    ],
    [
        "LOAD_ATTR",
        "six.add_metaclass"
    ],
    [
        "LOAD_NAME",
        "TracerMeta"
    ],
    [
        "CALL",
        "six.add_metaclass(TracerMeta)"
    ],
    [
        "LOAD_NAME",
        "object"
    ],
    [
        "CALL",
        "@six.add_metaclass(TracerMeta)\nclass Tracer(object):\n    def __init__(\n            self,\n            watch=(),\n            watch_explode=(),\n            depth=1,\n    ):\n        self.watch = [\n            v if isinstance(v, BaseVariable) else CommonVariable(v)\n            for v in ensure_tuple(watch)\n        ] + [\n            v if isinstance(v, BaseVariable) else Exploding(v)\n            for v in ensure_tuple(watch_explode)\n        ]\n        self.frame_infos = ArgDefaultDict(FrameInfo)\n        self.depth = depth\n        assert self.depth >= 1\n        self.target_codes = set()\n        self.target_frames = set()\n\n    def __call__(self, function):\n        if iscoroutinefunction(function):\n            raise NotImplementedError(\"coroutines are not supported, sorry!\")\n\n        self.target_codes.add(function.__code__)\n\n        @functools.wraps(function)\n        def simple_wrapper(*args, **kwargs):\n            with self:\n                return function(*args, **kwargs)\n\n        @functools.wraps(function)\n        def generator_wrapper(*args, **kwargs):\n            gen = function(*args, **kwargs)\n            method, incoming = gen.send, None\n            while True:\n                with self:\n                    try:\n                        outgoing = method(incoming)\n                    except StopIteration:\n                        return\n                try:\n                    method, incoming = gen.send, (yield outgoing)\n                except Exception as e:\n                    method, incoming = gen.throw, e\n\n        if inspect.isgeneratorfunction(function):\n            return generator_wrapper\n        else:\n            return simple_wrapper\n\n    def __enter__(self, context=0):\n        if not self.config.enabled:\n            return\n\n        calling_frame = sys._getframe(context + 1)\n        if not self._is_internal_frame(calling_frame):\n            calling_frame.f_trace = self.trace\n            self.target_frames.add(calling_frame)\n            self.config.last_frame = calling_frame\n            self.trace(calling_frame, 'enter', None)\n\n        stack = thread_global.__dict__.setdefault('original_trace_functions', [])\n        stack.append(sys.gettrace())\n        sys.settrace(self.trace)\n\n    def __exit__(self, exc_type, exc_value, exc_traceback, context=0):\n        if not self.config.enabled:\n            return\n\n        stack = thread_global.original_trace_functions\n        sys.settrace(stack.pop())\n        calling_frame = sys._getframe(context + 1)\n        self.trace(calling_frame, 'exit', None)\n        self.target_frames.discard(calling_frame)\n        self.frame_infos.pop(calling_frame, None)\n\n    def _is_internal_frame(self, frame):\n        return frame.f_code.co_filename.startswith(internal_directories)\n    \n    def _is_traced_frame(self, frame):\n        return frame.f_code in self.target_codes or frame in self.target_frames\n\n    def trace(self, frame, event, arg):\n        if not self._is_traced_frame(frame):\n            if (\n                    self.depth == 1\n                    or self._is_internal_frame(frame)\n            ) and not is_comprehension_frame(frame):\n                return None\n            else:\n                candidate = frame\n                i = 0\n                while True:\n                    if is_comprehension_frame(candidate):\n                        candidate = candidate.f_back\n                        continue\n                    i += 1\n                    if self._is_traced_frame(candidate):\n                        break\n                    candidate = candidate.f_back\n                    if i >= self.depth or candidate is None or self._is_internal_frame(candidate):\n                        return None\n\n        thread_local = self.config.thread_local\n        thread_local.__dict__.setdefault('depth', -1)\n        frame_info = self.frame_infos[frame]\n        if event in ('call', 'enter'):\n            thread_local.depth += 1\n        elif self.config.last_frame and self.config.last_frame is not frame:\n            line_no = frame_info.last_line_no\n            trace_event = Event(frame_info, event, arg, thread_local.depth, line_no=line_no)\n            line = self.config.formatter.format_line_only(trace_event)\n            self.config.write(line)\n\n        if event == 'exception':\n            frame_info.had_exception = True\n\n        self.config.last_frame = frame\n\n        trace_event = Event(frame_info, event, arg, thread_local.depth)\n        if not (frame.f_code.co_name == '<genexpr>' and event not in ('return', 'exception')):\n            trace_event.variables = frame_info.update_variables(\n                self.watch,\n                self.config.watch_extras,\n                event,\n            )\n\n        if event in ('return', 'exit'):\n            del self.frame_infos[frame]\n            thread_local.depth -= 1\n\n        formatted = self.config.formatter.format(trace_event)\n        self.config.write(formatted)\n\n        return self.trace"
    ],
    [
        "CALL",
        "six.add_metaclass(TracerMeta)"
    ],
    [
        "STORE_NAME",
        "@six.add_metaclass(TracerMeta)\nclass Tracer(object):\n    def __init__(\n            self,\n            watch=(),\n            watch_explode=(),\n            depth=1,\n    ):\n        self.watch = [\n            v if isinstance(v, BaseVariable) else CommonVariable(v)\n            for v in ensure_tuple(watch)\n        ] + [\n            v if isinstance(v, BaseVariable) else Exploding(v)\n            for v in ensure_tuple(watch_explode)\n        ]\n        self.frame_infos = ArgDefaultDict(FrameInfo)\n        self.depth = depth\n        assert self.depth >= 1\n        self.target_codes = set()\n        self.target_frames = set()\n\n    def __call__(self, function):\n        if iscoroutinefunction(function):\n            raise NotImplementedError(\"coroutines are not supported, sorry!\")\n\n        self.target_codes.add(function.__code__)\n\n        @functools.wraps(function)\n        def simple_wrapper(*args, **kwargs):\n            with self:\n                return function(*args, **kwargs)\n\n        @functools.wraps(function)\n        def generator_wrapper(*args, **kwargs):\n            gen = function(*args, **kwargs)\n            method, incoming = gen.send, None\n            while True:\n                with self:\n                    try:\n                        outgoing = method(incoming)\n                    except StopIteration:\n                        return\n                try:\n                    method, incoming = gen.send, (yield outgoing)\n                except Exception as e:\n                    method, incoming = gen.throw, e\n\n        if inspect.isgeneratorfunction(function):\n            return generator_wrapper\n        else:\n            return simple_wrapper\n\n    def __enter__(self, context=0):\n        if not self.config.enabled:\n            return\n\n        calling_frame = sys._getframe(context + 1)\n        if not self._is_internal_frame(calling_frame):\n            calling_frame.f_trace = self.trace\n            self.target_frames.add(calling_frame)\n            self.config.last_frame = calling_frame\n            self.trace(calling_frame, 'enter', None)\n\n        stack = thread_global.__dict__.setdefault('original_trace_functions', [])\n        stack.append(sys.gettrace())\n        sys.settrace(self.trace)\n\n    def __exit__(self, exc_type, exc_value, exc_traceback, context=0):\n        if not self.config.enabled:\n            return\n\n        stack = thread_global.original_trace_functions\n        sys.settrace(stack.pop())\n        calling_frame = sys._getframe(context + 1)\n        self.trace(calling_frame, 'exit', None)\n        self.target_frames.discard(calling_frame)\n        self.frame_infos.pop(calling_frame, None)\n\n    def _is_internal_frame(self, frame):\n        return frame.f_code.co_filename.startswith(internal_directories)\n    \n    def _is_traced_frame(self, frame):\n        return frame.f_code in self.target_codes or frame in self.target_frames\n\n    def trace(self, frame, event, arg):\n        if not self._is_traced_frame(frame):\n            if (\n                    self.depth == 1\n                    or self._is_internal_frame(frame)\n            ) and not is_comprehension_frame(frame):\n                return None\n            else:\n                candidate = frame\n                i = 0\n                while True:\n                    if is_comprehension_frame(candidate):\n                        candidate = candidate.f_back\n                        continue\n                    i += 1\n                    if self._is_traced_frame(candidate):\n                        break\n                    candidate = candidate.f_back\n                    if i >= self.depth or candidate is None or self._is_internal_frame(candidate):\n                        return None\n\n        thread_local = self.config.thread_local\n        thread_local.__dict__.setdefault('depth', -1)\n        frame_info = self.frame_infos[frame]\n        if event in ('call', 'enter'):\n            thread_local.depth += 1\n        elif self.config.last_frame and self.config.last_frame is not frame:\n            line_no = frame_info.last_line_no\n            trace_event = Event(frame_info, event, arg, thread_local.depth, line_no=line_no)\n            line = self.config.formatter.format_line_only(trace_event)\n            self.config.write(line)\n\n        if event == 'exception':\n            frame_info.had_exception = True\n\n        self.config.last_frame = frame\n\n        trace_event = Event(frame_info, event, arg, thread_local.depth)\n        if not (frame.f_code.co_name == '<genexpr>' and event not in ('return', 'exception')):\n            trace_event.variables = frame_info.update_variables(\n                self.watch,\n                self.config.watch_extras,\n                event,\n            )\n\n        if event in ('return', 'exit'):\n            del self.frame_infos[frame]\n            thread_local.depth -= 1\n\n        formatted = self.config.formatter.format(trace_event)\n        self.config.write(formatted)\n\n        return self.trace"
    ],
    [
        "LOAD_NAME",
        "object"
    ],
    [
        "CALL",
        "class Spy(object):\n    def __init__(self, config):\n        self.config = config\n\n    def __call__(self, *args, **kwargs):\n        if NO_ASTTOKENS:\n            raise Exception(\"birdseye doesn't support this version of Python\")\n\n        try:\n            import birdseye\n        except ImportError:\n            raise Exception(\"You must install birdseye separately to use spy: pip install birdseye\")\n\n        # Decorator without parentheses\n        if no_args_decorator(args, kwargs):\n            return self._trace(args[0])\n\n        # Decorator with parentheses and perhaps arguments\n        def decorator(func):\n            return self._trace(func, *args, **kwargs)\n\n        return decorator\n\n    def _trace(self, func, *args, **kwargs):\n        # noinspection PyUnresolvedReferences\n        from birdseye import eye\n\n        traced = eye(func)\n        traced = self.config.snoop(*args, **kwargs)(traced)\n\n        @functools.wraps(func)\n        def wrapper(*func_args, **func_kwargs):\n            if self.config.enabled:\n                final_func = traced\n            else:\n                final_func = func\n\n            return final_func(*func_args, **func_kwargs)\n\n        return wrapper"
    ],
    [
        "STORE_NAME",
        "class Spy(object):\n    def __init__(self, config):\n        self.config = config\n\n    def __call__(self, *args, **kwargs):\n        if NO_ASTTOKENS:\n            raise Exception(\"birdseye doesn't support this version of Python\")\n\n        try:\n            import birdseye\n        except ImportError:\n            raise Exception(\"You must install birdseye separately to use spy: pip install birdseye\")\n\n        # Decorator without parentheses\n        if no_args_decorator(args, kwargs):\n            return self._trace(args[0])\n\n        # Decorator with parentheses and perhaps arguments\n        def decorator(func):\n            return self._trace(func, *args, **kwargs)\n\n        return decorator\n\n    def _trace(self, func, *args, **kwargs):\n        # noinspection PyUnresolvedReferences\n        from birdseye import eye\n\n        traced = eye(func)\n        traced = self.config.snoop(*args, **kwargs)(traced)\n\n        @functools.wraps(func)\n        def wrapper(*func_args, **func_kwargs):\n            if self.config.enabled:\n                final_func = traced\n            else:\n                final_func = func\n\n            return final_func(*func_args, **func_kwargs)\n\n        return wrapper"
    ],
    [
        "LOAD_NAME",
        "ImportError"
    ],
    [
        "STORE_NAME",
        "    def __init__(self, frame):\n        self.frame = frame\n        self.local_reprs = {}\n        self.last_line_no = frame.f_lineno\n        self.comprehension_variables = OrderedDict()\n        self.source = Source.for_frame(frame)\n        self.is_generator = frame.f_code.co_flags & inspect.CO_GENERATOR\n        self.had_exception = False\n        if is_comprehension_frame(frame):\n            self.comprehension_type = (\n                    re.match(r'<(\\w+)comp>', frame.f_code.co_name).group(1).title()\n                    + u' comprehension'\n            )\n        else:\n            self.comprehension_type = ''"
    ],
    [
        "STORE_NAME",
        "    def update_variables(self, watch, watch_extras, event):\n        self.last_line_no = self.frame.f_lineno\n        old_local_reprs = self.local_reprs\n        self.local_reprs = OrderedDict(\n            (source, my_cheap_repr(value))\n            for source, value in\n            self.get_local_reprs(watch, watch_extras)\n        )\n\n        if self.comprehension_type:\n            for name, value_repr in self.local_reprs.items():\n                values = self.comprehension_variables.setdefault(name, [])\n                if not values or values[-1] != value_repr:\n                    values.append(value_repr)\n                    values[:] = truncate_list(values, 11)\n            if event in ('return', 'exception'):\n                return [\n                    (name, ', '.join(values))\n                    for name, values in self.comprehension_variables.items()\n                ]\n            else:\n                return []\n\n        variables = []\n        for name, value_repr in self.local_reprs.items():\n            if name not in old_local_reprs or old_local_reprs[name] != value_repr:\n                variables.append((name, value_repr))\n        return variables"
    ],
    [
        "STORE_NAME",
        "    def get_local_reprs(self, watch, watch_extras):\n        frame = self.frame\n        code = frame.f_code\n        vars_order = code.co_varnames + code.co_cellvars + code.co_freevars + tuple(frame.f_locals.keys())\n\n        result_items = sorted(\n            frame.f_locals.items(),\n            key=lambda key_value: vars_order.index(key_value[0])\n        )\n\n        for variable in watch:\n            result_items += sorted(variable.items(frame))\n\n        for source, value in result_items:\n            yield source, value\n            for extra in watch_extras:\n                try:\n                    pair = extra(source, value)\n                except Exception:\n                    pass\n                else:\n                    if pair is not None:\n                        assert len(pair) == 2, \"Watch extra must return pair or None\"\n                        yield pair"
    ],
    [
        "STORE_NAME",
        "    def get_local_reprs(self, watch, watch_extras):\n        frame = self.frame\n        code = frame.f_code\n        vars_order = code.co_varnames + code.co_cellvars + code.co_freevars + tuple(frame.f_locals.keys())\n\n        result_items = sorted(\n            frame.f_locals.items(),\n            key=lambda key_value: vars_order.index(key_value[0])\n        )\n\n        for variable in watch:\n            result_items += sorted(variable.items(frame))\n\n        for source, value in result_items:\n            yield source, value\n            for extra in watch_extras:\n                try:\n                    pair = extra(source, value)\n                except Exception:\n                    pass\n                else:\n                    if pair is not None:\n                        assert len(pair) == 2, \"Watch extra must return pair or None\"\n                        yield pair"
    ],
    [
        "LOAD_FAST_BORROW",
        "    def get_local_reprs(self, watch, watch_extras):\n        frame = self.frame\n        code = frame.f_code\n        vars_order = code.co_varnames + code.co_cellvars + code.co_freevars + tuple(frame.f_locals.keys())\n\n        result_items = sorted(\n            frame.f_locals.items(),\n            key=lambda key_value: vars_order.index(key_value[0])\n        )\n\n        for variable in watch:\n            result_items += sorted(variable.items(frame))\n\n        for source, value in result_items:\n            yield source, value\n            for extra in watch_extras:\n                try:\n                    pair = extra(source, value)\n                except Exception:\n                    pass\n                else:\n                    if pair is not None:\n                        assert len(pair) == 2, \"Watch extra must return pair or None\"\n                        yield pair"
    ],
    [
        "STORE_NAME",
        "    def get_local_reprs(self, watch, watch_extras):\n        frame = self.frame\n        code = frame.f_code\n        vars_order = code.co_varnames + code.co_cellvars + code.co_freevars + tuple(frame.f_locals.keys())\n\n        result_items = sorted(\n            frame.f_locals.items(),\n            key=lambda key_value: vars_order.index(key_value[0])\n        )\n\n        for variable in watch:\n            result_items += sorted(variable.items(frame))\n\n        for source, value in result_items:\n            yield source, value\n            for extra in watch_extras:\n                try:\n                    pair = extra(source, value)\n                except Exception:\n                    pass\n                else:\n                    if pair is not None:\n                        assert len(pair) == 2, \"Watch extra must return pair or None\"\n                        yield pair"
    ],
    [
        "LOAD_FAST_BORROW_LOAD_FAST_BORROW",
        "frame"
    ],
    [
        "STORE_ATTR",
        "self.frame"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.local_reprs"
    ],
    [
        "LOAD_FAST_BORROW",
        "frame"
    ],
    [
        "LOAD_ATTR",
        "frame.f_lineno"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.last_line_no"
    ],
    [
        "LOAD_GLOBAL",
        "OrderedDict"
    ],
    [
        "CALL",
        "OrderedDict()"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.comprehension_variables"
    ],
    [
        "LOAD_GLOBAL",
        "Source"
    ],
    [
        "LOAD_ATTR",
        "Source.for_frame"
    ],
    [
        "LOAD_FAST_BORROW",
        "frame"
    ],
    [
        "CALL",
        "Source.for_frame(frame)"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.source"
    ],
    [
        "LOAD_FAST_BORROW",
        "frame"
    ],
    [
        "LOAD_ATTR",
        "frame.f_code"
    ],
    [
        "LOAD_ATTR",
        "frame.f_code.co_flags"
    ],
    [
        "LOAD_GLOBAL",
        "inspect"
    ],
    [
        "LOAD_ATTR",
        "inspect.CO_GENERATOR"
    ],
    [
        "BINARY_OP",
        "frame.f_code.co_flags & inspect.CO_GENERATOR"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.is_generator"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.had_exception"
    ],
    [
        "LOAD_GLOBAL",
        "is_comprehension_frame"
    ],
    [
        "LOAD_FAST_BORROW",
        "frame"
    ],
    [
        "CALL",
        "is_comprehension_frame(frame)"
    ],
    [
        "LOAD_GLOBAL",
        "re"
    ],
    [
        "LOAD_ATTR",
        "re.match"
    ],
    [
        "LOAD_FAST_BORROW",
        "frame"
    ],
    [
        "LOAD_ATTR",
        "frame.f_code"
    ],
    [
        "LOAD_ATTR",
        "frame.f_code.co_name"
    ],
    [
        "CALL",
        "re.match(r'<(\\w+)comp>', frame.f_code.co_name)"
    ],
    [
        "LOAD_ATTR",
        "re.match(r'<(\\w+)comp>', frame.f_code.co_name).group"
    ],
    [
        "CALL",
        "re.match(r'<(\\w+)comp>', frame.f_code.co_name).group(1)"
    ],
    [
        "LOAD_ATTR",
        "re.match(r'<(\\w+)comp>', frame.f_code.co_name).group(1).title"
    ],
    [
        "CALL",
        "re.match(r'<(\\w+)comp>', frame.f_code.co_name).group(1).title()"
    ],
    [
        "BINARY_OP",
        "re.match(r'<(\\w+)comp>', frame.f_code.co_name).group(1).title()\n                    + u' comprehension'"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.comprehension_type"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.comprehension_type"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.frame"
    ],
    [
        "LOAD_ATTR",
        "self.frame.f_lineno"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.last_line_no"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.local_reprs"
    ],
    [
        "STORE_FAST",
        "old_local_reprs"
    ],
    [
        "LOAD_GLOBAL",
        "OrderedDict"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.get_local_reprs"
    ],
    [
        "LOAD_FAST_BORROW_LOAD_FAST_BORROW",
        "watch"
    ],
    [
        "CALL",
        "self.get_local_reprs(watch, watch_extras)"
    ],
    [
        "CALL",
        "(\n            (source, my_cheap_repr(value))\n            for source, value in\n            self.get_local_reprs(watch, watch_extras)\n        )"
    ],
    [
        "CALL",
        "OrderedDict(\n            (source, my_cheap_repr(value))\n            for source, value in\n            self.get_local_reprs(watch, watch_extras)\n        )"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.local_reprs"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.comprehension_type"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.local_reprs"
    ],
    [
        "LOAD_ATTR",
        "self.local_reprs.items"
    ],
    [
        "CALL",
        "self.local_reprs.items()"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.comprehension_variables"
    ],
    [
        "LOAD_ATTR",
        "self.comprehension_variables.setdefault"
    ],
    [
        "LOAD_FAST_BORROW",
        "name"
    ],
    [
        "CALL",
        "self.comprehension_variables.setdefault(name, [])"
    ],
    [
        "STORE_FAST",
        "values"
    ],
    [
        "LOAD_FAST_BORROW",
        "values"
    ],
    [
        "LOAD_FAST_BORROW",
        "values"
    ],
    [
        "BINARY_OP",
        "values[-1]"
    ],
    [
        "LOAD_FAST_BORROW",
        "value_repr"
    ],
    [
        "COMPARE_OP",
        "values[-1] != value_repr"
    ],
    [
        "LOAD_FAST_BORROW",
        "values"
    ],
    [
        "LOAD_ATTR",
        "values.append"
    ],
    [
        "LOAD_FAST_BORROW",
        "value_repr"
    ],
    [
        "CALL",
        "values.append(value_repr)"
    ],
    [
        "LOAD_GLOBAL",
        "truncate_list"
    ],
    [
        "LOAD_FAST_BORROW",
        "values"
    ],
    [
        "CALL",
        "truncate_list(values, 11)"
    ],
    [
        "LOAD_FAST_BORROW",
        "values"
    ],
    [
        "STORE_SUBSCR",
        "values[:]"
    ],
    [
        "LOAD_FAST_BORROW",
        "event"
    ],
    [
        "CONTAINS_OP",
        "event in ('return', 'exception')"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.comprehension_variables"
    ],
    [
        "LOAD_ATTR",
        "self.comprehension_variables.items"
    ],
    [
        "CALL",
        "self.comprehension_variables.items()"
    ],
    [
        "LOAD_FAST_AND_CLEAR",
        "[\n                    (name, ', '.join(values))\n                    for name, values in self.comprehension_variables.items()\n                ]"
    ],
    [
        "LOAD_FAST_AND_CLEAR",
        "[\n                    (name, ', '.join(values))\n                    for name, values in self.comprehension_variables.items()\n                ]"
    ],
    [
        "LOAD_FAST_BORROW",
        "name"
    ],
    [
        "LOAD_ATTR",
        "', '.join"
    ],
    [
        "LOAD_FAST_BORROW",
        "values"
    ],
    [
        "CALL",
        "', '.join(values)"
    ],
    [
        "STORE_FAST",
        "[\n                    (name, ', '.join(values))\n                    for name, values in self.comprehension_variables.items()\n                ]"
    ],
    [
        "STORE_FAST",
        "[\n                    (name, ', '.join(values))\n                    for name, values in self.comprehension_variables.items()\n                ]"
    ],
    [
        "STORE_FAST",
        "variables"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.local_reprs"
    ],
    [
        "LOAD_ATTR",
        "self.local_reprs.items"
    ],
    [
        "CALL",
        "self.local_reprs.items()"
    ],
    [
        "LOAD_FAST_BORROW_LOAD_FAST_BORROW",
        "name"
    ],
    [
        "CONTAINS_OP",
        "name not in old_local_reprs"
    ],
    [
        "LOAD_FAST_BORROW_LOAD_FAST_BORROW",
        "old_local_reprs"
    ],
    [
        "BINARY_OP",
        "old_local_reprs[name]"
    ],
    [
        "LOAD_FAST_BORROW",
        "value_repr"
    ],
    [
        "COMPARE_OP",
        "old_local_reprs[name] != value_repr"
    ],
    [
        "LOAD_FAST_BORROW",
        "variables"
    ],
    [
        "LOAD_ATTR",
        "variables.append"
    ],
    [
        "LOAD_FAST_BORROW_LOAD_FAST_BORROW",
        "name"
    ],
    [
        "CALL",
        "variables.append((name, value_repr))"
    ],
    [
        "LOAD_FAST_BORROW",
        "variables"
    ],
    [
        "STORE_FAST",
        "[\n                    (name, ', '.join(values))\n                    for name, values in self.comprehension_variables.items()\n                ]"
    ],
    [
        "STORE_FAST",
        "[\n                    (name, ', '.join(values))\n                    for name, values in self.comprehension_variables.items()\n                ]"
    ],
    [
        "LOAD_FAST",
        "(\n            (source, my_cheap_repr(value))\n            for source, value in\n            self.get_local_reprs(watch, watch_extras)\n        )"
    ],
    [
        "LOAD_FAST_BORROW",
        "source"
    ],
    [
        "LOAD_GLOBAL",
        "my_cheap_repr"
    ],
    [
        "LOAD_FAST_BORROW",
        "value"
    ],
    [
        "CALL",
        "my_cheap_repr(value)"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.frame"
    ],
    [
        "STORE_FAST",
        "frame"
    ],
    [
        "LOAD_FAST_BORROW",
        "frame"
    ],
    [
        "LOAD_ATTR",
        "frame.f_code"
    ],
    [
        "STORE_FAST",
        "code"
    ],
    [
        "LOAD_FAST_BORROW",
        "code"
    ],
    [
        "LOAD_ATTR",
        "code.co_varnames"
    ],
    [
        "LOAD_FAST_BORROW",
        "code"
    ],
    [
        "LOAD_ATTR",
        "code.co_cellvars"
    ],
    [
        "BINARY_OP",
        "code.co_varnames + code.co_cellvars"
    ],
    [
        "LOAD_FAST_BORROW",
        "code"
    ],
    [
        "LOAD_ATTR",
        "code.co_freevars"
    ],
    [
        "BINARY_OP",
        "code.co_varnames + code.co_cellvars + code.co_freevars"
    ],
    [
        "LOAD_GLOBAL",
        "tuple"
    ],
    [
        "LOAD_FAST_BORROW",
        "frame"
    ],
    [
        "LOAD_ATTR",
        "frame.f_locals"
    ],
    [
        "LOAD_ATTR",
        "frame.f_locals.keys"
    ],
    [
        "CALL",
        "frame.f_locals.keys()"
    ],
    [
        "CALL",
        "tuple(frame.f_locals.keys())"
    ],
    [
        "BINARY_OP",
        "code.co_varnames + code.co_cellvars + code.co_freevars + tuple(frame.f_locals.keys())"
    ],
    [
        "STORE_DEREF",
        "vars_order"
    ],
    [
        "LOAD_GLOBAL",
        "sorted"
    ],
    [
        "LOAD_FAST_BORROW",
        "frame"
    ],
    [
        "LOAD_ATTR",
        "frame.f_locals"
    ],
    [
        "LOAD_ATTR",
        "frame.f_locals.items"
    ],
    [
        "CALL",
        "frame.f_locals.items()"
    ],
    [
        "LOAD_FAST_BORROW",
        "lambda key_value: vars_order.index(key_value[0])"
    ],
    [
        "CALL_KW",
        "sorted(\n            frame.f_locals.items(),\n            key=lambda key_value: vars_order.index(key_value[0])\n        )"
    ],
    [
        "STORE_FAST",
        "result_items"
    ],
    [
        "LOAD_FAST_BORROW",
        "watch"
    ],
    [
        "STORE_FAST",
        "variable"
    ],
    [
        "LOAD_FAST_BORROW",
        "result_items"
    ],
    [
        "LOAD_GLOBAL",
        "sorted"
    ],
    [
        "LOAD_FAST_BORROW",
        "variable"
    ],
    [
        "LOAD_ATTR",
        "variable.items"
    ],
    [
        "LOAD_FAST_BORROW",
        "frame"
    ],
    [
        "CALL",
        "variable.items(frame)"
    ],
    [
        "CALL",
        "sorted(variable.items(frame))"
    ],
    [
        "BINARY_OP",
        "result_items += sorted(variable.items(frame))"
    ],
    [
        "STORE_FAST",
        "result_items"
    ],
    [
        "LOAD_FAST_BORROW",
        "result_items"
    ],
    [
        "LOAD_FAST_BORROW_LOAD_FAST_BORROW",
        "source"
    ],
    [
        "LOAD_FAST_BORROW",
        "watch_extras"
    ],
    [
        "STORE_FAST",
        "extra"
    ],
    [
        "LOAD_FAST_BORROW",
        "extra"
    ],
    [
        "LOAD_FAST_BORROW_LOAD_FAST_BORROW",
        "source"
    ],
    [
        "CALL",
        "extra(source, value)"
    ],
    [
        "STORE_FAST",
        "pair"
    ],
    [
        "LOAD_FAST_BORROW",
        "pair"
    ],
    [
        "LOAD_GLOBAL",
        "len"
    ],
    [
        "LOAD_FAST_BORROW",
        "pair"
    ],
    [
        "CALL",
        "len(pair)"
    ],
    [
        "COMPARE_OP",
        "len(pair) == 2"
    ],
    [
        "LOAD_FAST_BORROW",
        "pair"
    ],
    [
        "LOAD_GLOBAL",
        "Exception"
    ],
    [
        "LOAD_DEREF",
        "vars_order"
    ],
    [
        "LOAD_ATTR",
        "vars_order.index"
    ],
    [
        "LOAD_FAST_BORROW",
        "key_value"
    ],
    [
        "BINARY_OP",
        "key_value[0]"
    ],
    [
        "CALL",
        "vars_order.index(key_value[0])"
    ],
    [
        "STORE_NAME",
        "    def __new__(mcs, *args, **kwargs):\n        result = super(TracerMeta, mcs).__new__(mcs, *args, **kwargs)\n        result.default = result()\n        return result"
    ],
    [
        "STORE_NAME",
        "    def __call__(cls, *args, **kwargs):\n        if no_args_decorator(args, kwargs):\n            return cls.default(args[0])\n        else:\n            return super(TracerMeta, cls).__call__(*args, **kwargs)"
    ],
    [
        "STORE_NAME",
        "    def __enter__(self):\n        return self.default.__enter__(context=1)"
    ],
    [
        "STORE_NAME",
        "    def __exit__(self, *args):\n        return self.default.__exit__(*args, context=1)"
    ],
    [
        "STORE_NAME",
        "    def __exit__(self, *args):\n        return self.default.__exit__(*args, context=1)"
    ],
    [
        "LOAD_FAST_BORROW",
        "    def __exit__(self, *args):\n        return self.default.__exit__(*args, context=1)"
    ],
    [
        "STORE_NAME",
        "    def __exit__(self, *args):\n        return self.default.__exit__(*args, context=1)"
    ],
    [
        "LOAD_GLOBAL",
        "super"
    ],
    [
        "LOAD_GLOBAL",
        "TracerMeta"
    ],
    [
        "LOAD_FAST_BORROW",
        "mcs"
    ],
    [
        "LOAD_SUPER_ATTR",
        "super(TracerMeta, mcs).__new__"
    ],
    [
        "LOAD_FAST_BORROW",
        "mcs"
    ],
    [
        "LOAD_FAST_BORROW",
        "args"
    ],
    [
        "LOAD_FAST_BORROW",
        "kwargs"
    ],
    [
        "CALL_FUNCTION_EX",
        "super(TracerMeta, mcs).__new__(mcs, *args, **kwargs)"
    ],
    [
        "STORE_FAST",
        "result"
    ],
    [
        "LOAD_FAST_BORROW",
        "result"
    ],
    [
        "CALL",
        "result()"
    ],
    [
        "LOAD_FAST_BORROW",
        "result"
    ],
    [
        "STORE_ATTR",
        "result.default"
    ],
    [
        "LOAD_FAST_BORROW",
        "result"
    ],
    [
        "LOAD_GLOBAL",
        "no_args_decorator"
    ],
    [
        "LOAD_FAST_BORROW_LOAD_FAST_BORROW",
        "args"
    ],
    [
        "CALL",
        "no_args_decorator(args, kwargs)"
    ],
    [
        "LOAD_FAST_BORROW",
        "cls"
    ],
    [
        "LOAD_ATTR",
        "cls.default"
    ],
    [
        "LOAD_FAST_BORROW",
        "args"
    ],
    [
        "BINARY_OP",
        "args[0]"
    ],
    [
        "CALL",
        "cls.default(args[0])"
    ],
    [
        "LOAD_GLOBAL",
        "super"
    ],
    [
        "LOAD_GLOBAL",
        "TracerMeta"
    ],
    [
        "LOAD_FAST_BORROW",
        "cls"
    ],
    [
        "LOAD_SUPER_ATTR",
        "super(TracerMeta, cls).__call__"
    ],
    [
        "LOAD_FAST_BORROW",
        "args"
    ],
    [
        "LOAD_FAST_BORROW",
        "kwargs"
    ],
    [
        "CALL_FUNCTION_EX",
        "super(TracerMeta, cls).__call__(*args, **kwargs)"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.default"
    ],
    [
        "LOAD_ATTR",
        "self.default.__enter__"
    ],
    [
        "CALL_KW",
        "self.default.__enter__(context=1)"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.default"
    ],
    [
        "LOAD_ATTR",
        "self.default.__exit__"
    ],
    [
        "LOAD_FAST_BORROW",
        "args"
    ],
    [
        "CALL_FUNCTION_EX",
        "self.default.__exit__(*args, context=1)"
    ],
    [
        "STORE_NAME",
        "    def __init__(\n            self,\n            watch=(),\n            watch_explode=(),\n            depth=1,\n    ):\n        self.watch = [\n            v if isinstance(v, BaseVariable) else CommonVariable(v)\n            for v in ensure_tuple(watch)\n        ] + [\n            v if isinstance(v, BaseVariable) else Exploding(v)\n            for v in ensure_tuple(watch_explode)\n        ]\n        self.frame_infos = ArgDefaultDict(FrameInfo)\n        self.depth = depth\n        assert self.depth >= 1\n        self.target_codes = set()\n        self.target_frames = set()"
    ],
    [
        "STORE_NAME",
        "    def __call__(self, function):\n        if iscoroutinefunction(function):\n            raise NotImplementedError(\"coroutines are not supported, sorry!\")\n\n        self.target_codes.add(function.__code__)\n\n        @functools.wraps(function)\n        def simple_wrapper(*args, **kwargs):\n            with self:\n                return function(*args, **kwargs)\n\n        @functools.wraps(function)\n        def generator_wrapper(*args, **kwargs):\n            gen = function(*args, **kwargs)\n            method, incoming = gen.send, None\n            while True:\n                with self:\n                    try:\n                        outgoing = method(incoming)\n                    except StopIteration:\n                        return\n                try:\n                    method, incoming = gen.send, (yield outgoing)\n                except Exception as e:\n                    method, incoming = gen.throw, e\n\n        if inspect.isgeneratorfunction(function):\n            return generator_wrapper\n        else:\n            return simple_wrapper"
    ],
    [
        "STORE_NAME",
        "    def __enter__(self, context=0):\n        if not self.config.enabled:\n            return\n\n        calling_frame = sys._getframe(context + 1)\n        if not self._is_internal_frame(calling_frame):\n            calling_frame.f_trace = self.trace\n            self.target_frames.add(calling_frame)\n            self.config.last_frame = calling_frame\n            self.trace(calling_frame, 'enter', None)\n\n        stack = thread_global.__dict__.setdefault('original_trace_functions', [])\n        stack.append(sys.gettrace())\n        sys.settrace(self.trace)"
    ],
    [
        "STORE_NAME",
        "    def __exit__(self, exc_type, exc_value, exc_traceback, context=0):\n        if not self.config.enabled:\n            return\n\n        stack = thread_global.original_trace_functions\n        sys.settrace(stack.pop())\n        calling_frame = sys._getframe(context + 1)\n        self.trace(calling_frame, 'exit', None)\n        self.target_frames.discard(calling_frame)\n        self.frame_infos.pop(calling_frame, None)"
    ],
    [
        "STORE_NAME",
        "    def _is_internal_frame(self, frame):\n        return frame.f_code.co_filename.startswith(internal_directories)"
    ],
    [
        "STORE_NAME",
        "    def _is_traced_frame(self, frame):\n        return frame.f_code in self.target_codes or frame in self.target_frames"
    ],
    [
        "STORE_NAME",
        "    def trace(self, frame, event, arg):\n        if not self._is_traced_frame(frame):\n            if (\n                    self.depth == 1\n                    or self._is_internal_frame(frame)\n            ) and not is_comprehension_frame(frame):\n                return None\n            else:\n                candidate = frame\n                i = 0\n                while True:\n                    if is_comprehension_frame(candidate):\n                        candidate = candidate.f_back\n                        continue\n                    i += 1\n                    if self._is_traced_frame(candidate):\n                        break\n                    candidate = candidate.f_back\n                    if i >= self.depth or candidate is None or self._is_internal_frame(candidate):\n                        return None\n\n        thread_local = self.config.thread_local\n        thread_local.__dict__.setdefault('depth', -1)\n        frame_info = self.frame_infos[frame]\n        if event in ('call', 'enter'):\n            thread_local.depth += 1\n        elif self.config.last_frame and self.config.last_frame is not frame:\n            line_no = frame_info.last_line_no\n            trace_event = Event(frame_info, event, arg, thread_local.depth, line_no=line_no)\n            line = self.config.formatter.format_line_only(trace_event)\n            self.config.write(line)\n\n        if event == 'exception':\n            frame_info.had_exception = True\n\n        self.config.last_frame = frame\n\n        trace_event = Event(frame_info, event, arg, thread_local.depth)\n        if not (frame.f_code.co_name == '<genexpr>' and event not in ('return', 'exception')):\n            trace_event.variables = frame_info.update_variables(\n                self.watch,\n                self.config.watch_extras,\n                event,\n            )\n\n        if event in ('return', 'exit'):\n            del self.frame_infos[frame]\n            thread_local.depth -= 1\n\n        formatted = self.config.formatter.format(trace_event)\n        self.config.write(formatted)\n\n        return self.trace"
    ],
    [
        "STORE_NAME",
        "    def trace(self, frame, event, arg):\n        if not self._is_traced_frame(frame):\n            if (\n                    self.depth == 1\n                    or self._is_internal_frame(frame)\n            ) and not is_comprehension_frame(frame):\n                return None\n            else:\n                candidate = frame\n                i = 0\n                while True:\n                    if is_comprehension_frame(candidate):\n                        candidate = candidate.f_back\n                        continue\n                    i += 1\n                    if self._is_traced_frame(candidate):\n                        break\n                    candidate = candidate.f_back\n                    if i >= self.depth or candidate is None or self._is_internal_frame(candidate):\n                        return None\n\n        thread_local = self.config.thread_local\n        thread_local.__dict__.setdefault('depth', -1)\n        frame_info = self.frame_infos[frame]\n        if event in ('call', 'enter'):\n            thread_local.depth += 1\n        elif self.config.last_frame and self.config.last_frame is not frame:\n            line_no = frame_info.last_line_no\n            trace_event = Event(frame_info, event, arg, thread_local.depth, line_no=line_no)\n            line = self.config.formatter.format_line_only(trace_event)\n            self.config.write(line)\n\n        if event == 'exception':\n            frame_info.had_exception = True\n\n        self.config.last_frame = frame\n\n        trace_event = Event(frame_info, event, arg, thread_local.depth)\n        if not (frame.f_code.co_name == '<genexpr>' and event not in ('return', 'exception')):\n            trace_event.variables = frame_info.update_variables(\n                self.watch,\n                self.config.watch_extras,\n                event,\n            )\n\n        if event in ('return', 'exit'):\n            del self.frame_infos[frame]\n            thread_local.depth -= 1\n\n        formatted = self.config.formatter.format(trace_event)\n        self.config.write(formatted)\n\n        return self.trace"
    ],
    [
        "LOAD_FAST_BORROW",
        "    def trace(self, frame, event, arg):\n        if not self._is_traced_frame(frame):\n            if (\n                    self.depth == 1\n                    or self._is_internal_frame(frame)\n            ) and not is_comprehension_frame(frame):\n                return None\n            else:\n                candidate = frame\n                i = 0\n                while True:\n                    if is_comprehension_frame(candidate):\n                        candidate = candidate.f_back\n                        continue\n                    i += 1\n                    if self._is_traced_frame(candidate):\n                        break\n                    candidate = candidate.f_back\n                    if i >= self.depth or candidate is None or self._is_internal_frame(candidate):\n                        return None\n\n        thread_local = self.config.thread_local\n        thread_local.__dict__.setdefault('depth', -1)\n        frame_info = self.frame_infos[frame]\n        if event in ('call', 'enter'):\n            thread_local.depth += 1\n        elif self.config.last_frame and self.config.last_frame is not frame:\n            line_no = frame_info.last_line_no\n            trace_event = Event(frame_info, event, arg, thread_local.depth, line_no=line_no)\n            line = self.config.formatter.format_line_only(trace_event)\n            self.config.write(line)\n\n        if event == 'exception':\n            frame_info.had_exception = True\n\n        self.config.last_frame = frame\n\n        trace_event = Event(frame_info, event, arg, thread_local.depth)\n        if not (frame.f_code.co_name == '<genexpr>' and event not in ('return', 'exception')):\n            trace_event.variables = frame_info.update_variables(\n                self.watch,\n                self.config.watch_extras,\n                event,\n            )\n\n        if event in ('return', 'exit'):\n            del self.frame_infos[frame]\n            thread_local.depth -= 1\n\n        formatted = self.config.formatter.format(trace_event)\n        self.config.write(formatted)\n\n        return self.trace"
    ],
    [
        "STORE_NAME",
        "    def trace(self, frame, event, arg):\n        if not self._is_traced_frame(frame):\n            if (\n                    self.depth == 1\n                    or self._is_internal_frame(frame)\n            ) and not is_comprehension_frame(frame):\n                return None\n            else:\n                candidate = frame\n                i = 0\n                while True:\n                    if is_comprehension_frame(candidate):\n                        candidate = candidate.f_back\n                        continue\n                    i += 1\n                    if self._is_traced_frame(candidate):\n                        break\n                    candidate = candidate.f_back\n                    if i >= self.depth or candidate is None or self._is_internal_frame(candidate):\n                        return None\n\n        thread_local = self.config.thread_local\n        thread_local.__dict__.setdefault('depth', -1)\n        frame_info = self.frame_infos[frame]\n        if event in ('call', 'enter'):\n            thread_local.depth += 1\n        elif self.config.last_frame and self.config.last_frame is not frame:\n            line_no = frame_info.last_line_no\n            trace_event = Event(frame_info, event, arg, thread_local.depth, line_no=line_no)\n            line = self.config.formatter.format_line_only(trace_event)\n            self.config.write(line)\n\n        if event == 'exception':\n            frame_info.had_exception = True\n\n        self.config.last_frame = frame\n\n        trace_event = Event(frame_info, event, arg, thread_local.depth)\n        if not (frame.f_code.co_name == '<genexpr>' and event not in ('return', 'exception')):\n            trace_event.variables = frame_info.update_variables(\n                self.watch,\n                self.config.watch_extras,\n                event,\n            )\n\n        if event in ('return', 'exit'):\n            del self.frame_infos[frame]\n            thread_local.depth -= 1\n\n        formatted = self.config.formatter.format(trace_event)\n        self.config.write(formatted)\n\n        return self.trace"
    ],
    [
        "LOAD_GLOBAL",
        "ensure_tuple"
    ],
    [
        "LOAD_FAST_BORROW",
        "watch"
    ],
    [
        "CALL",
        "ensure_tuple(watch)"
    ],
    [
        "LOAD_FAST_AND_CLEAR",
        "[\n            v if isinstance(v, BaseVariable) else CommonVariable(v)\n            for v in ensure_tuple(watch)\n        ]"
    ],
    [
        "STORE_FAST",
        "v"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST_BORROW",
        "v"
    ],
    [
        "LOAD_GLOBAL",
        "BaseVariable"
    ],
    [
        "CALL",
        "isinstance(v, BaseVariable)"
    ],
    [
        "LOAD_FAST",
        "v"
    ],
    [
        "LOAD_GLOBAL",
        "CommonVariable"
    ],
    [
        "LOAD_FAST_BORROW",
        "v"
    ],
    [
        "CALL",
        "CommonVariable(v)"
    ],
    [
        "STORE_FAST",
        "[\n            v if isinstance(v, BaseVariable) else CommonVariable(v)\n            for v in ensure_tuple(watch)\n        ]"
    ],
    [
        "LOAD_GLOBAL",
        "ensure_tuple"
    ],
    [
        "LOAD_FAST_BORROW",
        "watch_explode"
    ],
    [
        "CALL",
        "ensure_tuple(watch_explode)"
    ],
    [
        "LOAD_FAST_AND_CLEAR",
        "[\n            v if isinstance(v, BaseVariable) else Exploding(v)\n            for v in ensure_tuple(watch_explode)\n        ]"
    ],
    [
        "STORE_FAST",
        "v"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST_BORROW",
        "v"
    ],
    [
        "LOAD_GLOBAL",
        "BaseVariable"
    ],
    [
        "CALL",
        "isinstance(v, BaseVariable)"
    ],
    [
        "LOAD_FAST",
        "v"
    ],
    [
        "LOAD_GLOBAL",
        "Exploding"
    ],
    [
        "LOAD_FAST_BORROW",
        "v"
    ],
    [
        "CALL",
        "Exploding(v)"
    ],
    [
        "STORE_FAST",
        "[\n            v if isinstance(v, BaseVariable) else Exploding(v)\n            for v in ensure_tuple(watch_explode)\n        ]"
    ],
    [
        "BINARY_OP",
        "[\n            v if isinstance(v, BaseVariable) else CommonVariable(v)\n            for v in ensure_tuple(watch)\n        ] + [\n            v if isinstance(v, BaseVariable) else Exploding(v)\n            for v in ensure_tuple(watch_explode)\n        ]"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.watch"
    ],
    [
        "LOAD_GLOBAL",
        "ArgDefaultDict"
    ],
    [
        "LOAD_GLOBAL",
        "FrameInfo"
    ],
    [
        "CALL",
        "ArgDefaultDict(FrameInfo)"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.frame_infos"
    ],
    [
        "LOAD_FAST_BORROW_LOAD_FAST_BORROW",
        "depth"
    ],
    [
        "STORE_ATTR",
        "self.depth"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.depth"
    ],
    [
        "COMPARE_OP",
        "self.depth >= 1"
    ],
    [
        "LOAD_GLOBAL",
        "set"
    ],
    [
        "CALL",
        "set()"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.target_codes"
    ],
    [
        "LOAD_GLOBAL",
        "set"
    ],
    [
        "CALL",
        "set()"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.target_frames"
    ],
    [
        "STORE_FAST",
        "[\n            v if isinstance(v, BaseVariable) else CommonVariable(v)\n            for v in ensure_tuple(watch)\n        ]"
    ],
    [
        "STORE_FAST",
        "[\n            v if isinstance(v, BaseVariable) else Exploding(v)\n            for v in ensure_tuple(watch_explode)\n        ]"
    ],
    [
        "LOAD_GLOBAL",
        "iscoroutinefunction"
    ],
    [
        "LOAD_DEREF",
        "function"
    ],
    [
        "CALL",
        "iscoroutinefunction(function)"
    ],
    [
        "LOAD_GLOBAL",
        "NotImplementedError"
    ],
    [
        "CALL",
        "NotImplementedError(\"coroutines are not supported, sorry!\")"
    ],
    [
        "LOAD_DEREF",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.target_codes"
    ],
    [
        "LOAD_ATTR",
        "self.target_codes.add"
    ],
    [
        "LOAD_DEREF",
        "function"
    ],
    [
        "LOAD_ATTR",
        "function.__code__"
    ],
    [
        "CALL",
        "self.target_codes.add(function.__code__)"
    ],
    [
        "LOAD_GLOBAL",
        "functools"
    ],
    [
        "LOAD_ATTR",
        "functools.wraps"
    ],
    [
        "LOAD_DEREF",
        "function"
    ],
    [
        "CALL",
        "functools.wraps(function)"
    ],
    [
        "LOAD_FAST_BORROW",
        "        @functools.wraps(function)\n        def simple_wrapper(*args, **kwargs):\n            with self:\n                return function(*args, **kwargs)"
    ],
    [
        "LOAD_FAST_BORROW",
        "        @functools.wraps(function)\n        def simple_wrapper(*args, **kwargs):\n            with self:\n                return function(*args, **kwargs)"
    ],
    [
        "CALL",
        "functools.wraps(function)"
    ],
    [
        "STORE_FAST",
        "        @functools.wraps(function)\n        def simple_wrapper(*args, **kwargs):\n            with self:\n                return function(*args, **kwargs)"
    ],
    [
        "LOAD_GLOBAL",
        "functools"
    ],
    [
        "LOAD_ATTR",
        "functools.wraps"
    ],
    [
        "LOAD_DEREF",
        "function"
    ],
    [
        "CALL",
        "functools.wraps(function)"
    ],
    [
        "LOAD_FAST_BORROW",
        "        @functools.wraps(function)\n        def generator_wrapper(*args, **kwargs):\n            gen = function(*args, **kwargs)\n            method, incoming = gen.send, None\n            while True:\n                with self:\n                    try:\n                        outgoing = method(incoming)\n                    except StopIteration:\n                        return\n                try:\n                    method, incoming = gen.send, (yield outgoing)\n                except Exception as e:\n                    method, incoming = gen.throw, e"
    ],
    [
        "LOAD_FAST_BORROW",
        "        @functools.wraps(function)\n        def generator_wrapper(*args, **kwargs):\n            gen = function(*args, **kwargs)\n            method, incoming = gen.send, None\n            while True:\n                with self:\n                    try:\n                        outgoing = method(incoming)\n                    except StopIteration:\n                        return\n                try:\n                    method, incoming = gen.send, (yield outgoing)\n                except Exception as e:\n                    method, incoming = gen.throw, e"
    ],
    [
        "CALL",
        "functools.wraps(function)"
    ],
    [
        "STORE_FAST",
        "        @functools.wraps(function)\n        def generator_wrapper(*args, **kwargs):\n            gen = function(*args, **kwargs)\n            method, incoming = gen.send, None\n            while True:\n                with self:\n                    try:\n                        outgoing = method(incoming)\n                    except StopIteration:\n                        return\n                try:\n                    method, incoming = gen.send, (yield outgoing)\n                except Exception as e:\n                    method, incoming = gen.throw, e"
    ],
    [
        "LOAD_GLOBAL",
        "inspect"
    ],
    [
        "LOAD_ATTR",
        "inspect.isgeneratorfunction"
    ],
    [
        "LOAD_DEREF",
        "function"
    ],
    [
        "CALL",
        "inspect.isgeneratorfunction(function)"
    ],
    [
        "LOAD_FAST_BORROW",
        "generator_wrapper"
    ],
    [
        "LOAD_FAST_BORROW",
        "simple_wrapper"
    ],
    [
        "LOAD_DEREF",
        "self"
    ],
    [
        "CALL",
        "            with self:\n                return function(*args, **kwargs)"
    ],
    [
        "LOAD_DEREF",
        "function"
    ],
    [
        "LOAD_FAST_BORROW",
        "args"
    ],
    [
        "LOAD_FAST_BORROW",
        "kwargs"
    ],
    [
        "CALL_FUNCTION_EX",
        "function(*args, **kwargs)"
    ],
    [
        "CALL",
        "            with self:\n                return function(*args, **kwargs)"
    ],
    [
        "LOAD_DEREF",
        "function"
    ],
    [
        "LOAD_FAST_BORROW",
        "args"
    ],
    [
        "LOAD_FAST_BORROW",
        "kwargs"
    ],
    [
        "CALL_FUNCTION_EX",
        "function(*args, **kwargs)"
    ],
    [
        "STORE_FAST",
        "gen"
    ],
    [
        "LOAD_FAST_BORROW",
        "gen"
    ],
    [
        "LOAD_ATTR",
        "gen.send"
    ],
    [
        "LOAD_DEREF",
        "self"
    ],
    [
        "CALL",
        "                with self:\n                    try:\n                        outgoing = method(incoming)\n                    except StopIteration:\n                        return"
    ],
    [
        "LOAD_FAST_BORROW",
        "method"
    ],
    [
        "LOAD_FAST_BORROW",
        "incoming"
    ],
    [
        "CALL",
        "method(incoming)"
    ],
    [
        "STORE_FAST",
        "outgoing"
    ],
    [
        "CALL",
        "                with self:\n                    try:\n                        outgoing = method(incoming)\n                    except StopIteration:\n                        return"
    ],
    [
        "LOAD_FAST",
        "gen"
    ],
    [
        "LOAD_ATTR",
        "gen.send"
    ],
    [
        "LOAD_FAST_CHECK",
        "outgoing"
    ],
    [
        "LOAD_GLOBAL",
        "StopIteration"
    ],
    [
        "CALL",
        "                with self:\n                    try:\n                        outgoing = method(incoming)\n                    except StopIteration:\n                        return"
    ],
    [
        "LOAD_GLOBAL",
        "Exception"
    ],
    [
        "STORE_FAST",
        "                except Exception as e:\n                    method, incoming = gen.throw, e"
    ],
    [
        "LOAD_FAST",
        "gen"
    ],
    [
        "LOAD_ATTR",
        "gen.throw"
    ],
    [
        "LOAD_FAST",
        "e"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.config"
    ],
    [
        "LOAD_ATTR",
        "self.config.enabled"
    ],
    [
        "LOAD_GLOBAL",
        "sys"
    ],
    [
        "LOAD_ATTR",
        "sys._getframe"
    ],
    [
        "LOAD_FAST_BORROW",
        "context"
    ],
    [
        "BINARY_OP",
        "context + 1"
    ],
    [
        "CALL",
        "sys._getframe(context + 1)"
    ],
    [
        "STORE_FAST",
        "calling_frame"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._is_internal_frame"
    ],
    [
        "LOAD_FAST_BORROW",
        "calling_frame"
    ],
    [
        "CALL",
        "self._is_internal_frame(calling_frame)"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.trace"
    ],
    [
        "LOAD_FAST_BORROW",
        "calling_frame"
    ],
    [
        "STORE_ATTR",
        "calling_frame.f_trace"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.target_frames"
    ],
    [
        "LOAD_ATTR",
        "self.target_frames.add"
    ],
    [
        "LOAD_FAST_BORROW",
        "calling_frame"
    ],
    [
        "CALL",
        "self.target_frames.add(calling_frame)"
    ],
    [
        "LOAD_FAST_BORROW_LOAD_FAST_BORROW",
        "calling_frame"
    ],
    [
        "LOAD_ATTR",
        "self.config"
    ],
    [
        "STORE_ATTR",
        "self.config.last_frame"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.trace"
    ],
    [
        "LOAD_FAST_BORROW",
        "calling_frame"
    ],
    [
        "CALL",
        "self.trace(calling_frame, 'enter', None)"
    ],
    [
        "LOAD_GLOBAL",
        "thread_global"
    ],
    [
        "LOAD_ATTR",
        "thread_global.__dict__"
    ],
    [
        "LOAD_ATTR",
        "thread_global.__dict__.setdefault"
    ],
    [
        "CALL",
        "thread_global.__dict__.setdefault('original_trace_functions', [])"
    ],
    [
        "STORE_FAST",
        "stack"
    ],
    [
        "LOAD_FAST_BORROW",
        "stack"
    ],
    [
        "LOAD_ATTR",
        "stack.append"
    ],
    [
        "LOAD_GLOBAL",
        "sys"
    ],
    [
        "LOAD_ATTR",
        "sys.gettrace"
    ],
    [
        "CALL",
        "sys.gettrace()"
    ],
    [
        "CALL",
        "stack.append(sys.gettrace())"
    ],
    [
        "LOAD_GLOBAL",
        "sys"
    ],
    [
        "LOAD_ATTR",
        "sys.settrace"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.trace"
    ],
    [
        "CALL",
        "sys.settrace(self.trace)"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.config"
    ],
    [
        "LOAD_ATTR",
        "self.config.enabled"
    ],
    [
        "LOAD_GLOBAL",
        "thread_global"
    ],
    [
        "LOAD_ATTR",
        "thread_global.original_trace_functions"
    ],
    [
        "STORE_FAST",
        "stack"
    ],
    [
        "LOAD_GLOBAL",
        "sys"
    ],
    [
        "LOAD_ATTR",
        "sys.settrace"
    ],
    [
        "LOAD_FAST_BORROW",
        "stack"
    ],
    [
        "LOAD_ATTR",
        "stack.pop"
    ],
    [
        "CALL",
        "stack.pop()"
    ],
    [
        "CALL",
        "sys.settrace(stack.pop())"
    ],
    [
        "LOAD_GLOBAL",
        "sys"
    ],
    [
        "LOAD_ATTR",
        "sys._getframe"
    ],
    [
        "LOAD_FAST_BORROW",
        "context"
    ],
    [
        "BINARY_OP",
        "context + 1"
    ],
    [
        "CALL",
        "sys._getframe(context + 1)"
    ],
    [
        "STORE_FAST",
        "calling_frame"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.trace"
    ],
    [
        "LOAD_FAST_BORROW",
        "calling_frame"
    ],
    [
        "CALL",
        "self.trace(calling_frame, 'exit', None)"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.target_frames"
    ],
    [
        "LOAD_ATTR",
        "self.target_frames.discard"
    ],
    [
        "LOAD_FAST_BORROW",
        "calling_frame"
    ],
    [
        "CALL",
        "self.target_frames.discard(calling_frame)"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.frame_infos"
    ],
    [
        "LOAD_ATTR",
        "self.frame_infos.pop"
    ],
    [
        "LOAD_FAST_BORROW",
        "calling_frame"
    ],
    [
        "CALL",
        "self.frame_infos.pop(calling_frame, None)"
    ],
    [
        "LOAD_FAST_BORROW",
        "frame"
    ],
    [
        "LOAD_ATTR",
        "frame.f_code"
    ],
    [
        "LOAD_ATTR",
        "frame.f_code.co_filename"
    ],
    [
        "LOAD_ATTR",
        "frame.f_code.co_filename.startswith"
    ],
    [
        "LOAD_GLOBAL",
        "internal_directories"
    ],
    [
        "CALL",
        "frame.f_code.co_filename.startswith(internal_directories)"
    ],
    [
        "LOAD_FAST_BORROW",
        "frame"
    ],
    [
        "LOAD_ATTR",
        "frame.f_code"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.target_codes"
    ],
    [
        "CONTAINS_OP",
        "frame.f_code in self.target_codes"
    ],
    [
        "LOAD_FAST_BORROW_LOAD_FAST_BORROW",
        "frame"
    ],
    [
        "LOAD_ATTR",
        "self.target_frames"
    ],
    [
        "CONTAINS_OP",
        "frame in self.target_frames"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._is_traced_frame"
    ],
    [
        "LOAD_FAST_BORROW",
        "frame"
    ],
    [
        "CALL",
        "self._is_traced_frame(frame)"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.depth"
    ],
    [
        "COMPARE_OP",
        "self.depth == 1"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._is_internal_frame"
    ],
    [
        "LOAD_FAST_BORROW",
        "frame"
    ],
    [
        "CALL",
        "self._is_internal_frame(frame)"
    ],
    [
        "LOAD_GLOBAL",
        "is_comprehension_frame"
    ],
    [
        "LOAD_FAST_BORROW",
        "frame"
    ],
    [
        "CALL",
        "is_comprehension_frame(frame)"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "STORE_FAST",
        "candidate"
    ],
    [
        "STORE_FAST",
        "i"
    ],
    [
        "LOAD_GLOBAL",
        "is_comprehension_frame"
    ],
    [
        "LOAD_FAST_BORROW",
        "candidate"
    ],
    [
        "CALL",
        "is_comprehension_frame(candidate)"
    ],
    [
        "LOAD_FAST_BORROW",
        "candidate"
    ],
    [
        "LOAD_ATTR",
        "candidate.f_back"
    ],
    [
        "STORE_FAST",
        "candidate"
    ],
    [
        "LOAD_FAST_BORROW",
        "i"
    ],
    [
        "BINARY_OP",
        "i += 1"
    ],
    [
        "STORE_FAST",
        "i"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._is_traced_frame"
    ],
    [
        "LOAD_FAST_BORROW",
        "candidate"
    ],
    [
        "CALL",
        "self._is_traced_frame(candidate)"
    ],
    [
        "LOAD_FAST_BORROW",
        "candidate"
    ],
    [
        "LOAD_ATTR",
        "candidate.f_back"
    ],
    [
        "STORE_FAST",
        "candidate"
    ],
    [
        "LOAD_FAST_BORROW_LOAD_FAST_BORROW",
        "i"
    ],
    [
        "LOAD_ATTR",
        "self.depth"
    ],
    [
        "COMPARE_OP",
        "i >= self.depth"
    ],
    [
        "LOAD_FAST_BORROW",
        "candidate"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._is_internal_frame"
    ],
    [
        "LOAD_FAST_BORROW",
        "candidate"
    ],
    [
        "CALL",
        "self._is_internal_frame(candidate)"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.config"
    ],
    [
        "LOAD_ATTR",
        "self.config.thread_local"
    ],
    [
        "STORE_FAST",
        "thread_local"
    ],
    [
        "LOAD_FAST_BORROW",
        "thread_local"
    ],
    [
        "LOAD_ATTR",
        "thread_local.__dict__"
    ],
    [
        "LOAD_ATTR",
        "thread_local.__dict__.setdefault"
    ],
    [
        "CALL",
        "thread_local.__dict__.setdefault('depth', -1)"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.frame_infos"
    ],
    [
        "LOAD_FAST_BORROW",
        "frame"
    ],
    [
        "BINARY_OP",
        "self.frame_infos[frame]"
    ],
    [
        "STORE_FAST",
        "frame_info"
    ],
    [
        "LOAD_FAST_BORROW",
        "event"
    ],
    [
        "CONTAINS_OP",
        "event in ('call', 'enter')"
    ],
    [
        "LOAD_FAST_BORROW",
        "thread_local"
    ],
    [
        "LOAD_ATTR",
        "thread_local.depth"
    ],
    [
        "BINARY_OP",
        "thread_local.depth += 1"
    ],
    [
        "STORE_ATTR",
        "thread_local.depth"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.config"
    ],
    [
        "LOAD_ATTR",
        "self.config.last_frame"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.config"
    ],
    [
        "LOAD_ATTR",
        "self.config.last_frame"
    ],
    [
        "LOAD_FAST_BORROW",
        "frame"
    ],
    [
        "IS_OP",
        "self.config.last_frame is not frame"
    ],
    [
        "LOAD_FAST_BORROW",
        "frame_info"
    ],
    [
        "LOAD_ATTR",
        "frame_info.last_line_no"
    ],
    [
        "STORE_FAST",
        "line_no"
    ],
    [
        "LOAD_GLOBAL",
        "Event"
    ],
    [
        "LOAD_FAST_BORROW_LOAD_FAST_BORROW",
        "frame_info"
    ],
    [
        "LOAD_FAST_BORROW_LOAD_FAST_BORROW",
        "arg"
    ],
    [
        "LOAD_ATTR",
        "thread_local.depth"
    ],
    [
        "LOAD_FAST_BORROW",
        "line_no"
    ],
    [
        "CALL_KW",
        "Event(frame_info, event, arg, thread_local.depth, line_no=line_no)"
    ],
    [
        "STORE_FAST",
        "trace_event"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.config"
    ],
    [
        "LOAD_ATTR",
        "self.config.formatter"
    ],
    [
        "LOAD_ATTR",
        "self.config.formatter.format_line_only"
    ],
    [
        "LOAD_FAST_BORROW",
        "trace_event"
    ],
    [
        "CALL",
        "self.config.formatter.format_line_only(trace_event)"
    ],
    [
        "STORE_FAST",
        "line"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.config"
    ],
    [
        "LOAD_ATTR",
        "self.config.write"
    ],
    [
        "LOAD_FAST_BORROW",
        "line"
    ],
    [
        "CALL",
        "self.config.write(line)"
    ],
    [
        "LOAD_FAST_BORROW",
        "event"
    ],
    [
        "COMPARE_OP",
        "event == 'exception'"
    ],
    [
        "LOAD_FAST_BORROW",
        "frame_info"
    ],
    [
        "STORE_ATTR",
        "frame_info.had_exception"
    ],
    [
        "LOAD_FAST_BORROW_LOAD_FAST_BORROW",
        "frame"
    ],
    [
        "LOAD_ATTR",
        "self.config"
    ],
    [
        "STORE_ATTR",
        "self.config.last_frame"
    ],
    [
        "LOAD_GLOBAL",
        "Event"
    ],
    [
        "LOAD_FAST_BORROW_LOAD_FAST_BORROW",
        "frame_info"
    ],
    [
        "LOAD_FAST_BORROW_LOAD_FAST_BORROW",
        "arg"
    ],
    [
        "LOAD_ATTR",
        "thread_local.depth"
    ],
    [
        "CALL",
        "Event(frame_info, event, arg, thread_local.depth)"
    ],
    [
        "STORE_FAST",
        "trace_event"
    ],
    [
        "LOAD_FAST_BORROW",
        "frame"
    ],
    [
        "LOAD_ATTR",
        "frame.f_code"
    ],
    [
        "LOAD_ATTR",
        "frame.f_code.co_name"
    ],
    [
        "COMPARE_OP",
        "frame.f_code.co_name == '<genexpr>'"
    ],
    [
        "LOAD_FAST_BORROW",
        "event"
    ],
    [
        "CONTAINS_OP",
        "event not in ('return', 'exception')"
    ],
    [
        "LOAD_FAST_BORROW",
        "frame_info"
    ],
    [
        "LOAD_ATTR",
        "frame_info.update_variables"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.watch"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.config"
    ],
    [
        "LOAD_ATTR",
        "self.config.watch_extras"
    ],
    [
        "LOAD_FAST_BORROW",
        "event"
    ],
    [
        "CALL",
        "frame_info.update_variables(\n                self.watch,\n                self.config.watch_extras,\n                event,\n            )"
    ],
    [
        "LOAD_FAST_BORROW",
        "trace_event"
    ],
    [
        "STORE_ATTR",
        "trace_event.variables"
    ],
    [
        "LOAD_FAST_BORROW",
        "event"
    ],
    [
        "CONTAINS_OP",
        "event in ('return', 'exit')"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.frame_infos"
    ],
    [
        "LOAD_FAST_BORROW",
        "frame"
    ],
    [
        "DELETE_SUBSCR",
        "self.frame_infos[frame]"
    ],
    [
        "LOAD_FAST_BORROW",
        "thread_local"
    ],
    [
        "LOAD_ATTR",
        "thread_local.depth"
    ],
    [
        "BINARY_OP",
        "thread_local.depth -= 1"
    ],
    [
        "STORE_ATTR",
        "thread_local.depth"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.config"
    ],
    [
        "LOAD_ATTR",
        "self.config.formatter"
    ],
    [
        "LOAD_ATTR",
        "self.config.formatter.format"
    ],
    [
        "LOAD_FAST_BORROW",
        "trace_event"
    ],
    [
        "CALL",
        "self.config.formatter.format(trace_event)"
    ],
    [
        "STORE_FAST",
        "formatted"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.config"
    ],
    [
        "LOAD_ATTR",
        "self.config.write"
    ],
    [
        "LOAD_FAST_BORROW",
        "formatted"
    ],
    [
        "CALL",
        "self.config.write(formatted)"
    ],
    [
        "LOAD_FAST_BORROW",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.trace"
    ],
    [
        "STORE_NAME",
        "    def __init__(self, config):\n        self.config = config"
    ],
    [
        "STORE_NAME",
        "    def __call__(self, *args, **kwargs):\n        if NO_ASTTOKENS:\n            raise Exception(\"birdseye doesn't support this version of Python\")\n\n        try:\n            import birdseye\n        except ImportError:\n            raise Exception(\"You must install birdseye separately to use spy: pip install birdseye\")\n\n        # Decorator without parentheses\n        if no_args_decorator(args, kwargs):\n            return self._trace(args[0])\n\n        # Decorator with parentheses and perhaps arguments\n        def decorator(func):\n            return self._trace(func, *args, **kwargs)\n\n        return decorator"
    ],
    [
        "STORE_NAME",
        "    def _trace(self, func, *args, **kwargs):\n        # noinspection PyUnresolvedReferences\n        from birdseye import eye\n\n        traced = eye(func)\n        traced = self.config.snoop(*args, **kwargs)(traced)\n\n        @functools.wraps(func)\n        def wrapper(*func_args, **func_kwargs):\n            if self.config.enabled:\n                final_func = traced\n            else:\n                final_func = func\n\n            return final_func(*func_args, **func_kwargs)\n\n        return wrapper"
    ],
    [
        "STORE_NAME",
        "    def _trace(self, func, *args, **kwargs):\n        # noinspection PyUnresolvedReferences\n        from birdseye import eye\n\n        traced = eye(func)\n        traced = self.config.snoop(*args, **kwargs)(traced)\n\n        @functools.wraps(func)\n        def wrapper(*func_args, **func_kwargs):\n            if self.config.enabled:\n                final_func = traced\n            else:\n                final_func = func\n\n            return final_func(*func_args, **func_kwargs)\n\n        return wrapper"
    ],
    [
        "LOAD_FAST_BORROW",
        "    def _trace(self, func, *args, **kwargs):\n        # noinspection PyUnresolvedReferences\n        from birdseye import eye\n\n        traced = eye(func)\n        traced = self.config.snoop(*args, **kwargs)(traced)\n\n        @functools.wraps(func)\n        def wrapper(*func_args, **func_kwargs):\n            if self.config.enabled:\n                final_func = traced\n            else:\n                final_func = func\n\n            return final_func(*func_args, **func_kwargs)\n\n        return wrapper"
    ],
    [
        "STORE_NAME",
        "    def _trace(self, func, *args, **kwargs):\n        # noinspection PyUnresolvedReferences\n        from birdseye import eye\n\n        traced = eye(func)\n        traced = self.config.snoop(*args, **kwargs)(traced)\n\n        @functools.wraps(func)\n        def wrapper(*func_args, **func_kwargs):\n            if self.config.enabled:\n                final_func = traced\n            else:\n                final_func = func\n\n            return final_func(*func_args, **func_kwargs)\n\n        return wrapper"
    ],
    [
        "LOAD_FAST_BORROW_LOAD_FAST_BORROW",
        "config"
    ],
    [
        "STORE_ATTR",
        "self.config"
    ],
    [
        "LOAD_GLOBAL",
        "NO_ASTTOKENS"
    ],
    [
        "LOAD_GLOBAL",
        "Exception"
    ],
    [
        "CALL",
        "Exception(\"birdseye doesn't support this version of Python\")"
    ],
    [
        "STORE_FAST",
        "import birdseye"
    ],
    [
        "LOAD_GLOBAL",
        "no_args_decorator"
    ],
    [
        "LOAD_DEREF",
        "args"
    ],
    [
        "LOAD_DEREF",
        "kwargs"
    ],
    [
        "CALL",
        "no_args_decorator(args, kwargs)"
    ],
    [
        "LOAD_DEREF",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._trace"
    ],
    [
        "LOAD_DEREF",
        "args"
    ],
    [
        "BINARY_OP",
        "args[0]"
    ],
    [
        "CALL",
        "self._trace(args[0])"
    ],
    [
        "LOAD_FAST",
        "        def decorator(func):\n            return self._trace(func, *args, **kwargs)"
    ],
    [
        "LOAD_FAST",
        "        def decorator(func):\n            return self._trace(func, *args, **kwargs)"
    ],
    [
        "LOAD_FAST",
        "        def decorator(func):\n            return self._trace(func, *args, **kwargs)"
    ],
    [
        "STORE_FAST",
        "        def decorator(func):\n            return self._trace(func, *args, **kwargs)"
    ],
    [
        "LOAD_FAST",
        "decorator"
    ],
    [
        "LOAD_GLOBAL",
        "ImportError"
    ],
    [
        "LOAD_GLOBAL",
        "Exception"
    ],
    [
        "CALL",
        "Exception(\"You must install birdseye separately to use spy: pip install birdseye\")"
    ],
    [
        "LOAD_DEREF",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._trace"
    ],
    [
        "LOAD_FAST_BORROW",
        "func"
    ],
    [
        "LOAD_DEREF",
        "args"
    ],
    [
        "LOAD_DEREF",
        "kwargs"
    ],
    [
        "CALL_FUNCTION_EX",
        "self._trace(func, *args, **kwargs)"
    ],
    [
        "STORE_FAST",
        "from birdseye import eye"
    ],
    [
        "LOAD_FAST_BORROW",
        "eye"
    ],
    [
        "LOAD_DEREF",
        "func"
    ],
    [
        "CALL",
        "eye(func)"
    ],
    [
        "STORE_DEREF",
        "traced"
    ],
    [
        "LOAD_DEREF",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.config"
    ],
    [
        "LOAD_ATTR",
        "self.config.snoop"
    ],
    [
        "LOAD_FAST_BORROW",
        "args"
    ],
    [
        "LOAD_FAST_BORROW",
        "kwargs"
    ],
    [
        "CALL_FUNCTION_EX",
        "self.config.snoop(*args, **kwargs)"
    ],
    [
        "LOAD_DEREF",
        "traced"
    ],
    [
        "CALL",
        "self.config.snoop(*args, **kwargs)(traced)"
    ],
    [
        "STORE_DEREF",
        "traced"
    ],
    [
        "LOAD_GLOBAL",
        "functools"
    ],
    [
        "LOAD_ATTR",
        "functools.wraps"
    ],
    [
        "LOAD_DEREF",
        "func"
    ],
    [
        "CALL",
        "functools.wraps(func)"
    ],
    [
        "LOAD_FAST_BORROW",
        "        @functools.wraps(func)\n        def wrapper(*func_args, **func_kwargs):\n            if self.config.enabled:\n                final_func = traced\n            else:\n                final_func = func\n\n            return final_func(*func_args, **func_kwargs)"
    ],
    [
        "LOAD_FAST_BORROW",
        "        @functools.wraps(func)\n        def wrapper(*func_args, **func_kwargs):\n            if self.config.enabled:\n                final_func = traced\n            else:\n                final_func = func\n\n            return final_func(*func_args, **func_kwargs)"
    ],
    [
        "LOAD_FAST_BORROW",
        "        @functools.wraps(func)\n        def wrapper(*func_args, **func_kwargs):\n            if self.config.enabled:\n                final_func = traced\n            else:\n                final_func = func\n\n            return final_func(*func_args, **func_kwargs)"
    ],
    [
        "CALL",
        "functools.wraps(func)"
    ],
    [
        "STORE_FAST",
        "        @functools.wraps(func)\n        def wrapper(*func_args, **func_kwargs):\n            if self.config.enabled:\n                final_func = traced\n            else:\n                final_func = func\n\n            return final_func(*func_args, **func_kwargs)"
    ],
    [
        "LOAD_FAST_BORROW",
        "wrapper"
    ],
    [
        "LOAD_DEREF",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.config"
    ],
    [
        "LOAD_ATTR",
        "self.config.enabled"
    ],
    [
        "LOAD_DEREF",
        "traced"
    ],
    [
        "STORE_FAST",
        "final_func"
    ],
    [
        "LOAD_DEREF",
        "func"
    ],
    [
        "STORE_FAST",
        "final_func"
    ],
    [
        "LOAD_FAST_BORROW",
        "final_func"
    ],
    [
        "LOAD_FAST_BORROW",
        "func_args"
    ],
    [
        "LOAD_FAST_BORROW",
        "func_kwargs"
    ],
    [
        "CALL_FUNCTION_EX",
        "final_func(*func_args, **func_kwargs)"
    ]
]