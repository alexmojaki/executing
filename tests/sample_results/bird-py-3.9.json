[
    [
        "STORE_NAME",
        "from __future__ import absolute_import, division, print_function"
    ],
    [
        "STORE_NAME",
        "from __future__ import absolute_import, division, print_function"
    ],
    [
        "STORE_NAME",
        "from __future__ import absolute_import, division, print_function"
    ],
    [
        "STORE_NAME",
        "from future import standard_library"
    ],
    [
        "LOAD_NAME",
        "standard_library"
    ],
    [
        "LOAD_METHOD",
        "standard_library.install_aliases"
    ],
    [
        "CALL_METHOD",
        "standard_library.install_aliases()"
    ],
    [
        "STORE_NAME",
        "from future.utils import iteritems"
    ],
    [
        "STORE_NAME",
        "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Iterable, Union, cast"
    ],
    [
        "STORE_NAME",
        "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Iterable, Union, cast"
    ],
    [
        "STORE_NAME",
        "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Iterable, Union, cast"
    ],
    [
        "STORE_NAME",
        "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Iterable, Union, cast"
    ],
    [
        "STORE_NAME",
        "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Iterable, Union, cast"
    ],
    [
        "STORE_NAME",
        "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Iterable, Union, cast"
    ],
    [
        "STORE_NAME",
        "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Iterable, Union, cast"
    ],
    [
        "STORE_NAME",
        "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Iterable, Union, cast"
    ],
    [
        "STORE_NAME",
        "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Iterable, Union, cast"
    ],
    [
        "STORE_NAME",
        "from typing import List, Dict, Any, Optional, NamedTuple, Tuple, Iterator, Iterable, Union, cast"
    ],
    [
        "STORE_NAME",
        "from types import FrameType, TracebackType, CodeType, FunctionType, ModuleType"
    ],
    [
        "STORE_NAME",
        "from types import FrameType, TracebackType, CodeType, FunctionType, ModuleType"
    ],
    [
        "STORE_NAME",
        "from types import FrameType, TracebackType, CodeType, FunctionType, ModuleType"
    ],
    [
        "STORE_NAME",
        "from types import FrameType, TracebackType, CodeType, FunctionType, ModuleType"
    ],
    [
        "STORE_NAME",
        "from types import FrameType, TracebackType, CodeType, FunctionType, ModuleType"
    ],
    [
        "STORE_NAME",
        "import typing"
    ],
    [
        "STORE_NAME",
        "import ast"
    ],
    [
        "STORE_NAME",
        "import html"
    ],
    [
        "STORE_NAME",
        "import inspect"
    ],
    [
        "STORE_NAME",
        "import json"
    ],
    [
        "STORE_NAME",
        "import os"
    ],
    [
        "STORE_NAME",
        "import traceback"
    ],
    [
        "STORE_NAME",
        "from collections import defaultdict, Sequence, Set, Mapping, deque, namedtuple, Counter"
    ],
    [
        "STORE_NAME",
        "from collections import defaultdict, Sequence, Set, Mapping, deque, namedtuple, Counter"
    ],
    [
        "STORE_NAME",
        "from collections import defaultdict, Sequence, Set, Mapping, deque, namedtuple, Counter"
    ],
    [
        "STORE_NAME",
        "from collections import defaultdict, Sequence, Set, Mapping, deque, namedtuple, Counter"
    ],
    [
        "STORE_NAME",
        "from collections import defaultdict, Sequence, Set, Mapping, deque, namedtuple, Counter"
    ],
    [
        "STORE_NAME",
        "from collections import defaultdict, Sequence, Set, Mapping, deque, namedtuple, Counter"
    ],
    [
        "STORE_NAME",
        "from collections import defaultdict, Sequence, Set, Mapping, deque, namedtuple, Counter"
    ],
    [
        "STORE_NAME",
        "from functools import partial"
    ],
    [
        "STORE_NAME",
        "from itertools import chain, islice"
    ],
    [
        "STORE_NAME",
        "from itertools import chain, islice"
    ],
    [
        "STORE_NAME",
        "from threading import Lock"
    ],
    [
        "STORE_NAME",
        "from uuid import uuid4"
    ],
    [
        "STORE_NAME",
        "import hashlib"
    ],
    [
        "STORE_NAME",
        "import sys"
    ],
    [
        "STORE_NAME",
        "from asttokens import ASTTokens"
    ],
    [
        "STORE_NAME",
        "from littleutils import group_by_key_func, only"
    ],
    [
        "STORE_NAME",
        "from littleutils import group_by_key_func, only"
    ],
    [
        "STORE_NAME",
        "from outdated import warn_if_outdated"
    ],
    [
        "STORE_NAME",
        "from cached_property import cached_property"
    ],
    [
        "STORE_NAME",
        "from cheap_repr import cheap_repr, try_register_repr"
    ],
    [
        "STORE_NAME",
        "from cheap_repr import cheap_repr, try_register_repr"
    ],
    [
        "STORE_NAME",
        "from cheap_repr.utils import safe_qualname, exception_string"
    ],
    [
        "STORE_NAME",
        "from cheap_repr.utils import safe_qualname, exception_string"
    ],
    [
        "STORE_NAME",
        "from birdseye.db import Database, retry_db"
    ],
    [
        "STORE_NAME",
        "from birdseye.db import Database, retry_db"
    ],
    [
        "STORE_NAME",
        "from birdseye.tracer import TreeTracerBase, TracedFile, EnterCallInfo, ExitCallInfo, FrameInfo, ChangeValue, Loop"
    ],
    [
        "STORE_NAME",
        "from birdseye.tracer import TreeTracerBase, TracedFile, EnterCallInfo, ExitCallInfo, FrameInfo, ChangeValue, Loop"
    ],
    [
        "STORE_NAME",
        "from birdseye.tracer import TreeTracerBase, TracedFile, EnterCallInfo, ExitCallInfo, FrameInfo, ChangeValue, Loop"
    ],
    [
        "STORE_NAME",
        "from birdseye.tracer import TreeTracerBase, TracedFile, EnterCallInfo, ExitCallInfo, FrameInfo, ChangeValue, Loop"
    ],
    [
        "STORE_NAME",
        "from birdseye.tracer import TreeTracerBase, TracedFile, EnterCallInfo, ExitCallInfo, FrameInfo, ChangeValue, Loop"
    ],
    [
        "STORE_NAME",
        "from birdseye.tracer import TreeTracerBase, TracedFile, EnterCallInfo, ExitCallInfo, FrameInfo, ChangeValue, Loop"
    ],
    [
        "STORE_NAME",
        "from birdseye.tracer import TreeTracerBase, TracedFile, EnterCallInfo, ExitCallInfo, FrameInfo, ChangeValue, Loop"
    ],
    [
        "STORE_NAME",
        "from birdseye import tracer"
    ],
    [
        "STORE_NAME",
        "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
    ],
    [
        "STORE_NAME",
        "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
    ],
    [
        "STORE_NAME",
        "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
    ],
    [
        "STORE_NAME",
        "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
    ],
    [
        "STORE_NAME",
        "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
    ],
    [
        "STORE_NAME",
        "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
    ],
    [
        "STORE_NAME",
        "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
    ],
    [
        "STORE_NAME",
        "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
    ],
    [
        "STORE_NAME",
        "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
    ],
    [
        "STORE_NAME",
        "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
    ],
    [
        "STORE_NAME",
        "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
    ],
    [
        "STORE_NAME",
        "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
    ],
    [
        "STORE_NAME",
        "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
    ],
    [
        "STORE_NAME",
        "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
    ],
    [
        "STORE_NAME",
        "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
    ],
    [
        "STORE_NAME",
        "from birdseye.utils import correct_type, PY3, PY2, one_or_none, \\\n    of_type, Deque, Text, flatten_list, lru_cache, ProtocolEncoder, IPYTHON_FILE_PATH, source_without_decorators, \\\n    is_future_import, get_unfrozen_datetime, FILE_SENTINEL_NAME, read_source_file"
    ],
    [
        "STORE_NAME",
        "from birdseye import __version__"
    ],
    [
        "STORE_NAME",
        "from numpy import ndarray"
    ],
    [
        "LOAD_NAME",
        "ImportError"
    ],
    [
        "LOAD_NAME",
        "object"
    ],
    [
        "CALL_FUNCTION",
        "    class ndarray(object):\n        pass"
    ],
    [
        "STORE_NAME",
        "    class ndarray(object):\n        pass"
    ],
    [
        "STORE_NAME",
        "from pandas import DataFrame, Series"
    ],
    [
        "STORE_NAME",
        "from pandas import DataFrame, Series"
    ],
    [
        "LOAD_NAME",
        "ImportError"
    ],
    [
        "LOAD_NAME",
        "object"
    ],
    [
        "CALL_FUNCTION",
        "    class DataFrame(object):\n        pass"
    ],
    [
        "STORE_NAME",
        "    class DataFrame(object):\n        pass"
    ],
    [
        "LOAD_NAME",
        "object"
    ],
    [
        "CALL_FUNCTION",
        "    class Series(object):\n        pass"
    ],
    [
        "STORE_NAME",
        "    class Series(object):\n        pass"
    ],
    [
        "STORE_NAME",
        "from django.db.models import QuerySet"
    ],
    [
        "LOAD_NAME",
        "ImportError"
    ],
    [
        "LOAD_NAME",
        "object"
    ],
    [
        "CALL_FUNCTION",
        "    class QuerySet(object):\n        pass"
    ],
    [
        "STORE_NAME",
        "    class QuerySet(object):\n        pass"
    ],
    [
        "LOAD_NAME",
        "warn_if_outdated"
    ],
    [
        "LOAD_NAME",
        "__version__"
    ],
    [
        "CALL_FUNCTION",
        "warn_if_outdated('birdseye', __version__)"
    ],
    [
        "LOAD_NAME",
        "namedtuple"
    ],
    [
        "CALL_FUNCTION",
        "namedtuple('CodeInfo', 'db_func traced_file arg_names')"
    ],
    [
        "STORE_NAME",
        "CodeInfo"
    ],
    [
        "LOAD_NAME",
        "TreeTracerBase"
    ],
    [
        "CALL_FUNCTION",
        "class BirdsEye(TreeTracerBase):\n    \"\"\"\n    Decorate functions with an instance of this class to debug them,\n    or just use the existing instance `eye`.\n    \"\"\"\n\n    def __init__(self, db_uri=None, num_samples=None):\n        \"\"\"\n        Set db_uri to specify where the database lives, as an alternative to\n        the environment variable BIRDSEYE_DB.\n        \"\"\"\n        super(BirdsEye, self).__init__()\n        self._db_uri = db_uri\n        self._code_infos = {}  # type: Dict[CodeType, CodeInfo]\n        self._last_call_id = None\n        self._ipython_cell_value = None\n        self.num_samples = num_samples or dict(\n            big=dict(\n                attributes=50,\n                dict=50,\n                list=30,\n                set=30,\n                pandas_rows=20,\n                pandas_cols=100,\n            ),\n            small=dict(\n                attributes=50,\n                dict=10,\n                list=6,\n                set=6,\n                pandas_rows=6,\n                pandas_cols=10,\n            ),\n        )\n\n    @cached_property\n    def db(self):\n        return Database(self._db_uri)\n\n    def parse_extra(self, root, source, filename):\n        # type: (ast.Module, str, str) -> None\n        for node in ast.walk(root):  # type: ast.AST\n            node._loops = tracer.loops(node)\n            if isinstance(node, ast.expr):\n                node._is_interesting_expression = is_interesting_expression(node)\n\n    @lru_cache()\n    def compile(self, source, filename, flags=0):\n        traced_file = super(BirdsEye, self).compile(source, filename, flags)\n        traced_file.tokens = ASTTokens(source, tree=traced_file.root)\n        return traced_file\n\n    def before_stmt(self, node, frame):\n        # type: (ast.stmt, FrameType) -> None\n        if frame.f_code not in self._code_infos:\n            return\n        if isinstance(node.parent, ast.For) and node is node.parent.body[0]:\n            self._add_iteration(node._loops, frame)\n\n    def before_expr(self, node, frame):\n        if isinstance(node.parent, ast.While) and node is node.parent.test:\n            self._add_iteration(node._loops, frame)\n\n    def _add_iteration(self, loops, frame):\n        # type: (typing.Sequence[Loop], FrameType) -> None\n        \"\"\"\n        Given one or more nested loops, add an iteration for the innermost\n        loop (the last in the sequence).\n        \"\"\"\n        iteration = self.stack[frame].iteration  # type: Iteration\n        for i, loop_node in enumerate(loops):\n            loop = iteration.loops[loop_node._tree_index]\n            if i == len(loops) - 1:\n                loop.append(Iteration())\n            else:\n                iteration = loop.last()\n\n    def after_expr(self, node, frame, value, exc_value, exc_tb):\n        # type: (ast.expr, FrameType, Any, Optional[BaseException], Optional[TracebackType]) -> Optional[ChangeValue]\n\n        if _tracing_recursively(frame):\n            return None\n\n        if frame.f_code not in self._code_infos:\n            return None\n\n        if node._is_interesting_expression:\n            # If this is an expression statement and the last statement\n            # in the body, the value is returned from the cell magic\n            # to be displayed as usual\n            if (self._code_infos[frame.f_code].traced_file.is_ipython_cell\n                    and isinstance(node.parent, ast.Expr)\n                    and node.parent is node.parent.parent.body[-1]):\n                self._ipython_cell_value = value\n\n            if is_obvious_builtin(node, self.stack[frame].expression_values[node]):\n                return None\n\n            frame_info = self.stack[frame]\n            if exc_value:\n                node_value = self._exception_value(node, frame, exc_value)\n            else:\n                node_value = NodeValue.expression(\n                    self.num_samples,\n                    value,\n                    level=max(1, 3 - len(node._loops) * (not self._is_first_loop_iteration(node, frame))),\n                )\n                self._set_node_value(node, frame, node_value)\n            self._check_inner_call(frame_info, node, node_value)\n\n        # i.e. is `node` the `y` in `[f(x) for x in y]`, making `node.parent` the `for x in y`\n        is_special_comprehension_iter = (\n                isinstance(node.parent, ast.comprehension) and\n                node is node.parent.iter and\n\n                # Generators execute in their own time and aren't directly attached to the parent frame\n                not isinstance(node.parent.parent, ast.GeneratorExp))\n\n        if not is_special_comprehension_iter:\n            return None\n\n        # Mark `for x in y` as a bit that executed, so it doesn't show as grey\n        self._set_node_value(node.parent, frame, NodeValue.covered())\n\n        if exc_value:\n            return None\n\n        # Track each iteration over `y` so that the 'loop' can be stepped through\n        loops = node._loops + (node.parent,)  # type: Tuple[Loop, ...]\n\n        def comprehension_iter_proxy():\n            for item in value:\n                self._add_iteration(loops, frame)\n                yield item\n\n        # This effectively changes to code to `for x in comprehension_iter_proxy()`\n        return ChangeValue(comprehension_iter_proxy())\n\n    def _check_inner_call(self, frame_info, node, node_value):\n        # type: (FrameInfo, Union[ast.stmt, ast.expr], NodeValue) -> None\n        inner_calls = frame_info.inner_calls.pop(node, None)\n        if inner_calls:\n            node_value.set_meta('inner_calls', inner_calls)\n\n    def _is_first_loop_iteration(self, node, frame):\n        # type: (ast.AST, FrameType) -> bool\n        iteration = self.stack[frame].iteration  # type: Iteration\n        for loop_node in node._loops:  # type: ast.AST\n            loop = iteration.loops[loop_node._tree_index]\n            iteration = loop.last()\n            if iteration.index > 0:\n                return False\n        return True\n\n    def _set_node_value(self, node, frame, value):\n        # type: (ast.AST, FrameType, NodeValue) -> None\n        iteration = self.stack[frame].iteration  # type: Iteration\n        for loop_node in node._loops:  # type: ast.AST\n            loop = iteration.loops[loop_node._tree_index]\n            loop.recorded_node(node)\n            iteration = loop.last()\n        iteration.vals[node._tree_index] = value\n\n    def _exception_value(self, node, frame, exc_value):\n        # type: (Union[ast.expr, ast.stmt], FrameType, BaseException) -> NodeValue\n        value = NodeValue.exception(exc_value)\n        self._set_node_value(node, frame, value)\n        return value\n\n    def after_stmt(self, node, frame, exc_value, exc_traceback, exc_node):\n        # type: (ast.stmt, FrameType, Optional[BaseException], Optional[TracebackType], Optional[ast.AST]) -> Optional[bool]\n        if frame.f_code not in self._code_infos or _tracing_recursively(frame):\n            return None\n        if exc_value and node is exc_node:\n            value = self._exception_value(node, frame, exc_value)\n        else:\n            value = NodeValue.covered()\n            self._set_node_value(node, frame, value)\n        self._check_inner_call(self.stack[frame], node, value)\n        return None\n\n    def enter_call(self, enter_info):\n        # type: (EnterCallInfo) -> None\n        frame = enter_info.current_frame  # type: FrameType\n        if frame.f_code not in self._code_infos or _tracing_recursively(frame):\n            return\n        frame_info = self.stack[frame]\n        frame_info.start_time = get_unfrozen_datetime()\n        frame_info.iteration = Iteration()\n\n        code_info = self._code_infos[frame.f_code]\n        if isinstance(enter_info.enter_node.parent, ast.Module):\n            arguments = []\n        else:\n            f_locals = frame.f_locals.copy()  # type: Dict[str, Any]\n            arguments = [(name, f_locals.pop(name))\n                         for name in code_info.arg_names\n                         if name] + [\n\n                            # Local variables other than actual arguments. These are variables from\n                            # the enclosing scope. It's handy to treat them like arguments in the UI\n                            it for it in f_locals.items()\n                            if it[0][0] != '.'  # Appears when using nested tuple arguments\n                        ]\n        frame_info.arguments = json.dumps([[k, cheap_repr(v)] for k, v in arguments])\n        frame_info.call_id = self._call_id()\n        frame_info.inner_calls = defaultdict(list)\n        prev = self.stack.get(enter_info.caller_frame)\n        if prev:\n            inner_calls = getattr(prev, 'inner_calls', None)\n            if inner_calls is not None:\n                inner_calls[enter_info.call_node].append(frame_info.call_id)\n\n    def _call_id(self):\n        # type: () -> Text\n        return uuid4().hex\n\n    def exit_call(self, exit_info):\n        # type: (ExitCallInfo) -> None\n        \"\"\"\n        This is where all the data collected during the call is gathered up\n        and sent to the database.\n        \"\"\"\n        frame = exit_info.current_frame  # type: FrameType\n        if frame.f_code not in self._code_infos or _tracing_recursively(frame):\n            return\n        frame_info = self.stack[frame]\n\n        top_iteration = frame_info.iteration  # type: Iteration\n        node_values = _deep_dict()\n        self._extract_node_values(top_iteration, (), node_values)\n\n        db_func = self._code_infos[frame.f_code].db_func\n        exc = exit_info.exc_value  # type: Optional[Exception]\n        if exc:\n            traceback_str = ''.join(traceback.format_exception(type(exc), exc, exit_info.exc_tb))\n            exception = exception_string(exc)\n        else:\n            traceback_str = exception = None\n\n        @retry_db\n        def add_call():\n            Call = self.db.Call\n            call = Call(id=frame_info.call_id,\n                        function_id=db_func,\n                        arguments=frame_info.arguments,\n                        return_value=cheap_repr(exit_info.return_value),\n                        exception=exception,\n                        traceback=traceback_str,\n                        data=json.dumps(\n                            dict(\n                                node_values=node_values,\n                                loop_iterations=top_iteration.extract_iterations()['loops'],\n                                type_names=type_registry.names(),\n                                num_special_types=type_registry.num_special_types,\n                            ),\n                            cls=ProtocolEncoder,\n                            separators=(',', ':')\n                        ),\n                        start_time=frame_info.start_time)\n            with self.db.session_scope() as session:\n                session.add(call)\n\n        add_call()\n\n        self._last_call_id = frame_info.call_id\n\n    def _extract_node_values(self, iteration, path, node_values):\n        # type: (Iteration, Tuple[int, ...], dict) -> None\n        \"\"\"\n        Populates node_values with values inside iteration.\n        \"\"\"\n        # Each element of `path` is an index of a loop iteration\n        # e.g. given the nested loops:\n        #\n        # for i in [0, 1, 2]:\n        #     for j in [0, 1, 2, 3]:\n        #\n        # path may be (i, j) for each of the iterations\n        for tree_index, node_value in iteration.vals.items():\n\n            # So this `full_path` is a tuple of ints, but the first\n            # int has a different meaning from the others\n            full_path = (tree_index,) + path\n\n            # Given a path (a, b, c) we're making node_values 'contain'\n            # this structure:\n            # {a: {b: {c: node_value}}}\n            d = node_values\n            for path_k in full_path[:-1]:\n                d = d[path_k]\n            d[full_path[-1]] = node_value\n\n        for loop in iteration.loops.values():\n            for i, iteration in enumerate(loop):\n                self._extract_node_values(iteration, path + (i,), node_values)\n\n    def trace_function(self, func):\n        # type: (FunctionType) -> FunctionType\n        new_func = super(BirdsEye, self).trace_function(func)\n        code_info = self._code_infos.get(new_func.__code__)\n        if code_info:\n            return new_func\n\n        lines, start_lineno = inspect.getsourcelines(func)  # type: List[Text], int\n        end_lineno = start_lineno + len(lines)\n        name = safe_qualname(func)\n        source_file = inspect.getsourcefile(func)\n        if source_file.startswith('<ipython-input'):\n            filename = IPYTHON_FILE_PATH\n        else:\n            filename = os.path.abspath(source_file)\n        traced_file = new_func.traced_file\n\n        arg_info = inspect.getargs(new_func.__code__)\n        arg_names = list(chain(flatten_list(arg_info[0]), arg_info[1:]))  # type: List[str]\n        self._trace(name, filename, traced_file, new_func.__code__, typ='function',\n                    start_lineno=start_lineno, end_lineno=end_lineno,\n                    arg_names=arg_names)\n\n        return new_func\n\n    def exec_ipython_cell(self, source, callback):\n        from IPython import get_ipython\n        shell = get_ipython()\n        filename = name = shell.compile.cache(source)\n        flags = shell.compile.flags\n\n        traced_file = self.compile(source, filename, flags)\n        traced_file.is_ipython_cell = True\n\n        for node in traced_file.root.body:\n            if is_future_import(node):\n                raise ValueError('from __future__ import ... statements '\n                                 'are not allowed in cells traced with %%eye')\n\n        shell.user_global_ns.update(self._trace_methods_dict(traced_file))\n\n        self._trace(name, filename, traced_file, traced_file.code, 'module', source)\n\n        try:\n            shell.ex(traced_file.code)\n            return self._ipython_cell_value\n        finally:\n            callback(self._last_call_id)\n            self._ipython_cell_value = None\n\n    def trace_this_module(self, context=0, deep=False):\n        frame = inspect.currentframe()\n\n        filename = None\n        while context >= 0:\n            frame = frame.f_back\n            filename = inspect.getsourcefile(frame)\n            if filename is not None:\n                context -= 1\n        filename = os.path.abspath(filename)\n\n        if frame.f_globals.get('__name__') != '__main__':\n            if PY3 and self._treetrace_hidden_with_stmt.__name__ not in frame.f_globals:\n                raise RuntimeError(\n                    'To trace an imported module, you must import birdseye before '\n                    'importing that module.')\n            return\n\n        lines = read_source_file(filename).splitlines()\n        lines[:frame.f_lineno] = [''] * frame.f_lineno\n        source = '\\n'.join(lines)\n        self.exec_string(source, filename, frame.f_globals, frame.f_locals, deep)\n        sys.exit(0)\n\n    def exec_string(self, source, filename, globs=None, locs=None, deep=False):\n        globs = globs or {}\n        locs = locs or {}\n\n        traced_file = self.compile(source, filename)\n\n        globs.update(self._trace_methods_dict(traced_file))\n\n        self._trace(FILE_SENTINEL_NAME, filename, traced_file, traced_file.code, 'module', source)\n\n        if deep:\n            nodes_by_lineno = {\n                node.lineno: node\n                for node in traced_file.nodes\n                if isinstance(node, ast.FunctionDef)\n            }\n\n            def find_code(root_code):\n                # type: (CodeType) -> None\n                for code in root_code.co_consts:  # type: CodeType\n                    if not inspect.iscode(code) or code.co_name.startswith('<'):\n                        continue\n\n                    find_code(code)\n\n                    lineno = code.co_firstlineno\n                    node = nodes_by_lineno.get(lineno)\n                    if not node:\n                        continue\n\n                    self._trace(\n                        code.co_name, filename, traced_file, code,\n                        typ='function',\n                        source=source,\n                        start_lineno=lineno,\n                        end_lineno=node.last_token.end[0] + 1,\n                    )\n\n            find_code(traced_file.code)\n\n        exec(traced_file.code, globs, locs)\n\n    def _trace(\n            self,\n            name,\n            filename,\n            traced_file,\n            code,\n            typ,\n            source='',\n            start_lineno=1,\n            end_lineno=None,\n            arg_names=(),\n    ):\n        if not end_lineno:\n            end_lineno = start_lineno + len(source.splitlines())\n        nodes = list(self._nodes_of_interest(traced_file, start_lineno, end_lineno))\n        html_body = self._nodes_html(nodes, start_lineno, end_lineno, traced_file)\n\n        data_dict = dict(\n            # This maps each node to the loops enclosing that node\n            node_loops={\n                node._tree_index: [n._tree_index for n in node._loops]\n                for node, _ in nodes\n                if node._loops\n            },\n        )\n        if typ == 'function':\n            tokens = traced_file.tokens\n            func_node = only(node\n                             for node, _ in nodes\n                             if isinstance(node, ast.FunctionDef)\n                             and node.first_token.start[0] == start_lineno)\n            func_startpos, source = source_without_decorators(tokens, func_node)\n            # These are for the PyCharm plugin\n            data_dict.update(\n                node_ranges=list(self._node_ranges(nodes, tokens, func_startpos)),\n                loop_ranges=list(self._loop_ranges(nodes, tokens, func_startpos)),\n            )\n\n        data = json.dumps(data_dict, sort_keys=True)\n        db_func = self._db_func(data, filename, html_body, name, start_lineno, source, typ)\n        self._code_infos[code] = CodeInfo(db_func, traced_file, arg_names)\n\n    def _loop_ranges(self, nodes, tokens, func_start):\n        # For a for loop, e.g.\n        #\n        #     for x in y:\n        #\n        # this yields the range of the target 'x'.\n        #\n        # For a while loop, e.g.\n        #\n        #     while x < 10:\n        #\n        # this yields the range of the condition 'x < 10'.\n        for node, (classes, _, __) in nodes:\n            if 'loop' not in classes:\n                continue\n\n            try:\n                target = node.target  # for loop\n            except AttributeError:\n                target = node.test  # while loop\n\n            start, end = tokens.get_text_range(target)\n            start -= func_start\n            end -= func_start\n\n            yield dict(\n                tree_index=node._tree_index,\n                start=start,\n                end=end\n            )\n\n    def _node_ranges(self, nodes, tokens, func_start):\n        for node, (classes, _, __) in nodes:\n            start, end = tokens.get_text_range(node)\n            start -= func_start\n            end -= func_start\n\n            if start < 0:\n                assert (end < 0  # nodes before the def, i.e. decorators\n                        or isinstance(node, ast.FunctionDef))\n                continue\n\n            yield dict(\n                tree_index=node._tree_index,\n                start=start,\n                end=end,\n                depth=node._depth,\n                classes=classes,\n            )\n\n    @retry_db\n    def _db_func(self, data, filename, html_body, name, start_lineno, source, typ):\n        \"\"\"\n        Retrieve the Function object from the database if one exists, or create one.\n        \"\"\"\n\n        def h(s):\n            return hashlib.sha256(s.encode('utf8')).hexdigest()\n\n        function_hash = h(filename + name + html_body + data + str(start_lineno))\n\n        Function = self.db.Function\n\n        with self.db.session_scope() as session:\n            db_func = one_or_none(session.query(Function).filter_by(hash=function_hash))  # type: Optional[Function]\n            if not db_func:\n                db_func = Function(file=filename,\n                                   name=name,\n                                   type=typ,\n                                   html_body=html_body,\n                                   lineno=start_lineno,\n                                   data=data,\n                                   body_hash=h(source),\n                                   hash=function_hash)\n                session.add(db_func)\n                session.commit()  # ensure .id exists\n            assert isinstance(db_func.id, int)\n            return db_func.id\n\n    def _nodes_of_interest(self, traced_file, start_lineno, end_lineno):\n        # type: (TracedFile, int, int) -> Iterator[Tuple[ast.AST, Tuple]]\n        \"\"\"\n        Nodes that may have a value, show up as a box in the UI, and lie within the\n        given line range.\n        \"\"\"\n        for node in traced_file.nodes:\n            classes = []\n\n            if (isinstance(node, (ast.While, ast.For, ast.comprehension)) and\n                    not isinstance(node.parent, ast.GeneratorExp)):\n                classes.append('loop')\n            if isinstance(node, ast.stmt):\n                classes.append('stmt')\n\n            if isinstance(node, ast.expr):\n                if not node._is_interesting_expression:\n                    continue\n            elif not classes:\n                continue\n\n            assert isinstance(node, ast.AST)\n\n            # In particular FormattedValue is missing this\n            if not hasattr(node, 'first_token'):\n                continue\n\n            if not start_lineno <= node.first_token.start[0] <= end_lineno:\n                continue\n\n            start, end = traced_file.tokens.get_text_range(node)  # type: int, int\n            if start == end == 0:\n                continue\n\n            yield node, (classes, start, end)\n\n    def _nodes_html(self, nodes, start_lineno, end_lineno, traced_file):\n        # type: (list, int, int, TracedFile) -> str\n        \"\"\"\n        The algorithm for generating the HTML works as follows. We generate a list\n        of HTMLPositions, which are essentially places to insert HTML into the source plus some\n        metadata. The order of the fields of HTMLPosition ensure that when the list is sorted,\n        the resulting HTML is valid and correct. Specifically, the fields are:\n        \n          1. index: the index in the source string where the HTML would be inserted\n          2. is_start: Indicates if this piece of HTML is the start of a tag, rather than the end.\n             Ends should appear first, so that the resulting HTML looks like:\n                <span> ... </span><span> ... </span>\n             rather than:\n                <span> ... <span></span> ... </span>\n             (I think this might actually be unnecessary, since I can't think of any cases of two\n              expressions right next to each other with nothing in between)\n          3. depth: the depth of the corresponding node in the AST. We want the start of a tag from\n             a node to appear before the start of a tag nested within, e.g. `foo()` should become:\n                <span [for foo()]><span [for foo]>foo</span>()</span>\n             rather than:   \n                <span [for foo]><span [for foo()]>foo</span>()</span>\n          4. html: the actual HTML to insert. Not important for ordering.\n          \n        Mostly the list contains pairs of HTMLPositions corresponding to AST nodes, one for the\n        start and one for the end.\n        \n        After the list is sorted, the HTML generated is essentially:\n        \n        source[0:positions[0].index] + positions[0].html + source[positions[0].index:positions[1].index] + positions[1].html + ...\n        \"\"\"\n\n        traced_file.root._depth = 0\n        for node in ast.walk(traced_file.root):  # type: ast.AST\n            for child in ast.iter_child_nodes(node):\n                child._depth = node._depth + 1\n\n        positions = []  # type: List[HTMLPosition]\n\n        for node, (classes, start, end) in nodes:\n            # noinspection PyArgumentList\n            positions.extend(map(\n                HTMLPosition,\n                [start, end],\n                [True, False],  # is_start\n                [node._depth, node._depth],\n                ['<span data-index=\"%s\" class=\"%s\">' % (node._tree_index, ' '.join(classes)),\n                 '</span>']))\n\n        end_lineno = self._separate_comprehensions(\n            [n[0] for n in nodes],\n            end_lineno, positions, traced_file)\n\n        # This just makes the loop below simpler\n        positions.append(HTMLPosition(len(traced_file.source), False, 0, ''))\n\n        positions.sort()\n\n        html_parts = []\n        start = 0\n        for position in positions:\n            html_parts.append(html.escape(traced_file.source[start:position.index]))\n            html_parts.append(position.html)\n            start = position.index\n        html_body = ''.join(html_parts)\n        html_body = '\\n'.join(html_body.split('\\n')[start_lineno - 1:end_lineno - 1])\n\n        return html_body.strip('\\n')\n\n    def _separate_comprehensions(self, nodes, end_lineno, positions, traced_file):\n        # type: (list, int, List[HTMLPosition], TracedFile) -> int\n        \"\"\"\n        Comprehensions (e.g. list comprehensions) are troublesome because they can\n        be navigated like loops, and the buttons for these need to be on separate lines.\n        This function inserts newlines to turn:\n\n        [x + y for x in range(3) for y in range(5)] and\n        [[x + y for x in range(3)] for y in range(5)]\n\n        into\n\n        [x + y for x in range(3)\n         for y in range(5)] and\n        [[x + y for x in range(3)]\n         for y in range(5)]\n        \"\"\"\n\n        comprehensions = group_by_key_func(of_type((ast.comprehension, ast.While, ast.For), nodes),\n                                           lambda c: c.first_token.start[0]\n                                           )  # type: Dict[Any, Iterable[ast.comprehension]]\n\n        def get_start(n):\n            # type: (ast.AST) -> int\n            return traced_file.tokens.get_text_range(n)[0]\n\n        for comp_list in comprehensions.values():\n            prev_start = None  # type: Optional[int]\n            for comp in sorted(comp_list, key=lambda c: c.first_token.startpos):\n                if isinstance(comp, ast.comprehension) and comp is comp.parent.generators[0]:\n                    start = get_start(comp.parent)\n                    if prev_start is not None and start < prev_start:\n                        start = get_start(comp)\n                else:\n                    start = get_start(comp)\n                if prev_start is not None:\n                    positions.append(HTMLPosition(start, True, 0, '\\n '))\n                    end_lineno += 1\n                prev_start = start\n\n        return end_lineno"
    ],
    [
        "STORE_NAME",
        "class BirdsEye(TreeTracerBase):\n    \"\"\"\n    Decorate functions with an instance of this class to debug them,\n    or just use the existing instance `eye`.\n    \"\"\"\n\n    def __init__(self, db_uri=None, num_samples=None):\n        \"\"\"\n        Set db_uri to specify where the database lives, as an alternative to\n        the environment variable BIRDSEYE_DB.\n        \"\"\"\n        super(BirdsEye, self).__init__()\n        self._db_uri = db_uri\n        self._code_infos = {}  # type: Dict[CodeType, CodeInfo]\n        self._last_call_id = None\n        self._ipython_cell_value = None\n        self.num_samples = num_samples or dict(\n            big=dict(\n                attributes=50,\n                dict=50,\n                list=30,\n                set=30,\n                pandas_rows=20,\n                pandas_cols=100,\n            ),\n            small=dict(\n                attributes=50,\n                dict=10,\n                list=6,\n                set=6,\n                pandas_rows=6,\n                pandas_cols=10,\n            ),\n        )\n\n    @cached_property\n    def db(self):\n        return Database(self._db_uri)\n\n    def parse_extra(self, root, source, filename):\n        # type: (ast.Module, str, str) -> None\n        for node in ast.walk(root):  # type: ast.AST\n            node._loops = tracer.loops(node)\n            if isinstance(node, ast.expr):\n                node._is_interesting_expression = is_interesting_expression(node)\n\n    @lru_cache()\n    def compile(self, source, filename, flags=0):\n        traced_file = super(BirdsEye, self).compile(source, filename, flags)\n        traced_file.tokens = ASTTokens(source, tree=traced_file.root)\n        return traced_file\n\n    def before_stmt(self, node, frame):\n        # type: (ast.stmt, FrameType) -> None\n        if frame.f_code not in self._code_infos:\n            return\n        if isinstance(node.parent, ast.For) and node is node.parent.body[0]:\n            self._add_iteration(node._loops, frame)\n\n    def before_expr(self, node, frame):\n        if isinstance(node.parent, ast.While) and node is node.parent.test:\n            self._add_iteration(node._loops, frame)\n\n    def _add_iteration(self, loops, frame):\n        # type: (typing.Sequence[Loop], FrameType) -> None\n        \"\"\"\n        Given one or more nested loops, add an iteration for the innermost\n        loop (the last in the sequence).\n        \"\"\"\n        iteration = self.stack[frame].iteration  # type: Iteration\n        for i, loop_node in enumerate(loops):\n            loop = iteration.loops[loop_node._tree_index]\n            if i == len(loops) - 1:\n                loop.append(Iteration())\n            else:\n                iteration = loop.last()\n\n    def after_expr(self, node, frame, value, exc_value, exc_tb):\n        # type: (ast.expr, FrameType, Any, Optional[BaseException], Optional[TracebackType]) -> Optional[ChangeValue]\n\n        if _tracing_recursively(frame):\n            return None\n\n        if frame.f_code not in self._code_infos:\n            return None\n\n        if node._is_interesting_expression:\n            # If this is an expression statement and the last statement\n            # in the body, the value is returned from the cell magic\n            # to be displayed as usual\n            if (self._code_infos[frame.f_code].traced_file.is_ipython_cell\n                    and isinstance(node.parent, ast.Expr)\n                    and node.parent is node.parent.parent.body[-1]):\n                self._ipython_cell_value = value\n\n            if is_obvious_builtin(node, self.stack[frame].expression_values[node]):\n                return None\n\n            frame_info = self.stack[frame]\n            if exc_value:\n                node_value = self._exception_value(node, frame, exc_value)\n            else:\n                node_value = NodeValue.expression(\n                    self.num_samples,\n                    value,\n                    level=max(1, 3 - len(node._loops) * (not self._is_first_loop_iteration(node, frame))),\n                )\n                self._set_node_value(node, frame, node_value)\n            self._check_inner_call(frame_info, node, node_value)\n\n        # i.e. is `node` the `y` in `[f(x) for x in y]`, making `node.parent` the `for x in y`\n        is_special_comprehension_iter = (\n                isinstance(node.parent, ast.comprehension) and\n                node is node.parent.iter and\n\n                # Generators execute in their own time and aren't directly attached to the parent frame\n                not isinstance(node.parent.parent, ast.GeneratorExp))\n\n        if not is_special_comprehension_iter:\n            return None\n\n        # Mark `for x in y` as a bit that executed, so it doesn't show as grey\n        self._set_node_value(node.parent, frame, NodeValue.covered())\n\n        if exc_value:\n            return None\n\n        # Track each iteration over `y` so that the 'loop' can be stepped through\n        loops = node._loops + (node.parent,)  # type: Tuple[Loop, ...]\n\n        def comprehension_iter_proxy():\n            for item in value:\n                self._add_iteration(loops, frame)\n                yield item\n\n        # This effectively changes to code to `for x in comprehension_iter_proxy()`\n        return ChangeValue(comprehension_iter_proxy())\n\n    def _check_inner_call(self, frame_info, node, node_value):\n        # type: (FrameInfo, Union[ast.stmt, ast.expr], NodeValue) -> None\n        inner_calls = frame_info.inner_calls.pop(node, None)\n        if inner_calls:\n            node_value.set_meta('inner_calls', inner_calls)\n\n    def _is_first_loop_iteration(self, node, frame):\n        # type: (ast.AST, FrameType) -> bool\n        iteration = self.stack[frame].iteration  # type: Iteration\n        for loop_node in node._loops:  # type: ast.AST\n            loop = iteration.loops[loop_node._tree_index]\n            iteration = loop.last()\n            if iteration.index > 0:\n                return False\n        return True\n\n    def _set_node_value(self, node, frame, value):\n        # type: (ast.AST, FrameType, NodeValue) -> None\n        iteration = self.stack[frame].iteration  # type: Iteration\n        for loop_node in node._loops:  # type: ast.AST\n            loop = iteration.loops[loop_node._tree_index]\n            loop.recorded_node(node)\n            iteration = loop.last()\n        iteration.vals[node._tree_index] = value\n\n    def _exception_value(self, node, frame, exc_value):\n        # type: (Union[ast.expr, ast.stmt], FrameType, BaseException) -> NodeValue\n        value = NodeValue.exception(exc_value)\n        self._set_node_value(node, frame, value)\n        return value\n\n    def after_stmt(self, node, frame, exc_value, exc_traceback, exc_node):\n        # type: (ast.stmt, FrameType, Optional[BaseException], Optional[TracebackType], Optional[ast.AST]) -> Optional[bool]\n        if frame.f_code not in self._code_infos or _tracing_recursively(frame):\n            return None\n        if exc_value and node is exc_node:\n            value = self._exception_value(node, frame, exc_value)\n        else:\n            value = NodeValue.covered()\n            self._set_node_value(node, frame, value)\n        self._check_inner_call(self.stack[frame], node, value)\n        return None\n\n    def enter_call(self, enter_info):\n        # type: (EnterCallInfo) -> None\n        frame = enter_info.current_frame  # type: FrameType\n        if frame.f_code not in self._code_infos or _tracing_recursively(frame):\n            return\n        frame_info = self.stack[frame]\n        frame_info.start_time = get_unfrozen_datetime()\n        frame_info.iteration = Iteration()\n\n        code_info = self._code_infos[frame.f_code]\n        if isinstance(enter_info.enter_node.parent, ast.Module):\n            arguments = []\n        else:\n            f_locals = frame.f_locals.copy()  # type: Dict[str, Any]\n            arguments = [(name, f_locals.pop(name))\n                         for name in code_info.arg_names\n                         if name] + [\n\n                            # Local variables other than actual arguments. These are variables from\n                            # the enclosing scope. It's handy to treat them like arguments in the UI\n                            it for it in f_locals.items()\n                            if it[0][0] != '.'  # Appears when using nested tuple arguments\n                        ]\n        frame_info.arguments = json.dumps([[k, cheap_repr(v)] for k, v in arguments])\n        frame_info.call_id = self._call_id()\n        frame_info.inner_calls = defaultdict(list)\n        prev = self.stack.get(enter_info.caller_frame)\n        if prev:\n            inner_calls = getattr(prev, 'inner_calls', None)\n            if inner_calls is not None:\n                inner_calls[enter_info.call_node].append(frame_info.call_id)\n\n    def _call_id(self):\n        # type: () -> Text\n        return uuid4().hex\n\n    def exit_call(self, exit_info):\n        # type: (ExitCallInfo) -> None\n        \"\"\"\n        This is where all the data collected during the call is gathered up\n        and sent to the database.\n        \"\"\"\n        frame = exit_info.current_frame  # type: FrameType\n        if frame.f_code not in self._code_infos or _tracing_recursively(frame):\n            return\n        frame_info = self.stack[frame]\n\n        top_iteration = frame_info.iteration  # type: Iteration\n        node_values = _deep_dict()\n        self._extract_node_values(top_iteration, (), node_values)\n\n        db_func = self._code_infos[frame.f_code].db_func\n        exc = exit_info.exc_value  # type: Optional[Exception]\n        if exc:\n            traceback_str = ''.join(traceback.format_exception(type(exc), exc, exit_info.exc_tb))\n            exception = exception_string(exc)\n        else:\n            traceback_str = exception = None\n\n        @retry_db\n        def add_call():\n            Call = self.db.Call\n            call = Call(id=frame_info.call_id,\n                        function_id=db_func,\n                        arguments=frame_info.arguments,\n                        return_value=cheap_repr(exit_info.return_value),\n                        exception=exception,\n                        traceback=traceback_str,\n                        data=json.dumps(\n                            dict(\n                                node_values=node_values,\n                                loop_iterations=top_iteration.extract_iterations()['loops'],\n                                type_names=type_registry.names(),\n                                num_special_types=type_registry.num_special_types,\n                            ),\n                            cls=ProtocolEncoder,\n                            separators=(',', ':')\n                        ),\n                        start_time=frame_info.start_time)\n            with self.db.session_scope() as session:\n                session.add(call)\n\n        add_call()\n\n        self._last_call_id = frame_info.call_id\n\n    def _extract_node_values(self, iteration, path, node_values):\n        # type: (Iteration, Tuple[int, ...], dict) -> None\n        \"\"\"\n        Populates node_values with values inside iteration.\n        \"\"\"\n        # Each element of `path` is an index of a loop iteration\n        # e.g. given the nested loops:\n        #\n        # for i in [0, 1, 2]:\n        #     for j in [0, 1, 2, 3]:\n        #\n        # path may be (i, j) for each of the iterations\n        for tree_index, node_value in iteration.vals.items():\n\n            # So this `full_path` is a tuple of ints, but the first\n            # int has a different meaning from the others\n            full_path = (tree_index,) + path\n\n            # Given a path (a, b, c) we're making node_values 'contain'\n            # this structure:\n            # {a: {b: {c: node_value}}}\n            d = node_values\n            for path_k in full_path[:-1]:\n                d = d[path_k]\n            d[full_path[-1]] = node_value\n\n        for loop in iteration.loops.values():\n            for i, iteration in enumerate(loop):\n                self._extract_node_values(iteration, path + (i,), node_values)\n\n    def trace_function(self, func):\n        # type: (FunctionType) -> FunctionType\n        new_func = super(BirdsEye, self).trace_function(func)\n        code_info = self._code_infos.get(new_func.__code__)\n        if code_info:\n            return new_func\n\n        lines, start_lineno = inspect.getsourcelines(func)  # type: List[Text], int\n        end_lineno = start_lineno + len(lines)\n        name = safe_qualname(func)\n        source_file = inspect.getsourcefile(func)\n        if source_file.startswith('<ipython-input'):\n            filename = IPYTHON_FILE_PATH\n        else:\n            filename = os.path.abspath(source_file)\n        traced_file = new_func.traced_file\n\n        arg_info = inspect.getargs(new_func.__code__)\n        arg_names = list(chain(flatten_list(arg_info[0]), arg_info[1:]))  # type: List[str]\n        self._trace(name, filename, traced_file, new_func.__code__, typ='function',\n                    start_lineno=start_lineno, end_lineno=end_lineno,\n                    arg_names=arg_names)\n\n        return new_func\n\n    def exec_ipython_cell(self, source, callback):\n        from IPython import get_ipython\n        shell = get_ipython()\n        filename = name = shell.compile.cache(source)\n        flags = shell.compile.flags\n\n        traced_file = self.compile(source, filename, flags)\n        traced_file.is_ipython_cell = True\n\n        for node in traced_file.root.body:\n            if is_future_import(node):\n                raise ValueError('from __future__ import ... statements '\n                                 'are not allowed in cells traced with %%eye')\n\n        shell.user_global_ns.update(self._trace_methods_dict(traced_file))\n\n        self._trace(name, filename, traced_file, traced_file.code, 'module', source)\n\n        try:\n            shell.ex(traced_file.code)\n            return self._ipython_cell_value\n        finally:\n            callback(self._last_call_id)\n            self._ipython_cell_value = None\n\n    def trace_this_module(self, context=0, deep=False):\n        frame = inspect.currentframe()\n\n        filename = None\n        while context >= 0:\n            frame = frame.f_back\n            filename = inspect.getsourcefile(frame)\n            if filename is not None:\n                context -= 1\n        filename = os.path.abspath(filename)\n\n        if frame.f_globals.get('__name__') != '__main__':\n            if PY3 and self._treetrace_hidden_with_stmt.__name__ not in frame.f_globals:\n                raise RuntimeError(\n                    'To trace an imported module, you must import birdseye before '\n                    'importing that module.')\n            return\n\n        lines = read_source_file(filename).splitlines()\n        lines[:frame.f_lineno] = [''] * frame.f_lineno\n        source = '\\n'.join(lines)\n        self.exec_string(source, filename, frame.f_globals, frame.f_locals, deep)\n        sys.exit(0)\n\n    def exec_string(self, source, filename, globs=None, locs=None, deep=False):\n        globs = globs or {}\n        locs = locs or {}\n\n        traced_file = self.compile(source, filename)\n\n        globs.update(self._trace_methods_dict(traced_file))\n\n        self._trace(FILE_SENTINEL_NAME, filename, traced_file, traced_file.code, 'module', source)\n\n        if deep:\n            nodes_by_lineno = {\n                node.lineno: node\n                for node in traced_file.nodes\n                if isinstance(node, ast.FunctionDef)\n            }\n\n            def find_code(root_code):\n                # type: (CodeType) -> None\n                for code in root_code.co_consts:  # type: CodeType\n                    if not inspect.iscode(code) or code.co_name.startswith('<'):\n                        continue\n\n                    find_code(code)\n\n                    lineno = code.co_firstlineno\n                    node = nodes_by_lineno.get(lineno)\n                    if not node:\n                        continue\n\n                    self._trace(\n                        code.co_name, filename, traced_file, code,\n                        typ='function',\n                        source=source,\n                        start_lineno=lineno,\n                        end_lineno=node.last_token.end[0] + 1,\n                    )\n\n            find_code(traced_file.code)\n\n        exec(traced_file.code, globs, locs)\n\n    def _trace(\n            self,\n            name,\n            filename,\n            traced_file,\n            code,\n            typ,\n            source='',\n            start_lineno=1,\n            end_lineno=None,\n            arg_names=(),\n    ):\n        if not end_lineno:\n            end_lineno = start_lineno + len(source.splitlines())\n        nodes = list(self._nodes_of_interest(traced_file, start_lineno, end_lineno))\n        html_body = self._nodes_html(nodes, start_lineno, end_lineno, traced_file)\n\n        data_dict = dict(\n            # This maps each node to the loops enclosing that node\n            node_loops={\n                node._tree_index: [n._tree_index for n in node._loops]\n                for node, _ in nodes\n                if node._loops\n            },\n        )\n        if typ == 'function':\n            tokens = traced_file.tokens\n            func_node = only(node\n                             for node, _ in nodes\n                             if isinstance(node, ast.FunctionDef)\n                             and node.first_token.start[0] == start_lineno)\n            func_startpos, source = source_without_decorators(tokens, func_node)\n            # These are for the PyCharm plugin\n            data_dict.update(\n                node_ranges=list(self._node_ranges(nodes, tokens, func_startpos)),\n                loop_ranges=list(self._loop_ranges(nodes, tokens, func_startpos)),\n            )\n\n        data = json.dumps(data_dict, sort_keys=True)\n        db_func = self._db_func(data, filename, html_body, name, start_lineno, source, typ)\n        self._code_infos[code] = CodeInfo(db_func, traced_file, arg_names)\n\n    def _loop_ranges(self, nodes, tokens, func_start):\n        # For a for loop, e.g.\n        #\n        #     for x in y:\n        #\n        # this yields the range of the target 'x'.\n        #\n        # For a while loop, e.g.\n        #\n        #     while x < 10:\n        #\n        # this yields the range of the condition 'x < 10'.\n        for node, (classes, _, __) in nodes:\n            if 'loop' not in classes:\n                continue\n\n            try:\n                target = node.target  # for loop\n            except AttributeError:\n                target = node.test  # while loop\n\n            start, end = tokens.get_text_range(target)\n            start -= func_start\n            end -= func_start\n\n            yield dict(\n                tree_index=node._tree_index,\n                start=start,\n                end=end\n            )\n\n    def _node_ranges(self, nodes, tokens, func_start):\n        for node, (classes, _, __) in nodes:\n            start, end = tokens.get_text_range(node)\n            start -= func_start\n            end -= func_start\n\n            if start < 0:\n                assert (end < 0  # nodes before the def, i.e. decorators\n                        or isinstance(node, ast.FunctionDef))\n                continue\n\n            yield dict(\n                tree_index=node._tree_index,\n                start=start,\n                end=end,\n                depth=node._depth,\n                classes=classes,\n            )\n\n    @retry_db\n    def _db_func(self, data, filename, html_body, name, start_lineno, source, typ):\n        \"\"\"\n        Retrieve the Function object from the database if one exists, or create one.\n        \"\"\"\n\n        def h(s):\n            return hashlib.sha256(s.encode('utf8')).hexdigest()\n\n        function_hash = h(filename + name + html_body + data + str(start_lineno))\n\n        Function = self.db.Function\n\n        with self.db.session_scope() as session:\n            db_func = one_or_none(session.query(Function).filter_by(hash=function_hash))  # type: Optional[Function]\n            if not db_func:\n                db_func = Function(file=filename,\n                                   name=name,\n                                   type=typ,\n                                   html_body=html_body,\n                                   lineno=start_lineno,\n                                   data=data,\n                                   body_hash=h(source),\n                                   hash=function_hash)\n                session.add(db_func)\n                session.commit()  # ensure .id exists\n            assert isinstance(db_func.id, int)\n            return db_func.id\n\n    def _nodes_of_interest(self, traced_file, start_lineno, end_lineno):\n        # type: (TracedFile, int, int) -> Iterator[Tuple[ast.AST, Tuple]]\n        \"\"\"\n        Nodes that may have a value, show up as a box in the UI, and lie within the\n        given line range.\n        \"\"\"\n        for node in traced_file.nodes:\n            classes = []\n\n            if (isinstance(node, (ast.While, ast.For, ast.comprehension)) and\n                    not isinstance(node.parent, ast.GeneratorExp)):\n                classes.append('loop')\n            if isinstance(node, ast.stmt):\n                classes.append('stmt')\n\n            if isinstance(node, ast.expr):\n                if not node._is_interesting_expression:\n                    continue\n            elif not classes:\n                continue\n\n            assert isinstance(node, ast.AST)\n\n            # In particular FormattedValue is missing this\n            if not hasattr(node, 'first_token'):\n                continue\n\n            if not start_lineno <= node.first_token.start[0] <= end_lineno:\n                continue\n\n            start, end = traced_file.tokens.get_text_range(node)  # type: int, int\n            if start == end == 0:\n                continue\n\n            yield node, (classes, start, end)\n\n    def _nodes_html(self, nodes, start_lineno, end_lineno, traced_file):\n        # type: (list, int, int, TracedFile) -> str\n        \"\"\"\n        The algorithm for generating the HTML works as follows. We generate a list\n        of HTMLPositions, which are essentially places to insert HTML into the source plus some\n        metadata. The order of the fields of HTMLPosition ensure that when the list is sorted,\n        the resulting HTML is valid and correct. Specifically, the fields are:\n        \n          1. index: the index in the source string where the HTML would be inserted\n          2. is_start: Indicates if this piece of HTML is the start of a tag, rather than the end.\n             Ends should appear first, so that the resulting HTML looks like:\n                <span> ... </span><span> ... </span>\n             rather than:\n                <span> ... <span></span> ... </span>\n             (I think this might actually be unnecessary, since I can't think of any cases of two\n              expressions right next to each other with nothing in between)\n          3. depth: the depth of the corresponding node in the AST. We want the start of a tag from\n             a node to appear before the start of a tag nested within, e.g. `foo()` should become:\n                <span [for foo()]><span [for foo]>foo</span>()</span>\n             rather than:   \n                <span [for foo]><span [for foo()]>foo</span>()</span>\n          4. html: the actual HTML to insert. Not important for ordering.\n          \n        Mostly the list contains pairs of HTMLPositions corresponding to AST nodes, one for the\n        start and one for the end.\n        \n        After the list is sorted, the HTML generated is essentially:\n        \n        source[0:positions[0].index] + positions[0].html + source[positions[0].index:positions[1].index] + positions[1].html + ...\n        \"\"\"\n\n        traced_file.root._depth = 0\n        for node in ast.walk(traced_file.root):  # type: ast.AST\n            for child in ast.iter_child_nodes(node):\n                child._depth = node._depth + 1\n\n        positions = []  # type: List[HTMLPosition]\n\n        for node, (classes, start, end) in nodes:\n            # noinspection PyArgumentList\n            positions.extend(map(\n                HTMLPosition,\n                [start, end],\n                [True, False],  # is_start\n                [node._depth, node._depth],\n                ['<span data-index=\"%s\" class=\"%s\">' % (node._tree_index, ' '.join(classes)),\n                 '</span>']))\n\n        end_lineno = self._separate_comprehensions(\n            [n[0] for n in nodes],\n            end_lineno, positions, traced_file)\n\n        # This just makes the loop below simpler\n        positions.append(HTMLPosition(len(traced_file.source), False, 0, ''))\n\n        positions.sort()\n\n        html_parts = []\n        start = 0\n        for position in positions:\n            html_parts.append(html.escape(traced_file.source[start:position.index]))\n            html_parts.append(position.html)\n            start = position.index\n        html_body = ''.join(html_parts)\n        html_body = '\\n'.join(html_body.split('\\n')[start_lineno - 1:end_lineno - 1])\n\n        return html_body.strip('\\n')\n\n    def _separate_comprehensions(self, nodes, end_lineno, positions, traced_file):\n        # type: (list, int, List[HTMLPosition], TracedFile) -> int\n        \"\"\"\n        Comprehensions (e.g. list comprehensions) are troublesome because they can\n        be navigated like loops, and the buttons for these need to be on separate lines.\n        This function inserts newlines to turn:\n\n        [x + y for x in range(3) for y in range(5)] and\n        [[x + y for x in range(3)] for y in range(5)]\n\n        into\n\n        [x + y for x in range(3)\n         for y in range(5)] and\n        [[x + y for x in range(3)]\n         for y in range(5)]\n        \"\"\"\n\n        comprehensions = group_by_key_func(of_type((ast.comprehension, ast.While, ast.For), nodes),\n                                           lambda c: c.first_token.start[0]\n                                           )  # type: Dict[Any, Iterable[ast.comprehension]]\n\n        def get_start(n):\n            # type: (ast.AST) -> int\n            return traced_file.tokens.get_text_range(n)[0]\n\n        for comp_list in comprehensions.values():\n            prev_start = None  # type: Optional[int]\n            for comp in sorted(comp_list, key=lambda c: c.first_token.startpos):\n                if isinstance(comp, ast.comprehension) and comp is comp.parent.generators[0]:\n                    start = get_start(comp.parent)\n                    if prev_start is not None and start < prev_start:\n                        start = get_start(comp)\n                else:\n                    start = get_start(comp)\n                if prev_start is not None:\n                    positions.append(HTMLPosition(start, True, 0, '\\n '))\n                    end_lineno += 1\n                prev_start = start\n\n        return end_lineno"
    ],
    [
        "LOAD_NAME",
        "BirdsEye"
    ],
    [
        "CALL_FUNCTION",
        "BirdsEye()"
    ],
    [
        "STORE_NAME",
        "eye"
    ],
    [
        "LOAD_NAME",
        "NamedTuple"
    ],
    [
        "LOAD_NAME",
        "int"
    ],
    [
        "LOAD_NAME",
        "bool"
    ],
    [
        "LOAD_NAME",
        "int"
    ],
    [
        "LOAD_NAME",
        "str"
    ],
    [
        "CALL_FUNCTION",
        "NamedTuple('HTMLPosition', [\n    ('index', int),\n    ('is_start', bool),\n    ('depth', int),\n    ('html', str),\n])"
    ],
    [
        "STORE_NAME",
        "HTMLPosition"
    ],
    [
        "STORE_NAME",
        "def _deep_dict():\n    return defaultdict(_deep_dict)"
    ],
    [
        "LOAD_NAME",
        "eye"
    ],
    [
        "LOAD_ATTR",
        "eye.enter_call"
    ],
    [
        "LOAD_ATTR",
        "eye.enter_call.__code__"
    ],
    [
        "LOAD_NAME",
        "eye"
    ],
    [
        "LOAD_ATTR",
        "eye.exit_call"
    ],
    [
        "LOAD_ATTR",
        "eye.exit_call.__code__"
    ],
    [
        "LOAD_NAME",
        "eye"
    ],
    [
        "LOAD_ATTR",
        "eye.after_expr"
    ],
    [
        "LOAD_ATTR",
        "eye.after_expr.__code__"
    ],
    [
        "LOAD_NAME",
        "eye"
    ],
    [
        "LOAD_ATTR",
        "eye.after_stmt"
    ],
    [
        "LOAD_ATTR",
        "eye.after_stmt.__code__"
    ],
    [
        "STORE_NAME",
        "_bad_codes"
    ],
    [
        "STORE_NAME",
        "def _tracing_recursively(frame):\n    while frame:\n        if frame.f_code in _bad_codes:\n            return True\n        frame = frame.f_back"
    ],
    [
        "LOAD_NAME",
        "object"
    ],
    [
        "CALL_FUNCTION",
        "class Iteration(object):\n    \"\"\"\n    Corresponds to an iteration of a loop during a call, OR\n    the call itself (FrameInfo.iteration).\n    \"\"\"\n\n    def __init__(self):\n        # Mapping of nodes (via node._tree_index) to the value of that\n        # node in this iteration. Only contains nodes within the corresponding\n        # loop or at the top of the function, but not in loops further within\n        # (those will be somewhere within self.loops)\n        # Therefore those nodes have at most one value.\n        self.vals = {}  # type: Dict[int, NodeValue]\n\n        # Mapping of loop nodes (via node._tree_index) to IterationLists\n        # for loops that happened during this iteration\n        self.loops = defaultdict(IterationList)  # type: Dict[int, IterationList]\n\n        # 0-based index of this iteration\n        self.index = None  # type: int\n        self.keep = False\n\n    def extract_iterations(self):\n        # type: () -> Dict[str, Union[int, Dict]]\n        return {\n            'index': self.index,\n            'loops': {\n                tree_index: [iteration.extract_iterations()\n                             for iteration in iteration_list]\n                for tree_index, iteration_list in self.loops.items()\n            }\n        }"
    ],
    [
        "STORE_NAME",
        "class Iteration(object):\n    \"\"\"\n    Corresponds to an iteration of a loop during a call, OR\n    the call itself (FrameInfo.iteration).\n    \"\"\"\n\n    def __init__(self):\n        # Mapping of nodes (via node._tree_index) to the value of that\n        # node in this iteration. Only contains nodes within the corresponding\n        # loop or at the top of the function, but not in loops further within\n        # (those will be somewhere within self.loops)\n        # Therefore those nodes have at most one value.\n        self.vals = {}  # type: Dict[int, NodeValue]\n\n        # Mapping of loop nodes (via node._tree_index) to IterationLists\n        # for loops that happened during this iteration\n        self.loops = defaultdict(IterationList)  # type: Dict[int, IterationList]\n\n        # 0-based index of this iteration\n        self.index = None  # type: int\n        self.keep = False\n\n    def extract_iterations(self):\n        # type: () -> Dict[str, Union[int, Dict]]\n        return {\n            'index': self.index,\n            'loops': {\n                tree_index: [iteration.extract_iterations()\n                             for iteration in iteration_list]\n                for tree_index, iteration_list in self.loops.items()\n            }\n        }"
    ],
    [
        "LOAD_NAME",
        "Iterable"
    ],
    [
        "LOAD_NAME",
        "Iteration"
    ],
    [
        "BINARY_SUBSCR",
        "Iterable[Iteration]"
    ],
    [
        "CALL_FUNCTION",
        "class IterationList(Iterable[Iteration]):\n    \"\"\"\n    A list of Iterations, corresponding to a run of a loop.\n    If the loop has many iterations, only contains the first and last few\n    and any in the middle where unique nodes had values, so that\n    any node which appeared during this loop exists in at least some iterations.\n    \"\"\"\n    side_len = 3\n\n    def __init__(self):\n        # Contains the first few iterations\n        # and any after that have unique nodes in them\n        self.start = []  # type: List[Iteration]\n\n        # Contains the last few iterations\n        self.end = deque(maxlen=self.side_len)  # type: Deque[Iteration]\n\n        # Total number of iterations in the loop, not all of which\n        # are kept\n        self.length = 0  # type: int\n\n        # Number of times each node has been recorded in this loop\n        self.recorded = Counter()\n\n    def append(self, iteration):\n        # type: (Iteration) -> None\n        if self.length < self.side_len:\n            self.start.append(iteration)\n        else:\n            # If self.end is too long, the first element self.end[0]\n            # is about to be dropped by the deque. If that iteration\n            # should be kept because of some node that was recorded,\n            # add it to self.start\n            if len(self.end) >= self.side_len and self.end[0].keep:\n                self.start.append(self.end[0])\n\n            self.end.append(iteration)\n        iteration.index = self.length\n        self.length += 1\n\n    def __iter__(self):\n        # type: () -> Iterator[Iteration]\n        return chain(self.start, self.end)\n\n    def last(self):\n        # type: () -> Iteration\n        if self.end:\n            return self.end[-1]\n        else:\n            return self.start[-1]\n\n    def recorded_node(self, node):\n        # type: (ast.AST) -> None\n        if self.recorded[node] >= 2:\n            # We've already seen this node enough\n            return\n\n        # This node is new(ish), make sure we keep this iteration\n        self.last().keep = True\n        self.recorded[node] += 1"
    ],
    [
        "STORE_NAME",
        "class IterationList(Iterable[Iteration]):\n    \"\"\"\n    A list of Iterations, corresponding to a run of a loop.\n    If the loop has many iterations, only contains the first and last few\n    and any in the middle where unique nodes had values, so that\n    any node which appeared during this loop exists in at least some iterations.\n    \"\"\"\n    side_len = 3\n\n    def __init__(self):\n        # Contains the first few iterations\n        # and any after that have unique nodes in them\n        self.start = []  # type: List[Iteration]\n\n        # Contains the last few iterations\n        self.end = deque(maxlen=self.side_len)  # type: Deque[Iteration]\n\n        # Total number of iterations in the loop, not all of which\n        # are kept\n        self.length = 0  # type: int\n\n        # Number of times each node has been recorded in this loop\n        self.recorded = Counter()\n\n    def append(self, iteration):\n        # type: (Iteration) -> None\n        if self.length < self.side_len:\n            self.start.append(iteration)\n        else:\n            # If self.end is too long, the first element self.end[0]\n            # is about to be dropped by the deque. If that iteration\n            # should be kept because of some node that was recorded,\n            # add it to self.start\n            if len(self.end) >= self.side_len and self.end[0].keep:\n                self.start.append(self.end[0])\n\n            self.end.append(iteration)\n        iteration.index = self.length\n        self.length += 1\n\n    def __iter__(self):\n        # type: () -> Iterator[Iteration]\n        return chain(self.start, self.end)\n\n    def last(self):\n        # type: () -> Iteration\n        if self.end:\n            return self.end[-1]\n        else:\n            return self.start[-1]\n\n    def recorded_node(self, node):\n        # type: (ast.AST) -> None\n        if self.recorded[node] >= 2:\n            # We've already seen this node enough\n            return\n\n        # This node is new(ish), make sure we keep this iteration\n        self.last().keep = True\n        self.recorded[node] += 1"
    ],
    [
        "LOAD_NAME",
        "object"
    ],
    [
        "CALL_FUNCTION",
        "class TypeRegistry(object):\n    basic_types = (type(None), bool, int, float, complex)\n    if PY2:\n        basic_types += (long,)\n    special_types = basic_types + (list, dict, tuple, set, frozenset, str)\n    if PY2:\n        special_types += (unicode if PY2 else bytes,)\n\n    num_special_types = len(special_types)\n\n    def __init__(self):\n        self.lock = Lock()\n        self.data = defaultdict(lambda: len(self.data))  # type: Dict[type, int]\n\n        for t in self.special_types:\n            _ = self.data[t]\n\n    def __getitem__(self, item):\n        t = correct_type(item)\n        with self.lock:\n            return self.data[t]\n\n    def names(self):\n        # type: () -> List[str]\n        rev = dict((v, k) for k, v in self.data.items())\n        return [safe_qualname(rev[i]) for i in range(len(rev))]"
    ],
    [
        "STORE_NAME",
        "class TypeRegistry(object):\n    basic_types = (type(None), bool, int, float, complex)\n    if PY2:\n        basic_types += (long,)\n    special_types = basic_types + (list, dict, tuple, set, frozenset, str)\n    if PY2:\n        special_types += (unicode if PY2 else bytes,)\n\n    num_special_types = len(special_types)\n\n    def __init__(self):\n        self.lock = Lock()\n        self.data = defaultdict(lambda: len(self.data))  # type: Dict[type, int]\n\n        for t in self.special_types:\n            _ = self.data[t]\n\n    def __getitem__(self, item):\n        t = correct_type(item)\n        with self.lock:\n            return self.data[t]\n\n    def names(self):\n        # type: () -> List[str]\n        rev = dict((v, k) for k, v in self.data.items())\n        return [safe_qualname(rev[i]) for i in range(len(rev))]"
    ],
    [
        "LOAD_NAME",
        "TypeRegistry"
    ],
    [
        "CALL_FUNCTION",
        "TypeRegistry()"
    ],
    [
        "STORE_NAME",
        "type_registry"
    ],
    [
        "LOAD_NAME",
        "object"
    ],
    [
        "CALL_FUNCTION",
        "class NodeValue(object):\n    \"\"\"\n    The 'value' of a node during a particular iteration.\n    This can mean different things, see the classmethods.\n    Can also contain some metadata, including links to other calls.\n    \"\"\"\n    __slots__ = ('val_repr', 'type_index', 'meta', 'children')\n\n    def __init__(self, val_repr, type_index):\n        self.val_repr = val_repr  # type: str\n        self.type_index = type_index  # type: int\n        self.meta = None  # type: Optional[Dict[str, Any]]\n        self.children = None  # type: Optional[List[Tuple[str, NodeValue]]]\n\n    def set_meta(self, key, value):\n        # type: (str, Any) -> None\n        self.meta = self.meta or {}\n        self.meta[key] = value\n\n    def add_child(self, samples, level, key, value):\n        # type: (dict, int, str, Any) -> None\n        self.children = self.children or []\n        self.children.append((key, NodeValue.expression(samples, value, level)))\n\n    def as_json(self):\n        result = [self.val_repr, self.type_index, self.meta or {}]  # type: list\n        if self.children:\n            result.extend(self.children)\n        return result\n\n    @classmethod\n    def covered(cls):\n        \"\"\"\n        Represents a bit of code, usually a statement, that executed successfully but\n        doesn't have an actual value.\n        \"\"\"\n        return cls('', -2)\n\n    @classmethod\n    def exception(cls, exc_value):\n        \"\"\"\n        Means that exc_value was raised by a node when executing, and not any inner node.\n        \"\"\"\n        return cls(exception_string(exc_value), -1)\n\n    @classmethod\n    def expression(cls, samples, val, level):\n        # type: (dict, Any, int) -> NodeValue\n        \"\"\"\n        The value of an expression or one of its children, with attributes,\n        dictionary items, etc as children. Has a max depth of `level` levels.\n        \"\"\"\n        result = cls(cheap_repr(val), type_registry[val])\n        if isinstance(val, (TypeRegistry.basic_types, BirdsEye)):\n            return result\n\n        length = None\n        if not isinstance(val, QuerySet):  # len triggers a database query\n            try:\n                length = len(val)\n            except:\n                pass\n            else:\n                result.set_meta('len', length)\n\n        if isinstance(val, ModuleType):\n            level = min(level, 2)\n\n        add_child = partial(result.add_child, samples, level - 1)\n\n        if isinstance(val, (Series, ndarray)):\n            attrs = ['dtype']\n            if isinstance(val, ndarray):\n                attrs.append('shape')\n            for name in attrs:\n                try:\n                    attr = getattr(val, name)\n                except AttributeError:\n                    pass\n                else:\n                    add_child(name, attr)\n\n        if level >= 3 or level >= 2 and isinstance(val, Series):\n            sample_type = 'big'\n        else:\n            sample_type = 'small'\n\n        samples = samples[sample_type]\n\n        # Always expand DataFrames and Series regardless of level to\n        # make the table view of DataFrames work\n\n        if isinstance(val, DataFrame):\n            meta = {}\n            result.set_meta('dataframe', meta)\n\n            max_rows = samples['pandas_rows']\n            max_cols = samples['pandas_cols']\n\n            if length > max_rows + 2:\n                meta['row_break'] = max_rows // 2\n\n            columns = val.columns\n            num_cols = len(columns)\n            if num_cols > max_cols + 2:\n                meta['col_break'] = max_cols // 2\n\n            indices = set(_sample_indices(num_cols, max_cols))\n            for i, (formatted_name, label) in enumerate(zip(val.columns.format(sparsify=False),\n                                                            val.columns)):\n                if i in indices:\n                    add_child(formatted_name, val[label])\n\n            return result\n\n        if isinstance(val, Series):\n            for i in _sample_indices(length, samples['pandas_rows']):\n                try:\n                    k = val.index[i:i + 1].format(sparsify=False)[0]\n                    v = val.iloc[i]\n                except:\n                    pass\n                else:\n                    add_child(k, v)\n            return result\n\n        if (level <= 0 or\n                isinstance(val,\n                           (str, bytes, range)\n                           if PY3 else\n                           (str, unicode, xrange))):\n            return result\n\n        if isinstance(val, (Sequence, ndarray)) and length is not None:\n            for i in _sample_indices(length, samples['list']):\n                try:\n                    v = val[i]\n                except:\n                    pass\n                else:\n                    add_child(str(i), v)\n\n        if isinstance(val, Mapping):\n            for k, v in islice(_safe_iter(val, iteritems), samples['dict']):\n                add_child(cheap_repr(k), v)\n\n        if isinstance(val, Set):\n            vals = _safe_iter(val)\n            num_items = samples['set']\n            if length is None or length > num_items + 2:\n                vals = islice(vals, num_items)\n            for i, v in enumerate(vals):\n                add_child('<%s>' % i, v)\n\n        d = getattr(val, '__dict__', None)\n        if d:\n            for k in sorted(islice(_safe_iter(d),\n                                   samples['attributes']),\n                            key=str):\n                v = d[k]\n                if isinstance(v, TracedFile):\n                    continue\n                add_child(str(k), v)\n        else:\n            for s in sorted(getattr(type(val), '__slots__', None) or ()):\n                try:\n                    attr = getattr(val, s)\n                except AttributeError:\n                    pass\n                else:\n                    add_child(str(s), attr)\n        return result"
    ],
    [
        "STORE_NAME",
        "class NodeValue(object):\n    \"\"\"\n    The 'value' of a node during a particular iteration.\n    This can mean different things, see the classmethods.\n    Can also contain some metadata, including links to other calls.\n    \"\"\"\n    __slots__ = ('val_repr', 'type_index', 'meta', 'children')\n\n    def __init__(self, val_repr, type_index):\n        self.val_repr = val_repr  # type: str\n        self.type_index = type_index  # type: int\n        self.meta = None  # type: Optional[Dict[str, Any]]\n        self.children = None  # type: Optional[List[Tuple[str, NodeValue]]]\n\n    def set_meta(self, key, value):\n        # type: (str, Any) -> None\n        self.meta = self.meta or {}\n        self.meta[key] = value\n\n    def add_child(self, samples, level, key, value):\n        # type: (dict, int, str, Any) -> None\n        self.children = self.children or []\n        self.children.append((key, NodeValue.expression(samples, value, level)))\n\n    def as_json(self):\n        result = [self.val_repr, self.type_index, self.meta or {}]  # type: list\n        if self.children:\n            result.extend(self.children)\n        return result\n\n    @classmethod\n    def covered(cls):\n        \"\"\"\n        Represents a bit of code, usually a statement, that executed successfully but\n        doesn't have an actual value.\n        \"\"\"\n        return cls('', -2)\n\n    @classmethod\n    def exception(cls, exc_value):\n        \"\"\"\n        Means that exc_value was raised by a node when executing, and not any inner node.\n        \"\"\"\n        return cls(exception_string(exc_value), -1)\n\n    @classmethod\n    def expression(cls, samples, val, level):\n        # type: (dict, Any, int) -> NodeValue\n        \"\"\"\n        The value of an expression or one of its children, with attributes,\n        dictionary items, etc as children. Has a max depth of `level` levels.\n        \"\"\"\n        result = cls(cheap_repr(val), type_registry[val])\n        if isinstance(val, (TypeRegistry.basic_types, BirdsEye)):\n            return result\n\n        length = None\n        if not isinstance(val, QuerySet):  # len triggers a database query\n            try:\n                length = len(val)\n            except:\n                pass\n            else:\n                result.set_meta('len', length)\n\n        if isinstance(val, ModuleType):\n            level = min(level, 2)\n\n        add_child = partial(result.add_child, samples, level - 1)\n\n        if isinstance(val, (Series, ndarray)):\n            attrs = ['dtype']\n            if isinstance(val, ndarray):\n                attrs.append('shape')\n            for name in attrs:\n                try:\n                    attr = getattr(val, name)\n                except AttributeError:\n                    pass\n                else:\n                    add_child(name, attr)\n\n        if level >= 3 or level >= 2 and isinstance(val, Series):\n            sample_type = 'big'\n        else:\n            sample_type = 'small'\n\n        samples = samples[sample_type]\n\n        # Always expand DataFrames and Series regardless of level to\n        # make the table view of DataFrames work\n\n        if isinstance(val, DataFrame):\n            meta = {}\n            result.set_meta('dataframe', meta)\n\n            max_rows = samples['pandas_rows']\n            max_cols = samples['pandas_cols']\n\n            if length > max_rows + 2:\n                meta['row_break'] = max_rows // 2\n\n            columns = val.columns\n            num_cols = len(columns)\n            if num_cols > max_cols + 2:\n                meta['col_break'] = max_cols // 2\n\n            indices = set(_sample_indices(num_cols, max_cols))\n            for i, (formatted_name, label) in enumerate(zip(val.columns.format(sparsify=False),\n                                                            val.columns)):\n                if i in indices:\n                    add_child(formatted_name, val[label])\n\n            return result\n\n        if isinstance(val, Series):\n            for i in _sample_indices(length, samples['pandas_rows']):\n                try:\n                    k = val.index[i:i + 1].format(sparsify=False)[0]\n                    v = val.iloc[i]\n                except:\n                    pass\n                else:\n                    add_child(k, v)\n            return result\n\n        if (level <= 0 or\n                isinstance(val,\n                           (str, bytes, range)\n                           if PY3 else\n                           (str, unicode, xrange))):\n            return result\n\n        if isinstance(val, (Sequence, ndarray)) and length is not None:\n            for i in _sample_indices(length, samples['list']):\n                try:\n                    v = val[i]\n                except:\n                    pass\n                else:\n                    add_child(str(i), v)\n\n        if isinstance(val, Mapping):\n            for k, v in islice(_safe_iter(val, iteritems), samples['dict']):\n                add_child(cheap_repr(k), v)\n\n        if isinstance(val, Set):\n            vals = _safe_iter(val)\n            num_items = samples['set']\n            if length is None or length > num_items + 2:\n                vals = islice(vals, num_items)\n            for i, v in enumerate(vals):\n                add_child('<%s>' % i, v)\n\n        d = getattr(val, '__dict__', None)\n        if d:\n            for k in sorted(islice(_safe_iter(d),\n                                   samples['attributes']),\n                            key=str):\n                v = d[k]\n                if isinstance(v, TracedFile):\n                    continue\n                add_child(str(k), v)\n        else:\n            for s in sorted(getattr(type(val), '__slots__', None) or ()):\n                try:\n                    attr = getattr(val, s)\n                except AttributeError:\n                    pass\n                else:\n                    add_child(str(s), attr)\n        return result"
    ],
    [
        "STORE_NAME",
        "def _safe_iter(val, f=lambda x: x):\n    try:\n        for x in f(val):\n            yield x\n    except:\n        pass"
    ],
    [
        "STORE_NAME",
        "def _sample_indices(length, max_length):\n    if length <= max_length + 2:\n        return range(length)\n    else:\n        return chain(range(max_length // 2),\n                     range(length - max_length // 2,\n                           length))"
    ],
    [
        "LOAD_NAME",
        "try_register_repr"
    ],
    [
        "CALL_FUNCTION",
        "try_register_repr('pandas', 'Series')"
    ],
    [
        "CALL_FUNCTION",
        "try_register_repr('pandas', 'Series')"
    ],
    [
        "STORE_NAME",
        "@try_register_repr('pandas', 'Series')\ndef _repr_series_one_line(x, helper):\n    n = len(x)\n    if n == 0:\n        return repr(x)\n    newlevel = helper.level - 1\n    pieces = []\n    maxparts = _repr_series_one_line.maxparts\n    for i in _sample_indices(n, maxparts):\n        k = x.index[i:i + 1].format(sparsify=False)[0]\n        v = x.iloc[i]\n        pieces.append('%s = %s' % (k, cheap_repr(v, newlevel)))\n    if n > maxparts + 2:\n        pieces.insert(maxparts // 2, '...')\n    return '; '.join(pieces)"
    ],
    [
        "STORE_NAME",
        "def is_interesting_expression(node):\n    # type: (ast.AST) -> bool\n    \"\"\"\n    If this expression has a value that may not be exactly what it looks like,\n    return True. Put differently, return False if this is just a literal.\n    \"\"\"\n    return (isinstance(node, ast.expr) and\n            not (isinstance(node, (ast.Num, ast.Str, getattr(ast, 'NameConstant', ()))) or\n                 isinstance(getattr(node, 'ctx', None),\n                            (ast.Store, ast.Del)) or\n                 (isinstance(node, ast.UnaryOp) and\n                  isinstance(node.op, (ast.UAdd, ast.USub)) and\n                  isinstance(node.operand, ast.Num)) or\n                 (isinstance(node, (ast.List, ast.Tuple, ast.Dict)) and\n                  not any(is_interesting_expression(n) for n in ast.iter_child_nodes(node)))))"
    ],
    [
        "STORE_NAME",
        "def is_obvious_builtin(node, value):\n    # type: (ast.expr, Any) -> bool\n    \"\"\"\n    Return True if this node looks like a builtin and it really is\n    (i.e. hasn't been shadowed).\n    \"\"\"\n    # noinspection PyUnresolvedReferences\n    builtins = cast(dict, __builtins__)\n    return ((isinstance(node, ast.Name) and\n             node.id in builtins and\n             builtins[node.id] is value) or\n            isinstance(node, getattr(ast, 'NameConstant', ())))"
    ],
    [
        "LOAD_NAME",
        "    class ndarray(object):\n        pass"
    ],
    [
        "STORE_NAME",
        "    class ndarray(object):\n        pass"
    ],
    [
        "STORE_NAME",
        "    class ndarray(object):\n        pass"
    ],
    [
        "LOAD_NAME",
        "    class DataFrame(object):\n        pass"
    ],
    [
        "STORE_NAME",
        "    class DataFrame(object):\n        pass"
    ],
    [
        "STORE_NAME",
        "    class DataFrame(object):\n        pass"
    ],
    [
        "LOAD_NAME",
        "    class Series(object):\n        pass"
    ],
    [
        "STORE_NAME",
        "    class Series(object):\n        pass"
    ],
    [
        "STORE_NAME",
        "    class Series(object):\n        pass"
    ],
    [
        "LOAD_NAME",
        "    class QuerySet(object):\n        pass"
    ],
    [
        "STORE_NAME",
        "    class QuerySet(object):\n        pass"
    ],
    [
        "STORE_NAME",
        "    class QuerySet(object):\n        pass"
    ],
    [
        "LOAD_NAME",
        "class BirdsEye(TreeTracerBase):\n    \"\"\"\n    Decorate functions with an instance of this class to debug them,\n    or just use the existing instance `eye`.\n    \"\"\"\n\n    def __init__(self, db_uri=None, num_samples=None):\n        \"\"\"\n        Set db_uri to specify where the database lives, as an alternative to\n        the environment variable BIRDSEYE_DB.\n        \"\"\"\n        super(BirdsEye, self).__init__()\n        self._db_uri = db_uri\n        self._code_infos = {}  # type: Dict[CodeType, CodeInfo]\n        self._last_call_id = None\n        self._ipython_cell_value = None\n        self.num_samples = num_samples or dict(\n            big=dict(\n                attributes=50,\n                dict=50,\n                list=30,\n                set=30,\n                pandas_rows=20,\n                pandas_cols=100,\n            ),\n            small=dict(\n                attributes=50,\n                dict=10,\n                list=6,\n                set=6,\n                pandas_rows=6,\n                pandas_cols=10,\n            ),\n        )\n\n    @cached_property\n    def db(self):\n        return Database(self._db_uri)\n\n    def parse_extra(self, root, source, filename):\n        # type: (ast.Module, str, str) -> None\n        for node in ast.walk(root):  # type: ast.AST\n            node._loops = tracer.loops(node)\n            if isinstance(node, ast.expr):\n                node._is_interesting_expression = is_interesting_expression(node)\n\n    @lru_cache()\n    def compile(self, source, filename, flags=0):\n        traced_file = super(BirdsEye, self).compile(source, filename, flags)\n        traced_file.tokens = ASTTokens(source, tree=traced_file.root)\n        return traced_file\n\n    def before_stmt(self, node, frame):\n        # type: (ast.stmt, FrameType) -> None\n        if frame.f_code not in self._code_infos:\n            return\n        if isinstance(node.parent, ast.For) and node is node.parent.body[0]:\n            self._add_iteration(node._loops, frame)\n\n    def before_expr(self, node, frame):\n        if isinstance(node.parent, ast.While) and node is node.parent.test:\n            self._add_iteration(node._loops, frame)\n\n    def _add_iteration(self, loops, frame):\n        # type: (typing.Sequence[Loop], FrameType) -> None\n        \"\"\"\n        Given one or more nested loops, add an iteration for the innermost\n        loop (the last in the sequence).\n        \"\"\"\n        iteration = self.stack[frame].iteration  # type: Iteration\n        for i, loop_node in enumerate(loops):\n            loop = iteration.loops[loop_node._tree_index]\n            if i == len(loops) - 1:\n                loop.append(Iteration())\n            else:\n                iteration = loop.last()\n\n    def after_expr(self, node, frame, value, exc_value, exc_tb):\n        # type: (ast.expr, FrameType, Any, Optional[BaseException], Optional[TracebackType]) -> Optional[ChangeValue]\n\n        if _tracing_recursively(frame):\n            return None\n\n        if frame.f_code not in self._code_infos:\n            return None\n\n        if node._is_interesting_expression:\n            # If this is an expression statement and the last statement\n            # in the body, the value is returned from the cell magic\n            # to be displayed as usual\n            if (self._code_infos[frame.f_code].traced_file.is_ipython_cell\n                    and isinstance(node.parent, ast.Expr)\n                    and node.parent is node.parent.parent.body[-1]):\n                self._ipython_cell_value = value\n\n            if is_obvious_builtin(node, self.stack[frame].expression_values[node]):\n                return None\n\n            frame_info = self.stack[frame]\n            if exc_value:\n                node_value = self._exception_value(node, frame, exc_value)\n            else:\n                node_value = NodeValue.expression(\n                    self.num_samples,\n                    value,\n                    level=max(1, 3 - len(node._loops) * (not self._is_first_loop_iteration(node, frame))),\n                )\n                self._set_node_value(node, frame, node_value)\n            self._check_inner_call(frame_info, node, node_value)\n\n        # i.e. is `node` the `y` in `[f(x) for x in y]`, making `node.parent` the `for x in y`\n        is_special_comprehension_iter = (\n                isinstance(node.parent, ast.comprehension) and\n                node is node.parent.iter and\n\n                # Generators execute in their own time and aren't directly attached to the parent frame\n                not isinstance(node.parent.parent, ast.GeneratorExp))\n\n        if not is_special_comprehension_iter:\n            return None\n\n        # Mark `for x in y` as a bit that executed, so it doesn't show as grey\n        self._set_node_value(node.parent, frame, NodeValue.covered())\n\n        if exc_value:\n            return None\n\n        # Track each iteration over `y` so that the 'loop' can be stepped through\n        loops = node._loops + (node.parent,)  # type: Tuple[Loop, ...]\n\n        def comprehension_iter_proxy():\n            for item in value:\n                self._add_iteration(loops, frame)\n                yield item\n\n        # This effectively changes to code to `for x in comprehension_iter_proxy()`\n        return ChangeValue(comprehension_iter_proxy())\n\n    def _check_inner_call(self, frame_info, node, node_value):\n        # type: (FrameInfo, Union[ast.stmt, ast.expr], NodeValue) -> None\n        inner_calls = frame_info.inner_calls.pop(node, None)\n        if inner_calls:\n            node_value.set_meta('inner_calls', inner_calls)\n\n    def _is_first_loop_iteration(self, node, frame):\n        # type: (ast.AST, FrameType) -> bool\n        iteration = self.stack[frame].iteration  # type: Iteration\n        for loop_node in node._loops:  # type: ast.AST\n            loop = iteration.loops[loop_node._tree_index]\n            iteration = loop.last()\n            if iteration.index > 0:\n                return False\n        return True\n\n    def _set_node_value(self, node, frame, value):\n        # type: (ast.AST, FrameType, NodeValue) -> None\n        iteration = self.stack[frame].iteration  # type: Iteration\n        for loop_node in node._loops:  # type: ast.AST\n            loop = iteration.loops[loop_node._tree_index]\n            loop.recorded_node(node)\n            iteration = loop.last()\n        iteration.vals[node._tree_index] = value\n\n    def _exception_value(self, node, frame, exc_value):\n        # type: (Union[ast.expr, ast.stmt], FrameType, BaseException) -> NodeValue\n        value = NodeValue.exception(exc_value)\n        self._set_node_value(node, frame, value)\n        return value\n\n    def after_stmt(self, node, frame, exc_value, exc_traceback, exc_node):\n        # type: (ast.stmt, FrameType, Optional[BaseException], Optional[TracebackType], Optional[ast.AST]) -> Optional[bool]\n        if frame.f_code not in self._code_infos or _tracing_recursively(frame):\n            return None\n        if exc_value and node is exc_node:\n            value = self._exception_value(node, frame, exc_value)\n        else:\n            value = NodeValue.covered()\n            self._set_node_value(node, frame, value)\n        self._check_inner_call(self.stack[frame], node, value)\n        return None\n\n    def enter_call(self, enter_info):\n        # type: (EnterCallInfo) -> None\n        frame = enter_info.current_frame  # type: FrameType\n        if frame.f_code not in self._code_infos or _tracing_recursively(frame):\n            return\n        frame_info = self.stack[frame]\n        frame_info.start_time = get_unfrozen_datetime()\n        frame_info.iteration = Iteration()\n\n        code_info = self._code_infos[frame.f_code]\n        if isinstance(enter_info.enter_node.parent, ast.Module):\n            arguments = []\n        else:\n            f_locals = frame.f_locals.copy()  # type: Dict[str, Any]\n            arguments = [(name, f_locals.pop(name))\n                         for name in code_info.arg_names\n                         if name] + [\n\n                            # Local variables other than actual arguments. These are variables from\n                            # the enclosing scope. It's handy to treat them like arguments in the UI\n                            it for it in f_locals.items()\n                            if it[0][0] != '.'  # Appears when using nested tuple arguments\n                        ]\n        frame_info.arguments = json.dumps([[k, cheap_repr(v)] for k, v in arguments])\n        frame_info.call_id = self._call_id()\n        frame_info.inner_calls = defaultdict(list)\n        prev = self.stack.get(enter_info.caller_frame)\n        if prev:\n            inner_calls = getattr(prev, 'inner_calls', None)\n            if inner_calls is not None:\n                inner_calls[enter_info.call_node].append(frame_info.call_id)\n\n    def _call_id(self):\n        # type: () -> Text\n        return uuid4().hex\n\n    def exit_call(self, exit_info):\n        # type: (ExitCallInfo) -> None\n        \"\"\"\n        This is where all the data collected during the call is gathered up\n        and sent to the database.\n        \"\"\"\n        frame = exit_info.current_frame  # type: FrameType\n        if frame.f_code not in self._code_infos or _tracing_recursively(frame):\n            return\n        frame_info = self.stack[frame]\n\n        top_iteration = frame_info.iteration  # type: Iteration\n        node_values = _deep_dict()\n        self._extract_node_values(top_iteration, (), node_values)\n\n        db_func = self._code_infos[frame.f_code].db_func\n        exc = exit_info.exc_value  # type: Optional[Exception]\n        if exc:\n            traceback_str = ''.join(traceback.format_exception(type(exc), exc, exit_info.exc_tb))\n            exception = exception_string(exc)\n        else:\n            traceback_str = exception = None\n\n        @retry_db\n        def add_call():\n            Call = self.db.Call\n            call = Call(id=frame_info.call_id,\n                        function_id=db_func,\n                        arguments=frame_info.arguments,\n                        return_value=cheap_repr(exit_info.return_value),\n                        exception=exception,\n                        traceback=traceback_str,\n                        data=json.dumps(\n                            dict(\n                                node_values=node_values,\n                                loop_iterations=top_iteration.extract_iterations()['loops'],\n                                type_names=type_registry.names(),\n                                num_special_types=type_registry.num_special_types,\n                            ),\n                            cls=ProtocolEncoder,\n                            separators=(',', ':')\n                        ),\n                        start_time=frame_info.start_time)\n            with self.db.session_scope() as session:\n                session.add(call)\n\n        add_call()\n\n        self._last_call_id = frame_info.call_id\n\n    def _extract_node_values(self, iteration, path, node_values):\n        # type: (Iteration, Tuple[int, ...], dict) -> None\n        \"\"\"\n        Populates node_values with values inside iteration.\n        \"\"\"\n        # Each element of `path` is an index of a loop iteration\n        # e.g. given the nested loops:\n        #\n        # for i in [0, 1, 2]:\n        #     for j in [0, 1, 2, 3]:\n        #\n        # path may be (i, j) for each of the iterations\n        for tree_index, node_value in iteration.vals.items():\n\n            # So this `full_path` is a tuple of ints, but the first\n            # int has a different meaning from the others\n            full_path = (tree_index,) + path\n\n            # Given a path (a, b, c) we're making node_values 'contain'\n            # this structure:\n            # {a: {b: {c: node_value}}}\n            d = node_values\n            for path_k in full_path[:-1]:\n                d = d[path_k]\n            d[full_path[-1]] = node_value\n\n        for loop in iteration.loops.values():\n            for i, iteration in enumerate(loop):\n                self._extract_node_values(iteration, path + (i,), node_values)\n\n    def trace_function(self, func):\n        # type: (FunctionType) -> FunctionType\n        new_func = super(BirdsEye, self).trace_function(func)\n        code_info = self._code_infos.get(new_func.__code__)\n        if code_info:\n            return new_func\n\n        lines, start_lineno = inspect.getsourcelines(func)  # type: List[Text], int\n        end_lineno = start_lineno + len(lines)\n        name = safe_qualname(func)\n        source_file = inspect.getsourcefile(func)\n        if source_file.startswith('<ipython-input'):\n            filename = IPYTHON_FILE_PATH\n        else:\n            filename = os.path.abspath(source_file)\n        traced_file = new_func.traced_file\n\n        arg_info = inspect.getargs(new_func.__code__)\n        arg_names = list(chain(flatten_list(arg_info[0]), arg_info[1:]))  # type: List[str]\n        self._trace(name, filename, traced_file, new_func.__code__, typ='function',\n                    start_lineno=start_lineno, end_lineno=end_lineno,\n                    arg_names=arg_names)\n\n        return new_func\n\n    def exec_ipython_cell(self, source, callback):\n        from IPython import get_ipython\n        shell = get_ipython()\n        filename = name = shell.compile.cache(source)\n        flags = shell.compile.flags\n\n        traced_file = self.compile(source, filename, flags)\n        traced_file.is_ipython_cell = True\n\n        for node in traced_file.root.body:\n            if is_future_import(node):\n                raise ValueError('from __future__ import ... statements '\n                                 'are not allowed in cells traced with %%eye')\n\n        shell.user_global_ns.update(self._trace_methods_dict(traced_file))\n\n        self._trace(name, filename, traced_file, traced_file.code, 'module', source)\n\n        try:\n            shell.ex(traced_file.code)\n            return self._ipython_cell_value\n        finally:\n            callback(self._last_call_id)\n            self._ipython_cell_value = None\n\n    def trace_this_module(self, context=0, deep=False):\n        frame = inspect.currentframe()\n\n        filename = None\n        while context >= 0:\n            frame = frame.f_back\n            filename = inspect.getsourcefile(frame)\n            if filename is not None:\n                context -= 1\n        filename = os.path.abspath(filename)\n\n        if frame.f_globals.get('__name__') != '__main__':\n            if PY3 and self._treetrace_hidden_with_stmt.__name__ not in frame.f_globals:\n                raise RuntimeError(\n                    'To trace an imported module, you must import birdseye before '\n                    'importing that module.')\n            return\n\n        lines = read_source_file(filename).splitlines()\n        lines[:frame.f_lineno] = [''] * frame.f_lineno\n        source = '\\n'.join(lines)\n        self.exec_string(source, filename, frame.f_globals, frame.f_locals, deep)\n        sys.exit(0)\n\n    def exec_string(self, source, filename, globs=None, locs=None, deep=False):\n        globs = globs or {}\n        locs = locs or {}\n\n        traced_file = self.compile(source, filename)\n\n        globs.update(self._trace_methods_dict(traced_file))\n\n        self._trace(FILE_SENTINEL_NAME, filename, traced_file, traced_file.code, 'module', source)\n\n        if deep:\n            nodes_by_lineno = {\n                node.lineno: node\n                for node in traced_file.nodes\n                if isinstance(node, ast.FunctionDef)\n            }\n\n            def find_code(root_code):\n                # type: (CodeType) -> None\n                for code in root_code.co_consts:  # type: CodeType\n                    if not inspect.iscode(code) or code.co_name.startswith('<'):\n                        continue\n\n                    find_code(code)\n\n                    lineno = code.co_firstlineno\n                    node = nodes_by_lineno.get(lineno)\n                    if not node:\n                        continue\n\n                    self._trace(\n                        code.co_name, filename, traced_file, code,\n                        typ='function',\n                        source=source,\n                        start_lineno=lineno,\n                        end_lineno=node.last_token.end[0] + 1,\n                    )\n\n            find_code(traced_file.code)\n\n        exec(traced_file.code, globs, locs)\n\n    def _trace(\n            self,\n            name,\n            filename,\n            traced_file,\n            code,\n            typ,\n            source='',\n            start_lineno=1,\n            end_lineno=None,\n            arg_names=(),\n    ):\n        if not end_lineno:\n            end_lineno = start_lineno + len(source.splitlines())\n        nodes = list(self._nodes_of_interest(traced_file, start_lineno, end_lineno))\n        html_body = self._nodes_html(nodes, start_lineno, end_lineno, traced_file)\n\n        data_dict = dict(\n            # This maps each node to the loops enclosing that node\n            node_loops={\n                node._tree_index: [n._tree_index for n in node._loops]\n                for node, _ in nodes\n                if node._loops\n            },\n        )\n        if typ == 'function':\n            tokens = traced_file.tokens\n            func_node = only(node\n                             for node, _ in nodes\n                             if isinstance(node, ast.FunctionDef)\n                             and node.first_token.start[0] == start_lineno)\n            func_startpos, source = source_without_decorators(tokens, func_node)\n            # These are for the PyCharm plugin\n            data_dict.update(\n                node_ranges=list(self._node_ranges(nodes, tokens, func_startpos)),\n                loop_ranges=list(self._loop_ranges(nodes, tokens, func_startpos)),\n            )\n\n        data = json.dumps(data_dict, sort_keys=True)\n        db_func = self._db_func(data, filename, html_body, name, start_lineno, source, typ)\n        self._code_infos[code] = CodeInfo(db_func, traced_file, arg_names)\n\n    def _loop_ranges(self, nodes, tokens, func_start):\n        # For a for loop, e.g.\n        #\n        #     for x in y:\n        #\n        # this yields the range of the target 'x'.\n        #\n        # For a while loop, e.g.\n        #\n        #     while x < 10:\n        #\n        # this yields the range of the condition 'x < 10'.\n        for node, (classes, _, __) in nodes:\n            if 'loop' not in classes:\n                continue\n\n            try:\n                target = node.target  # for loop\n            except AttributeError:\n                target = node.test  # while loop\n\n            start, end = tokens.get_text_range(target)\n            start -= func_start\n            end -= func_start\n\n            yield dict(\n                tree_index=node._tree_index,\n                start=start,\n                end=end\n            )\n\n    def _node_ranges(self, nodes, tokens, func_start):\n        for node, (classes, _, __) in nodes:\n            start, end = tokens.get_text_range(node)\n            start -= func_start\n            end -= func_start\n\n            if start < 0:\n                assert (end < 0  # nodes before the def, i.e. decorators\n                        or isinstance(node, ast.FunctionDef))\n                continue\n\n            yield dict(\n                tree_index=node._tree_index,\n                start=start,\n                end=end,\n                depth=node._depth,\n                classes=classes,\n            )\n\n    @retry_db\n    def _db_func(self, data, filename, html_body, name, start_lineno, source, typ):\n        \"\"\"\n        Retrieve the Function object from the database if one exists, or create one.\n        \"\"\"\n\n        def h(s):\n            return hashlib.sha256(s.encode('utf8')).hexdigest()\n\n        function_hash = h(filename + name + html_body + data + str(start_lineno))\n\n        Function = self.db.Function\n\n        with self.db.session_scope() as session:\n            db_func = one_or_none(session.query(Function).filter_by(hash=function_hash))  # type: Optional[Function]\n            if not db_func:\n                db_func = Function(file=filename,\n                                   name=name,\n                                   type=typ,\n                                   html_body=html_body,\n                                   lineno=start_lineno,\n                                   data=data,\n                                   body_hash=h(source),\n                                   hash=function_hash)\n                session.add(db_func)\n                session.commit()  # ensure .id exists\n            assert isinstance(db_func.id, int)\n            return db_func.id\n\n    def _nodes_of_interest(self, traced_file, start_lineno, end_lineno):\n        # type: (TracedFile, int, int) -> Iterator[Tuple[ast.AST, Tuple]]\n        \"\"\"\n        Nodes that may have a value, show up as a box in the UI, and lie within the\n        given line range.\n        \"\"\"\n        for node in traced_file.nodes:\n            classes = []\n\n            if (isinstance(node, (ast.While, ast.For, ast.comprehension)) and\n                    not isinstance(node.parent, ast.GeneratorExp)):\n                classes.append('loop')\n            if isinstance(node, ast.stmt):\n                classes.append('stmt')\n\n            if isinstance(node, ast.expr):\n                if not node._is_interesting_expression:\n                    continue\n            elif not classes:\n                continue\n\n            assert isinstance(node, ast.AST)\n\n            # In particular FormattedValue is missing this\n            if not hasattr(node, 'first_token'):\n                continue\n\n            if not start_lineno <= node.first_token.start[0] <= end_lineno:\n                continue\n\n            start, end = traced_file.tokens.get_text_range(node)  # type: int, int\n            if start == end == 0:\n                continue\n\n            yield node, (classes, start, end)\n\n    def _nodes_html(self, nodes, start_lineno, end_lineno, traced_file):\n        # type: (list, int, int, TracedFile) -> str\n        \"\"\"\n        The algorithm for generating the HTML works as follows. We generate a list\n        of HTMLPositions, which are essentially places to insert HTML into the source plus some\n        metadata. The order of the fields of HTMLPosition ensure that when the list is sorted,\n        the resulting HTML is valid and correct. Specifically, the fields are:\n        \n          1. index: the index in the source string where the HTML would be inserted\n          2. is_start: Indicates if this piece of HTML is the start of a tag, rather than the end.\n             Ends should appear first, so that the resulting HTML looks like:\n                <span> ... </span><span> ... </span>\n             rather than:\n                <span> ... <span></span> ... </span>\n             (I think this might actually be unnecessary, since I can't think of any cases of two\n              expressions right next to each other with nothing in between)\n          3. depth: the depth of the corresponding node in the AST. We want the start of a tag from\n             a node to appear before the start of a tag nested within, e.g. `foo()` should become:\n                <span [for foo()]><span [for foo]>foo</span>()</span>\n             rather than:   \n                <span [for foo]><span [for foo()]>foo</span>()</span>\n          4. html: the actual HTML to insert. Not important for ordering.\n          \n        Mostly the list contains pairs of HTMLPositions corresponding to AST nodes, one for the\n        start and one for the end.\n        \n        After the list is sorted, the HTML generated is essentially:\n        \n        source[0:positions[0].index] + positions[0].html + source[positions[0].index:positions[1].index] + positions[1].html + ...\n        \"\"\"\n\n        traced_file.root._depth = 0\n        for node in ast.walk(traced_file.root):  # type: ast.AST\n            for child in ast.iter_child_nodes(node):\n                child._depth = node._depth + 1\n\n        positions = []  # type: List[HTMLPosition]\n\n        for node, (classes, start, end) in nodes:\n            # noinspection PyArgumentList\n            positions.extend(map(\n                HTMLPosition,\n                [start, end],\n                [True, False],  # is_start\n                [node._depth, node._depth],\n                ['<span data-index=\"%s\" class=\"%s\">' % (node._tree_index, ' '.join(classes)),\n                 '</span>']))\n\n        end_lineno = self._separate_comprehensions(\n            [n[0] for n in nodes],\n            end_lineno, positions, traced_file)\n\n        # This just makes the loop below simpler\n        positions.append(HTMLPosition(len(traced_file.source), False, 0, ''))\n\n        positions.sort()\n\n        html_parts = []\n        start = 0\n        for position in positions:\n            html_parts.append(html.escape(traced_file.source[start:position.index]))\n            html_parts.append(position.html)\n            start = position.index\n        html_body = ''.join(html_parts)\n        html_body = '\\n'.join(html_body.split('\\n')[start_lineno - 1:end_lineno - 1])\n\n        return html_body.strip('\\n')\n\n    def _separate_comprehensions(self, nodes, end_lineno, positions, traced_file):\n        # type: (list, int, List[HTMLPosition], TracedFile) -> int\n        \"\"\"\n        Comprehensions (e.g. list comprehensions) are troublesome because they can\n        be navigated like loops, and the buttons for these need to be on separate lines.\n        This function inserts newlines to turn:\n\n        [x + y for x in range(3) for y in range(5)] and\n        [[x + y for x in range(3)] for y in range(5)]\n\n        into\n\n        [x + y for x in range(3)\n         for y in range(5)] and\n        [[x + y for x in range(3)]\n         for y in range(5)]\n        \"\"\"\n\n        comprehensions = group_by_key_func(of_type((ast.comprehension, ast.While, ast.For), nodes),\n                                           lambda c: c.first_token.start[0]\n                                           )  # type: Dict[Any, Iterable[ast.comprehension]]\n\n        def get_start(n):\n            # type: (ast.AST) -> int\n            return traced_file.tokens.get_text_range(n)[0]\n\n        for comp_list in comprehensions.values():\n            prev_start = None  # type: Optional[int]\n            for comp in sorted(comp_list, key=lambda c: c.first_token.startpos):\n                if isinstance(comp, ast.comprehension) and comp is comp.parent.generators[0]:\n                    start = get_start(comp.parent)\n                    if prev_start is not None and start < prev_start:\n                        start = get_start(comp)\n                else:\n                    start = get_start(comp)\n                if prev_start is not None:\n                    positions.append(HTMLPosition(start, True, 0, '\\n '))\n                    end_lineno += 1\n                prev_start = start\n\n        return end_lineno"
    ],
    [
        "STORE_NAME",
        "class BirdsEye(TreeTracerBase):\n    \"\"\"\n    Decorate functions with an instance of this class to debug them,\n    or just use the existing instance `eye`.\n    \"\"\"\n\n    def __init__(self, db_uri=None, num_samples=None):\n        \"\"\"\n        Set db_uri to specify where the database lives, as an alternative to\n        the environment variable BIRDSEYE_DB.\n        \"\"\"\n        super(BirdsEye, self).__init__()\n        self._db_uri = db_uri\n        self._code_infos = {}  # type: Dict[CodeType, CodeInfo]\n        self._last_call_id = None\n        self._ipython_cell_value = None\n        self.num_samples = num_samples or dict(\n            big=dict(\n                attributes=50,\n                dict=50,\n                list=30,\n                set=30,\n                pandas_rows=20,\n                pandas_cols=100,\n            ),\n            small=dict(\n                attributes=50,\n                dict=10,\n                list=6,\n                set=6,\n                pandas_rows=6,\n                pandas_cols=10,\n            ),\n        )\n\n    @cached_property\n    def db(self):\n        return Database(self._db_uri)\n\n    def parse_extra(self, root, source, filename):\n        # type: (ast.Module, str, str) -> None\n        for node in ast.walk(root):  # type: ast.AST\n            node._loops = tracer.loops(node)\n            if isinstance(node, ast.expr):\n                node._is_interesting_expression = is_interesting_expression(node)\n\n    @lru_cache()\n    def compile(self, source, filename, flags=0):\n        traced_file = super(BirdsEye, self).compile(source, filename, flags)\n        traced_file.tokens = ASTTokens(source, tree=traced_file.root)\n        return traced_file\n\n    def before_stmt(self, node, frame):\n        # type: (ast.stmt, FrameType) -> None\n        if frame.f_code not in self._code_infos:\n            return\n        if isinstance(node.parent, ast.For) and node is node.parent.body[0]:\n            self._add_iteration(node._loops, frame)\n\n    def before_expr(self, node, frame):\n        if isinstance(node.parent, ast.While) and node is node.parent.test:\n            self._add_iteration(node._loops, frame)\n\n    def _add_iteration(self, loops, frame):\n        # type: (typing.Sequence[Loop], FrameType) -> None\n        \"\"\"\n        Given one or more nested loops, add an iteration for the innermost\n        loop (the last in the sequence).\n        \"\"\"\n        iteration = self.stack[frame].iteration  # type: Iteration\n        for i, loop_node in enumerate(loops):\n            loop = iteration.loops[loop_node._tree_index]\n            if i == len(loops) - 1:\n                loop.append(Iteration())\n            else:\n                iteration = loop.last()\n\n    def after_expr(self, node, frame, value, exc_value, exc_tb):\n        # type: (ast.expr, FrameType, Any, Optional[BaseException], Optional[TracebackType]) -> Optional[ChangeValue]\n\n        if _tracing_recursively(frame):\n            return None\n\n        if frame.f_code not in self._code_infos:\n            return None\n\n        if node._is_interesting_expression:\n            # If this is an expression statement and the last statement\n            # in the body, the value is returned from the cell magic\n            # to be displayed as usual\n            if (self._code_infos[frame.f_code].traced_file.is_ipython_cell\n                    and isinstance(node.parent, ast.Expr)\n                    and node.parent is node.parent.parent.body[-1]):\n                self._ipython_cell_value = value\n\n            if is_obvious_builtin(node, self.stack[frame].expression_values[node]):\n                return None\n\n            frame_info = self.stack[frame]\n            if exc_value:\n                node_value = self._exception_value(node, frame, exc_value)\n            else:\n                node_value = NodeValue.expression(\n                    self.num_samples,\n                    value,\n                    level=max(1, 3 - len(node._loops) * (not self._is_first_loop_iteration(node, frame))),\n                )\n                self._set_node_value(node, frame, node_value)\n            self._check_inner_call(frame_info, node, node_value)\n\n        # i.e. is `node` the `y` in `[f(x) for x in y]`, making `node.parent` the `for x in y`\n        is_special_comprehension_iter = (\n                isinstance(node.parent, ast.comprehension) and\n                node is node.parent.iter and\n\n                # Generators execute in their own time and aren't directly attached to the parent frame\n                not isinstance(node.parent.parent, ast.GeneratorExp))\n\n        if not is_special_comprehension_iter:\n            return None\n\n        # Mark `for x in y` as a bit that executed, so it doesn't show as grey\n        self._set_node_value(node.parent, frame, NodeValue.covered())\n\n        if exc_value:\n            return None\n\n        # Track each iteration over `y` so that the 'loop' can be stepped through\n        loops = node._loops + (node.parent,)  # type: Tuple[Loop, ...]\n\n        def comprehension_iter_proxy():\n            for item in value:\n                self._add_iteration(loops, frame)\n                yield item\n\n        # This effectively changes to code to `for x in comprehension_iter_proxy()`\n        return ChangeValue(comprehension_iter_proxy())\n\n    def _check_inner_call(self, frame_info, node, node_value):\n        # type: (FrameInfo, Union[ast.stmt, ast.expr], NodeValue) -> None\n        inner_calls = frame_info.inner_calls.pop(node, None)\n        if inner_calls:\n            node_value.set_meta('inner_calls', inner_calls)\n\n    def _is_first_loop_iteration(self, node, frame):\n        # type: (ast.AST, FrameType) -> bool\n        iteration = self.stack[frame].iteration  # type: Iteration\n        for loop_node in node._loops:  # type: ast.AST\n            loop = iteration.loops[loop_node._tree_index]\n            iteration = loop.last()\n            if iteration.index > 0:\n                return False\n        return True\n\n    def _set_node_value(self, node, frame, value):\n        # type: (ast.AST, FrameType, NodeValue) -> None\n        iteration = self.stack[frame].iteration  # type: Iteration\n        for loop_node in node._loops:  # type: ast.AST\n            loop = iteration.loops[loop_node._tree_index]\n            loop.recorded_node(node)\n            iteration = loop.last()\n        iteration.vals[node._tree_index] = value\n\n    def _exception_value(self, node, frame, exc_value):\n        # type: (Union[ast.expr, ast.stmt], FrameType, BaseException) -> NodeValue\n        value = NodeValue.exception(exc_value)\n        self._set_node_value(node, frame, value)\n        return value\n\n    def after_stmt(self, node, frame, exc_value, exc_traceback, exc_node):\n        # type: (ast.stmt, FrameType, Optional[BaseException], Optional[TracebackType], Optional[ast.AST]) -> Optional[bool]\n        if frame.f_code not in self._code_infos or _tracing_recursively(frame):\n            return None\n        if exc_value and node is exc_node:\n            value = self._exception_value(node, frame, exc_value)\n        else:\n            value = NodeValue.covered()\n            self._set_node_value(node, frame, value)\n        self._check_inner_call(self.stack[frame], node, value)\n        return None\n\n    def enter_call(self, enter_info):\n        # type: (EnterCallInfo) -> None\n        frame = enter_info.current_frame  # type: FrameType\n        if frame.f_code not in self._code_infos or _tracing_recursively(frame):\n            return\n        frame_info = self.stack[frame]\n        frame_info.start_time = get_unfrozen_datetime()\n        frame_info.iteration = Iteration()\n\n        code_info = self._code_infos[frame.f_code]\n        if isinstance(enter_info.enter_node.parent, ast.Module):\n            arguments = []\n        else:\n            f_locals = frame.f_locals.copy()  # type: Dict[str, Any]\n            arguments = [(name, f_locals.pop(name))\n                         for name in code_info.arg_names\n                         if name] + [\n\n                            # Local variables other than actual arguments. These are variables from\n                            # the enclosing scope. It's handy to treat them like arguments in the UI\n                            it for it in f_locals.items()\n                            if it[0][0] != '.'  # Appears when using nested tuple arguments\n                        ]\n        frame_info.arguments = json.dumps([[k, cheap_repr(v)] for k, v in arguments])\n        frame_info.call_id = self._call_id()\n        frame_info.inner_calls = defaultdict(list)\n        prev = self.stack.get(enter_info.caller_frame)\n        if prev:\n            inner_calls = getattr(prev, 'inner_calls', None)\n            if inner_calls is not None:\n                inner_calls[enter_info.call_node].append(frame_info.call_id)\n\n    def _call_id(self):\n        # type: () -> Text\n        return uuid4().hex\n\n    def exit_call(self, exit_info):\n        # type: (ExitCallInfo) -> None\n        \"\"\"\n        This is where all the data collected during the call is gathered up\n        and sent to the database.\n        \"\"\"\n        frame = exit_info.current_frame  # type: FrameType\n        if frame.f_code not in self._code_infos or _tracing_recursively(frame):\n            return\n        frame_info = self.stack[frame]\n\n        top_iteration = frame_info.iteration  # type: Iteration\n        node_values = _deep_dict()\n        self._extract_node_values(top_iteration, (), node_values)\n\n        db_func = self._code_infos[frame.f_code].db_func\n        exc = exit_info.exc_value  # type: Optional[Exception]\n        if exc:\n            traceback_str = ''.join(traceback.format_exception(type(exc), exc, exit_info.exc_tb))\n            exception = exception_string(exc)\n        else:\n            traceback_str = exception = None\n\n        @retry_db\n        def add_call():\n            Call = self.db.Call\n            call = Call(id=frame_info.call_id,\n                        function_id=db_func,\n                        arguments=frame_info.arguments,\n                        return_value=cheap_repr(exit_info.return_value),\n                        exception=exception,\n                        traceback=traceback_str,\n                        data=json.dumps(\n                            dict(\n                                node_values=node_values,\n                                loop_iterations=top_iteration.extract_iterations()['loops'],\n                                type_names=type_registry.names(),\n                                num_special_types=type_registry.num_special_types,\n                            ),\n                            cls=ProtocolEncoder,\n                            separators=(',', ':')\n                        ),\n                        start_time=frame_info.start_time)\n            with self.db.session_scope() as session:\n                session.add(call)\n\n        add_call()\n\n        self._last_call_id = frame_info.call_id\n\n    def _extract_node_values(self, iteration, path, node_values):\n        # type: (Iteration, Tuple[int, ...], dict) -> None\n        \"\"\"\n        Populates node_values with values inside iteration.\n        \"\"\"\n        # Each element of `path` is an index of a loop iteration\n        # e.g. given the nested loops:\n        #\n        # for i in [0, 1, 2]:\n        #     for j in [0, 1, 2, 3]:\n        #\n        # path may be (i, j) for each of the iterations\n        for tree_index, node_value in iteration.vals.items():\n\n            # So this `full_path` is a tuple of ints, but the first\n            # int has a different meaning from the others\n            full_path = (tree_index,) + path\n\n            # Given a path (a, b, c) we're making node_values 'contain'\n            # this structure:\n            # {a: {b: {c: node_value}}}\n            d = node_values\n            for path_k in full_path[:-1]:\n                d = d[path_k]\n            d[full_path[-1]] = node_value\n\n        for loop in iteration.loops.values():\n            for i, iteration in enumerate(loop):\n                self._extract_node_values(iteration, path + (i,), node_values)\n\n    def trace_function(self, func):\n        # type: (FunctionType) -> FunctionType\n        new_func = super(BirdsEye, self).trace_function(func)\n        code_info = self._code_infos.get(new_func.__code__)\n        if code_info:\n            return new_func\n\n        lines, start_lineno = inspect.getsourcelines(func)  # type: List[Text], int\n        end_lineno = start_lineno + len(lines)\n        name = safe_qualname(func)\n        source_file = inspect.getsourcefile(func)\n        if source_file.startswith('<ipython-input'):\n            filename = IPYTHON_FILE_PATH\n        else:\n            filename = os.path.abspath(source_file)\n        traced_file = new_func.traced_file\n\n        arg_info = inspect.getargs(new_func.__code__)\n        arg_names = list(chain(flatten_list(arg_info[0]), arg_info[1:]))  # type: List[str]\n        self._trace(name, filename, traced_file, new_func.__code__, typ='function',\n                    start_lineno=start_lineno, end_lineno=end_lineno,\n                    arg_names=arg_names)\n\n        return new_func\n\n    def exec_ipython_cell(self, source, callback):\n        from IPython import get_ipython\n        shell = get_ipython()\n        filename = name = shell.compile.cache(source)\n        flags = shell.compile.flags\n\n        traced_file = self.compile(source, filename, flags)\n        traced_file.is_ipython_cell = True\n\n        for node in traced_file.root.body:\n            if is_future_import(node):\n                raise ValueError('from __future__ import ... statements '\n                                 'are not allowed in cells traced with %%eye')\n\n        shell.user_global_ns.update(self._trace_methods_dict(traced_file))\n\n        self._trace(name, filename, traced_file, traced_file.code, 'module', source)\n\n        try:\n            shell.ex(traced_file.code)\n            return self._ipython_cell_value\n        finally:\n            callback(self._last_call_id)\n            self._ipython_cell_value = None\n\n    def trace_this_module(self, context=0, deep=False):\n        frame = inspect.currentframe()\n\n        filename = None\n        while context >= 0:\n            frame = frame.f_back\n            filename = inspect.getsourcefile(frame)\n            if filename is not None:\n                context -= 1\n        filename = os.path.abspath(filename)\n\n        if frame.f_globals.get('__name__') != '__main__':\n            if PY3 and self._treetrace_hidden_with_stmt.__name__ not in frame.f_globals:\n                raise RuntimeError(\n                    'To trace an imported module, you must import birdseye before '\n                    'importing that module.')\n            return\n\n        lines = read_source_file(filename).splitlines()\n        lines[:frame.f_lineno] = [''] * frame.f_lineno\n        source = '\\n'.join(lines)\n        self.exec_string(source, filename, frame.f_globals, frame.f_locals, deep)\n        sys.exit(0)\n\n    def exec_string(self, source, filename, globs=None, locs=None, deep=False):\n        globs = globs or {}\n        locs = locs or {}\n\n        traced_file = self.compile(source, filename)\n\n        globs.update(self._trace_methods_dict(traced_file))\n\n        self._trace(FILE_SENTINEL_NAME, filename, traced_file, traced_file.code, 'module', source)\n\n        if deep:\n            nodes_by_lineno = {\n                node.lineno: node\n                for node in traced_file.nodes\n                if isinstance(node, ast.FunctionDef)\n            }\n\n            def find_code(root_code):\n                # type: (CodeType) -> None\n                for code in root_code.co_consts:  # type: CodeType\n                    if not inspect.iscode(code) or code.co_name.startswith('<'):\n                        continue\n\n                    find_code(code)\n\n                    lineno = code.co_firstlineno\n                    node = nodes_by_lineno.get(lineno)\n                    if not node:\n                        continue\n\n                    self._trace(\n                        code.co_name, filename, traced_file, code,\n                        typ='function',\n                        source=source,\n                        start_lineno=lineno,\n                        end_lineno=node.last_token.end[0] + 1,\n                    )\n\n            find_code(traced_file.code)\n\n        exec(traced_file.code, globs, locs)\n\n    def _trace(\n            self,\n            name,\n            filename,\n            traced_file,\n            code,\n            typ,\n            source='',\n            start_lineno=1,\n            end_lineno=None,\n            arg_names=(),\n    ):\n        if not end_lineno:\n            end_lineno = start_lineno + len(source.splitlines())\n        nodes = list(self._nodes_of_interest(traced_file, start_lineno, end_lineno))\n        html_body = self._nodes_html(nodes, start_lineno, end_lineno, traced_file)\n\n        data_dict = dict(\n            # This maps each node to the loops enclosing that node\n            node_loops={\n                node._tree_index: [n._tree_index for n in node._loops]\n                for node, _ in nodes\n                if node._loops\n            },\n        )\n        if typ == 'function':\n            tokens = traced_file.tokens\n            func_node = only(node\n                             for node, _ in nodes\n                             if isinstance(node, ast.FunctionDef)\n                             and node.first_token.start[0] == start_lineno)\n            func_startpos, source = source_without_decorators(tokens, func_node)\n            # These are for the PyCharm plugin\n            data_dict.update(\n                node_ranges=list(self._node_ranges(nodes, tokens, func_startpos)),\n                loop_ranges=list(self._loop_ranges(nodes, tokens, func_startpos)),\n            )\n\n        data = json.dumps(data_dict, sort_keys=True)\n        db_func = self._db_func(data, filename, html_body, name, start_lineno, source, typ)\n        self._code_infos[code] = CodeInfo(db_func, traced_file, arg_names)\n\n    def _loop_ranges(self, nodes, tokens, func_start):\n        # For a for loop, e.g.\n        #\n        #     for x in y:\n        #\n        # this yields the range of the target 'x'.\n        #\n        # For a while loop, e.g.\n        #\n        #     while x < 10:\n        #\n        # this yields the range of the condition 'x < 10'.\n        for node, (classes, _, __) in nodes:\n            if 'loop' not in classes:\n                continue\n\n            try:\n                target = node.target  # for loop\n            except AttributeError:\n                target = node.test  # while loop\n\n            start, end = tokens.get_text_range(target)\n            start -= func_start\n            end -= func_start\n\n            yield dict(\n                tree_index=node._tree_index,\n                start=start,\n                end=end\n            )\n\n    def _node_ranges(self, nodes, tokens, func_start):\n        for node, (classes, _, __) in nodes:\n            start, end = tokens.get_text_range(node)\n            start -= func_start\n            end -= func_start\n\n            if start < 0:\n                assert (end < 0  # nodes before the def, i.e. decorators\n                        or isinstance(node, ast.FunctionDef))\n                continue\n\n            yield dict(\n                tree_index=node._tree_index,\n                start=start,\n                end=end,\n                depth=node._depth,\n                classes=classes,\n            )\n\n    @retry_db\n    def _db_func(self, data, filename, html_body, name, start_lineno, source, typ):\n        \"\"\"\n        Retrieve the Function object from the database if one exists, or create one.\n        \"\"\"\n\n        def h(s):\n            return hashlib.sha256(s.encode('utf8')).hexdigest()\n\n        function_hash = h(filename + name + html_body + data + str(start_lineno))\n\n        Function = self.db.Function\n\n        with self.db.session_scope() as session:\n            db_func = one_or_none(session.query(Function).filter_by(hash=function_hash))  # type: Optional[Function]\n            if not db_func:\n                db_func = Function(file=filename,\n                                   name=name,\n                                   type=typ,\n                                   html_body=html_body,\n                                   lineno=start_lineno,\n                                   data=data,\n                                   body_hash=h(source),\n                                   hash=function_hash)\n                session.add(db_func)\n                session.commit()  # ensure .id exists\n            assert isinstance(db_func.id, int)\n            return db_func.id\n\n    def _nodes_of_interest(self, traced_file, start_lineno, end_lineno):\n        # type: (TracedFile, int, int) -> Iterator[Tuple[ast.AST, Tuple]]\n        \"\"\"\n        Nodes that may have a value, show up as a box in the UI, and lie within the\n        given line range.\n        \"\"\"\n        for node in traced_file.nodes:\n            classes = []\n\n            if (isinstance(node, (ast.While, ast.For, ast.comprehension)) and\n                    not isinstance(node.parent, ast.GeneratorExp)):\n                classes.append('loop')\n            if isinstance(node, ast.stmt):\n                classes.append('stmt')\n\n            if isinstance(node, ast.expr):\n                if not node._is_interesting_expression:\n                    continue\n            elif not classes:\n                continue\n\n            assert isinstance(node, ast.AST)\n\n            # In particular FormattedValue is missing this\n            if not hasattr(node, 'first_token'):\n                continue\n\n            if not start_lineno <= node.first_token.start[0] <= end_lineno:\n                continue\n\n            start, end = traced_file.tokens.get_text_range(node)  # type: int, int\n            if start == end == 0:\n                continue\n\n            yield node, (classes, start, end)\n\n    def _nodes_html(self, nodes, start_lineno, end_lineno, traced_file):\n        # type: (list, int, int, TracedFile) -> str\n        \"\"\"\n        The algorithm for generating the HTML works as follows. We generate a list\n        of HTMLPositions, which are essentially places to insert HTML into the source plus some\n        metadata. The order of the fields of HTMLPosition ensure that when the list is sorted,\n        the resulting HTML is valid and correct. Specifically, the fields are:\n        \n          1. index: the index in the source string where the HTML would be inserted\n          2. is_start: Indicates if this piece of HTML is the start of a tag, rather than the end.\n             Ends should appear first, so that the resulting HTML looks like:\n                <span> ... </span><span> ... </span>\n             rather than:\n                <span> ... <span></span> ... </span>\n             (I think this might actually be unnecessary, since I can't think of any cases of two\n              expressions right next to each other with nothing in between)\n          3. depth: the depth of the corresponding node in the AST. We want the start of a tag from\n             a node to appear before the start of a tag nested within, e.g. `foo()` should become:\n                <span [for foo()]><span [for foo]>foo</span>()</span>\n             rather than:   \n                <span [for foo]><span [for foo()]>foo</span>()</span>\n          4. html: the actual HTML to insert. Not important for ordering.\n          \n        Mostly the list contains pairs of HTMLPositions corresponding to AST nodes, one for the\n        start and one for the end.\n        \n        After the list is sorted, the HTML generated is essentially:\n        \n        source[0:positions[0].index] + positions[0].html + source[positions[0].index:positions[1].index] + positions[1].html + ...\n        \"\"\"\n\n        traced_file.root._depth = 0\n        for node in ast.walk(traced_file.root):  # type: ast.AST\n            for child in ast.iter_child_nodes(node):\n                child._depth = node._depth + 1\n\n        positions = []  # type: List[HTMLPosition]\n\n        for node, (classes, start, end) in nodes:\n            # noinspection PyArgumentList\n            positions.extend(map(\n                HTMLPosition,\n                [start, end],\n                [True, False],  # is_start\n                [node._depth, node._depth],\n                ['<span data-index=\"%s\" class=\"%s\">' % (node._tree_index, ' '.join(classes)),\n                 '</span>']))\n\n        end_lineno = self._separate_comprehensions(\n            [n[0] for n in nodes],\n            end_lineno, positions, traced_file)\n\n        # This just makes the loop below simpler\n        positions.append(HTMLPosition(len(traced_file.source), False, 0, ''))\n\n        positions.sort()\n\n        html_parts = []\n        start = 0\n        for position in positions:\n            html_parts.append(html.escape(traced_file.source[start:position.index]))\n            html_parts.append(position.html)\n            start = position.index\n        html_body = ''.join(html_parts)\n        html_body = '\\n'.join(html_body.split('\\n')[start_lineno - 1:end_lineno - 1])\n\n        return html_body.strip('\\n')\n\n    def _separate_comprehensions(self, nodes, end_lineno, positions, traced_file):\n        # type: (list, int, List[HTMLPosition], TracedFile) -> int\n        \"\"\"\n        Comprehensions (e.g. list comprehensions) are troublesome because they can\n        be navigated like loops, and the buttons for these need to be on separate lines.\n        This function inserts newlines to turn:\n\n        [x + y for x in range(3) for y in range(5)] and\n        [[x + y for x in range(3)] for y in range(5)]\n\n        into\n\n        [x + y for x in range(3)\n         for y in range(5)] and\n        [[x + y for x in range(3)]\n         for y in range(5)]\n        \"\"\"\n\n        comprehensions = group_by_key_func(of_type((ast.comprehension, ast.While, ast.For), nodes),\n                                           lambda c: c.first_token.start[0]\n                                           )  # type: Dict[Any, Iterable[ast.comprehension]]\n\n        def get_start(n):\n            # type: (ast.AST) -> int\n            return traced_file.tokens.get_text_range(n)[0]\n\n        for comp_list in comprehensions.values():\n            prev_start = None  # type: Optional[int]\n            for comp in sorted(comp_list, key=lambda c: c.first_token.startpos):\n                if isinstance(comp, ast.comprehension) and comp is comp.parent.generators[0]:\n                    start = get_start(comp.parent)\n                    if prev_start is not None and start < prev_start:\n                        start = get_start(comp)\n                else:\n                    start = get_start(comp)\n                if prev_start is not None:\n                    positions.append(HTMLPosition(start, True, 0, '\\n '))\n                    end_lineno += 1\n                prev_start = start\n\n        return end_lineno"
    ],
    [
        "STORE_NAME",
        "class BirdsEye(TreeTracerBase):\n    \"\"\"\n    Decorate functions with an instance of this class to debug them,\n    or just use the existing instance `eye`.\n    \"\"\"\n\n    def __init__(self, db_uri=None, num_samples=None):\n        \"\"\"\n        Set db_uri to specify where the database lives, as an alternative to\n        the environment variable BIRDSEYE_DB.\n        \"\"\"\n        super(BirdsEye, self).__init__()\n        self._db_uri = db_uri\n        self._code_infos = {}  # type: Dict[CodeType, CodeInfo]\n        self._last_call_id = None\n        self._ipython_cell_value = None\n        self.num_samples = num_samples or dict(\n            big=dict(\n                attributes=50,\n                dict=50,\n                list=30,\n                set=30,\n                pandas_rows=20,\n                pandas_cols=100,\n            ),\n            small=dict(\n                attributes=50,\n                dict=10,\n                list=6,\n                set=6,\n                pandas_rows=6,\n                pandas_cols=10,\n            ),\n        )\n\n    @cached_property\n    def db(self):\n        return Database(self._db_uri)\n\n    def parse_extra(self, root, source, filename):\n        # type: (ast.Module, str, str) -> None\n        for node in ast.walk(root):  # type: ast.AST\n            node._loops = tracer.loops(node)\n            if isinstance(node, ast.expr):\n                node._is_interesting_expression = is_interesting_expression(node)\n\n    @lru_cache()\n    def compile(self, source, filename, flags=0):\n        traced_file = super(BirdsEye, self).compile(source, filename, flags)\n        traced_file.tokens = ASTTokens(source, tree=traced_file.root)\n        return traced_file\n\n    def before_stmt(self, node, frame):\n        # type: (ast.stmt, FrameType) -> None\n        if frame.f_code not in self._code_infos:\n            return\n        if isinstance(node.parent, ast.For) and node is node.parent.body[0]:\n            self._add_iteration(node._loops, frame)\n\n    def before_expr(self, node, frame):\n        if isinstance(node.parent, ast.While) and node is node.parent.test:\n            self._add_iteration(node._loops, frame)\n\n    def _add_iteration(self, loops, frame):\n        # type: (typing.Sequence[Loop], FrameType) -> None\n        \"\"\"\n        Given one or more nested loops, add an iteration for the innermost\n        loop (the last in the sequence).\n        \"\"\"\n        iteration = self.stack[frame].iteration  # type: Iteration\n        for i, loop_node in enumerate(loops):\n            loop = iteration.loops[loop_node._tree_index]\n            if i == len(loops) - 1:\n                loop.append(Iteration())\n            else:\n                iteration = loop.last()\n\n    def after_expr(self, node, frame, value, exc_value, exc_tb):\n        # type: (ast.expr, FrameType, Any, Optional[BaseException], Optional[TracebackType]) -> Optional[ChangeValue]\n\n        if _tracing_recursively(frame):\n            return None\n\n        if frame.f_code not in self._code_infos:\n            return None\n\n        if node._is_interesting_expression:\n            # If this is an expression statement and the last statement\n            # in the body, the value is returned from the cell magic\n            # to be displayed as usual\n            if (self._code_infos[frame.f_code].traced_file.is_ipython_cell\n                    and isinstance(node.parent, ast.Expr)\n                    and node.parent is node.parent.parent.body[-1]):\n                self._ipython_cell_value = value\n\n            if is_obvious_builtin(node, self.stack[frame].expression_values[node]):\n                return None\n\n            frame_info = self.stack[frame]\n            if exc_value:\n                node_value = self._exception_value(node, frame, exc_value)\n            else:\n                node_value = NodeValue.expression(\n                    self.num_samples,\n                    value,\n                    level=max(1, 3 - len(node._loops) * (not self._is_first_loop_iteration(node, frame))),\n                )\n                self._set_node_value(node, frame, node_value)\n            self._check_inner_call(frame_info, node, node_value)\n\n        # i.e. is `node` the `y` in `[f(x) for x in y]`, making `node.parent` the `for x in y`\n        is_special_comprehension_iter = (\n                isinstance(node.parent, ast.comprehension) and\n                node is node.parent.iter and\n\n                # Generators execute in their own time and aren't directly attached to the parent frame\n                not isinstance(node.parent.parent, ast.GeneratorExp))\n\n        if not is_special_comprehension_iter:\n            return None\n\n        # Mark `for x in y` as a bit that executed, so it doesn't show as grey\n        self._set_node_value(node.parent, frame, NodeValue.covered())\n\n        if exc_value:\n            return None\n\n        # Track each iteration over `y` so that the 'loop' can be stepped through\n        loops = node._loops + (node.parent,)  # type: Tuple[Loop, ...]\n\n        def comprehension_iter_proxy():\n            for item in value:\n                self._add_iteration(loops, frame)\n                yield item\n\n        # This effectively changes to code to `for x in comprehension_iter_proxy()`\n        return ChangeValue(comprehension_iter_proxy())\n\n    def _check_inner_call(self, frame_info, node, node_value):\n        # type: (FrameInfo, Union[ast.stmt, ast.expr], NodeValue) -> None\n        inner_calls = frame_info.inner_calls.pop(node, None)\n        if inner_calls:\n            node_value.set_meta('inner_calls', inner_calls)\n\n    def _is_first_loop_iteration(self, node, frame):\n        # type: (ast.AST, FrameType) -> bool\n        iteration = self.stack[frame].iteration  # type: Iteration\n        for loop_node in node._loops:  # type: ast.AST\n            loop = iteration.loops[loop_node._tree_index]\n            iteration = loop.last()\n            if iteration.index > 0:\n                return False\n        return True\n\n    def _set_node_value(self, node, frame, value):\n        # type: (ast.AST, FrameType, NodeValue) -> None\n        iteration = self.stack[frame].iteration  # type: Iteration\n        for loop_node in node._loops:  # type: ast.AST\n            loop = iteration.loops[loop_node._tree_index]\n            loop.recorded_node(node)\n            iteration = loop.last()\n        iteration.vals[node._tree_index] = value\n\n    def _exception_value(self, node, frame, exc_value):\n        # type: (Union[ast.expr, ast.stmt], FrameType, BaseException) -> NodeValue\n        value = NodeValue.exception(exc_value)\n        self._set_node_value(node, frame, value)\n        return value\n\n    def after_stmt(self, node, frame, exc_value, exc_traceback, exc_node):\n        # type: (ast.stmt, FrameType, Optional[BaseException], Optional[TracebackType], Optional[ast.AST]) -> Optional[bool]\n        if frame.f_code not in self._code_infos or _tracing_recursively(frame):\n            return None\n        if exc_value and node is exc_node:\n            value = self._exception_value(node, frame, exc_value)\n        else:\n            value = NodeValue.covered()\n            self._set_node_value(node, frame, value)\n        self._check_inner_call(self.stack[frame], node, value)\n        return None\n\n    def enter_call(self, enter_info):\n        # type: (EnterCallInfo) -> None\n        frame = enter_info.current_frame  # type: FrameType\n        if frame.f_code not in self._code_infos or _tracing_recursively(frame):\n            return\n        frame_info = self.stack[frame]\n        frame_info.start_time = get_unfrozen_datetime()\n        frame_info.iteration = Iteration()\n\n        code_info = self._code_infos[frame.f_code]\n        if isinstance(enter_info.enter_node.parent, ast.Module):\n            arguments = []\n        else:\n            f_locals = frame.f_locals.copy()  # type: Dict[str, Any]\n            arguments = [(name, f_locals.pop(name))\n                         for name in code_info.arg_names\n                         if name] + [\n\n                            # Local variables other than actual arguments. These are variables from\n                            # the enclosing scope. It's handy to treat them like arguments in the UI\n                            it for it in f_locals.items()\n                            if it[0][0] != '.'  # Appears when using nested tuple arguments\n                        ]\n        frame_info.arguments = json.dumps([[k, cheap_repr(v)] for k, v in arguments])\n        frame_info.call_id = self._call_id()\n        frame_info.inner_calls = defaultdict(list)\n        prev = self.stack.get(enter_info.caller_frame)\n        if prev:\n            inner_calls = getattr(prev, 'inner_calls', None)\n            if inner_calls is not None:\n                inner_calls[enter_info.call_node].append(frame_info.call_id)\n\n    def _call_id(self):\n        # type: () -> Text\n        return uuid4().hex\n\n    def exit_call(self, exit_info):\n        # type: (ExitCallInfo) -> None\n        \"\"\"\n        This is where all the data collected during the call is gathered up\n        and sent to the database.\n        \"\"\"\n        frame = exit_info.current_frame  # type: FrameType\n        if frame.f_code not in self._code_infos or _tracing_recursively(frame):\n            return\n        frame_info = self.stack[frame]\n\n        top_iteration = frame_info.iteration  # type: Iteration\n        node_values = _deep_dict()\n        self._extract_node_values(top_iteration, (), node_values)\n\n        db_func = self._code_infos[frame.f_code].db_func\n        exc = exit_info.exc_value  # type: Optional[Exception]\n        if exc:\n            traceback_str = ''.join(traceback.format_exception(type(exc), exc, exit_info.exc_tb))\n            exception = exception_string(exc)\n        else:\n            traceback_str = exception = None\n\n        @retry_db\n        def add_call():\n            Call = self.db.Call\n            call = Call(id=frame_info.call_id,\n                        function_id=db_func,\n                        arguments=frame_info.arguments,\n                        return_value=cheap_repr(exit_info.return_value),\n                        exception=exception,\n                        traceback=traceback_str,\n                        data=json.dumps(\n                            dict(\n                                node_values=node_values,\n                                loop_iterations=top_iteration.extract_iterations()['loops'],\n                                type_names=type_registry.names(),\n                                num_special_types=type_registry.num_special_types,\n                            ),\n                            cls=ProtocolEncoder,\n                            separators=(',', ':')\n                        ),\n                        start_time=frame_info.start_time)\n            with self.db.session_scope() as session:\n                session.add(call)\n\n        add_call()\n\n        self._last_call_id = frame_info.call_id\n\n    def _extract_node_values(self, iteration, path, node_values):\n        # type: (Iteration, Tuple[int, ...], dict) -> None\n        \"\"\"\n        Populates node_values with values inside iteration.\n        \"\"\"\n        # Each element of `path` is an index of a loop iteration\n        # e.g. given the nested loops:\n        #\n        # for i in [0, 1, 2]:\n        #     for j in [0, 1, 2, 3]:\n        #\n        # path may be (i, j) for each of the iterations\n        for tree_index, node_value in iteration.vals.items():\n\n            # So this `full_path` is a tuple of ints, but the first\n            # int has a different meaning from the others\n            full_path = (tree_index,) + path\n\n            # Given a path (a, b, c) we're making node_values 'contain'\n            # this structure:\n            # {a: {b: {c: node_value}}}\n            d = node_values\n            for path_k in full_path[:-1]:\n                d = d[path_k]\n            d[full_path[-1]] = node_value\n\n        for loop in iteration.loops.values():\n            for i, iteration in enumerate(loop):\n                self._extract_node_values(iteration, path + (i,), node_values)\n\n    def trace_function(self, func):\n        # type: (FunctionType) -> FunctionType\n        new_func = super(BirdsEye, self).trace_function(func)\n        code_info = self._code_infos.get(new_func.__code__)\n        if code_info:\n            return new_func\n\n        lines, start_lineno = inspect.getsourcelines(func)  # type: List[Text], int\n        end_lineno = start_lineno + len(lines)\n        name = safe_qualname(func)\n        source_file = inspect.getsourcefile(func)\n        if source_file.startswith('<ipython-input'):\n            filename = IPYTHON_FILE_PATH\n        else:\n            filename = os.path.abspath(source_file)\n        traced_file = new_func.traced_file\n\n        arg_info = inspect.getargs(new_func.__code__)\n        arg_names = list(chain(flatten_list(arg_info[0]), arg_info[1:]))  # type: List[str]\n        self._trace(name, filename, traced_file, new_func.__code__, typ='function',\n                    start_lineno=start_lineno, end_lineno=end_lineno,\n                    arg_names=arg_names)\n\n        return new_func\n\n    def exec_ipython_cell(self, source, callback):\n        from IPython import get_ipython\n        shell = get_ipython()\n        filename = name = shell.compile.cache(source)\n        flags = shell.compile.flags\n\n        traced_file = self.compile(source, filename, flags)\n        traced_file.is_ipython_cell = True\n\n        for node in traced_file.root.body:\n            if is_future_import(node):\n                raise ValueError('from __future__ import ... statements '\n                                 'are not allowed in cells traced with %%eye')\n\n        shell.user_global_ns.update(self._trace_methods_dict(traced_file))\n\n        self._trace(name, filename, traced_file, traced_file.code, 'module', source)\n\n        try:\n            shell.ex(traced_file.code)\n            return self._ipython_cell_value\n        finally:\n            callback(self._last_call_id)\n            self._ipython_cell_value = None\n\n    def trace_this_module(self, context=0, deep=False):\n        frame = inspect.currentframe()\n\n        filename = None\n        while context >= 0:\n            frame = frame.f_back\n            filename = inspect.getsourcefile(frame)\n            if filename is not None:\n                context -= 1\n        filename = os.path.abspath(filename)\n\n        if frame.f_globals.get('__name__') != '__main__':\n            if PY3 and self._treetrace_hidden_with_stmt.__name__ not in frame.f_globals:\n                raise RuntimeError(\n                    'To trace an imported module, you must import birdseye before '\n                    'importing that module.')\n            return\n\n        lines = read_source_file(filename).splitlines()\n        lines[:frame.f_lineno] = [''] * frame.f_lineno\n        source = '\\n'.join(lines)\n        self.exec_string(source, filename, frame.f_globals, frame.f_locals, deep)\n        sys.exit(0)\n\n    def exec_string(self, source, filename, globs=None, locs=None, deep=False):\n        globs = globs or {}\n        locs = locs or {}\n\n        traced_file = self.compile(source, filename)\n\n        globs.update(self._trace_methods_dict(traced_file))\n\n        self._trace(FILE_SENTINEL_NAME, filename, traced_file, traced_file.code, 'module', source)\n\n        if deep:\n            nodes_by_lineno = {\n                node.lineno: node\n                for node in traced_file.nodes\n                if isinstance(node, ast.FunctionDef)\n            }\n\n            def find_code(root_code):\n                # type: (CodeType) -> None\n                for code in root_code.co_consts:  # type: CodeType\n                    if not inspect.iscode(code) or code.co_name.startswith('<'):\n                        continue\n\n                    find_code(code)\n\n                    lineno = code.co_firstlineno\n                    node = nodes_by_lineno.get(lineno)\n                    if not node:\n                        continue\n\n                    self._trace(\n                        code.co_name, filename, traced_file, code,\n                        typ='function',\n                        source=source,\n                        start_lineno=lineno,\n                        end_lineno=node.last_token.end[0] + 1,\n                    )\n\n            find_code(traced_file.code)\n\n        exec(traced_file.code, globs, locs)\n\n    def _trace(\n            self,\n            name,\n            filename,\n            traced_file,\n            code,\n            typ,\n            source='',\n            start_lineno=1,\n            end_lineno=None,\n            arg_names=(),\n    ):\n        if not end_lineno:\n            end_lineno = start_lineno + len(source.splitlines())\n        nodes = list(self._nodes_of_interest(traced_file, start_lineno, end_lineno))\n        html_body = self._nodes_html(nodes, start_lineno, end_lineno, traced_file)\n\n        data_dict = dict(\n            # This maps each node to the loops enclosing that node\n            node_loops={\n                node._tree_index: [n._tree_index for n in node._loops]\n                for node, _ in nodes\n                if node._loops\n            },\n        )\n        if typ == 'function':\n            tokens = traced_file.tokens\n            func_node = only(node\n                             for node, _ in nodes\n                             if isinstance(node, ast.FunctionDef)\n                             and node.first_token.start[0] == start_lineno)\n            func_startpos, source = source_without_decorators(tokens, func_node)\n            # These are for the PyCharm plugin\n            data_dict.update(\n                node_ranges=list(self._node_ranges(nodes, tokens, func_startpos)),\n                loop_ranges=list(self._loop_ranges(nodes, tokens, func_startpos)),\n            )\n\n        data = json.dumps(data_dict, sort_keys=True)\n        db_func = self._db_func(data, filename, html_body, name, start_lineno, source, typ)\n        self._code_infos[code] = CodeInfo(db_func, traced_file, arg_names)\n\n    def _loop_ranges(self, nodes, tokens, func_start):\n        # For a for loop, e.g.\n        #\n        #     for x in y:\n        #\n        # this yields the range of the target 'x'.\n        #\n        # For a while loop, e.g.\n        #\n        #     while x < 10:\n        #\n        # this yields the range of the condition 'x < 10'.\n        for node, (classes, _, __) in nodes:\n            if 'loop' not in classes:\n                continue\n\n            try:\n                target = node.target  # for loop\n            except AttributeError:\n                target = node.test  # while loop\n\n            start, end = tokens.get_text_range(target)\n            start -= func_start\n            end -= func_start\n\n            yield dict(\n                tree_index=node._tree_index,\n                start=start,\n                end=end\n            )\n\n    def _node_ranges(self, nodes, tokens, func_start):\n        for node, (classes, _, __) in nodes:\n            start, end = tokens.get_text_range(node)\n            start -= func_start\n            end -= func_start\n\n            if start < 0:\n                assert (end < 0  # nodes before the def, i.e. decorators\n                        or isinstance(node, ast.FunctionDef))\n                continue\n\n            yield dict(\n                tree_index=node._tree_index,\n                start=start,\n                end=end,\n                depth=node._depth,\n                classes=classes,\n            )\n\n    @retry_db\n    def _db_func(self, data, filename, html_body, name, start_lineno, source, typ):\n        \"\"\"\n        Retrieve the Function object from the database if one exists, or create one.\n        \"\"\"\n\n        def h(s):\n            return hashlib.sha256(s.encode('utf8')).hexdigest()\n\n        function_hash = h(filename + name + html_body + data + str(start_lineno))\n\n        Function = self.db.Function\n\n        with self.db.session_scope() as session:\n            db_func = one_or_none(session.query(Function).filter_by(hash=function_hash))  # type: Optional[Function]\n            if not db_func:\n                db_func = Function(file=filename,\n                                   name=name,\n                                   type=typ,\n                                   html_body=html_body,\n                                   lineno=start_lineno,\n                                   data=data,\n                                   body_hash=h(source),\n                                   hash=function_hash)\n                session.add(db_func)\n                session.commit()  # ensure .id exists\n            assert isinstance(db_func.id, int)\n            return db_func.id\n\n    def _nodes_of_interest(self, traced_file, start_lineno, end_lineno):\n        # type: (TracedFile, int, int) -> Iterator[Tuple[ast.AST, Tuple]]\n        \"\"\"\n        Nodes that may have a value, show up as a box in the UI, and lie within the\n        given line range.\n        \"\"\"\n        for node in traced_file.nodes:\n            classes = []\n\n            if (isinstance(node, (ast.While, ast.For, ast.comprehension)) and\n                    not isinstance(node.parent, ast.GeneratorExp)):\n                classes.append('loop')\n            if isinstance(node, ast.stmt):\n                classes.append('stmt')\n\n            if isinstance(node, ast.expr):\n                if not node._is_interesting_expression:\n                    continue\n            elif not classes:\n                continue\n\n            assert isinstance(node, ast.AST)\n\n            # In particular FormattedValue is missing this\n            if not hasattr(node, 'first_token'):\n                continue\n\n            if not start_lineno <= node.first_token.start[0] <= end_lineno:\n                continue\n\n            start, end = traced_file.tokens.get_text_range(node)  # type: int, int\n            if start == end == 0:\n                continue\n\n            yield node, (classes, start, end)\n\n    def _nodes_html(self, nodes, start_lineno, end_lineno, traced_file):\n        # type: (list, int, int, TracedFile) -> str\n        \"\"\"\n        The algorithm for generating the HTML works as follows. We generate a list\n        of HTMLPositions, which are essentially places to insert HTML into the source plus some\n        metadata. The order of the fields of HTMLPosition ensure that when the list is sorted,\n        the resulting HTML is valid and correct. Specifically, the fields are:\n        \n          1. index: the index in the source string where the HTML would be inserted\n          2. is_start: Indicates if this piece of HTML is the start of a tag, rather than the end.\n             Ends should appear first, so that the resulting HTML looks like:\n                <span> ... </span><span> ... </span>\n             rather than:\n                <span> ... <span></span> ... </span>\n             (I think this might actually be unnecessary, since I can't think of any cases of two\n              expressions right next to each other with nothing in between)\n          3. depth: the depth of the corresponding node in the AST. We want the start of a tag from\n             a node to appear before the start of a tag nested within, e.g. `foo()` should become:\n                <span [for foo()]><span [for foo]>foo</span>()</span>\n             rather than:   \n                <span [for foo]><span [for foo()]>foo</span>()</span>\n          4. html: the actual HTML to insert. Not important for ordering.\n          \n        Mostly the list contains pairs of HTMLPositions corresponding to AST nodes, one for the\n        start and one for the end.\n        \n        After the list is sorted, the HTML generated is essentially:\n        \n        source[0:positions[0].index] + positions[0].html + source[positions[0].index:positions[1].index] + positions[1].html + ...\n        \"\"\"\n\n        traced_file.root._depth = 0\n        for node in ast.walk(traced_file.root):  # type: ast.AST\n            for child in ast.iter_child_nodes(node):\n                child._depth = node._depth + 1\n\n        positions = []  # type: List[HTMLPosition]\n\n        for node, (classes, start, end) in nodes:\n            # noinspection PyArgumentList\n            positions.extend(map(\n                HTMLPosition,\n                [start, end],\n                [True, False],  # is_start\n                [node._depth, node._depth],\n                ['<span data-index=\"%s\" class=\"%s\">' % (node._tree_index, ' '.join(classes)),\n                 '</span>']))\n\n        end_lineno = self._separate_comprehensions(\n            [n[0] for n in nodes],\n            end_lineno, positions, traced_file)\n\n        # This just makes the loop below simpler\n        positions.append(HTMLPosition(len(traced_file.source), False, 0, ''))\n\n        positions.sort()\n\n        html_parts = []\n        start = 0\n        for position in positions:\n            html_parts.append(html.escape(traced_file.source[start:position.index]))\n            html_parts.append(position.html)\n            start = position.index\n        html_body = ''.join(html_parts)\n        html_body = '\\n'.join(html_body.split('\\n')[start_lineno - 1:end_lineno - 1])\n\n        return html_body.strip('\\n')\n\n    def _separate_comprehensions(self, nodes, end_lineno, positions, traced_file):\n        # type: (list, int, List[HTMLPosition], TracedFile) -> int\n        \"\"\"\n        Comprehensions (e.g. list comprehensions) are troublesome because they can\n        be navigated like loops, and the buttons for these need to be on separate lines.\n        This function inserts newlines to turn:\n\n        [x + y for x in range(3) for y in range(5)] and\n        [[x + y for x in range(3)] for y in range(5)]\n\n        into\n\n        [x + y for x in range(3)\n         for y in range(5)] and\n        [[x + y for x in range(3)]\n         for y in range(5)]\n        \"\"\"\n\n        comprehensions = group_by_key_func(of_type((ast.comprehension, ast.While, ast.For), nodes),\n                                           lambda c: c.first_token.start[0]\n                                           )  # type: Dict[Any, Iterable[ast.comprehension]]\n\n        def get_start(n):\n            # type: (ast.AST) -> int\n            return traced_file.tokens.get_text_range(n)[0]\n\n        for comp_list in comprehensions.values():\n            prev_start = None  # type: Optional[int]\n            for comp in sorted(comp_list, key=lambda c: c.first_token.startpos):\n                if isinstance(comp, ast.comprehension) and comp is comp.parent.generators[0]:\n                    start = get_start(comp.parent)\n                    if prev_start is not None and start < prev_start:\n                        start = get_start(comp)\n                else:\n                    start = get_start(comp)\n                if prev_start is not None:\n                    positions.append(HTMLPosition(start, True, 0, '\\n '))\n                    end_lineno += 1\n                prev_start = start\n\n        return end_lineno"
    ],
    [
        "STORE_NAME",
        "\"\"\"\n    Decorate functions with an instance of this class to debug them,\n    or just use the existing instance `eye`.\n    \"\"\""
    ],
    [
        "STORE_NAME",
        "    def __init__(self, db_uri=None, num_samples=None):\n        \"\"\"\n        Set db_uri to specify where the database lives, as an alternative to\n        the environment variable BIRDSEYE_DB.\n        \"\"\"\n        super(BirdsEye, self).__init__()\n        self._db_uri = db_uri\n        self._code_infos = {}  # type: Dict[CodeType, CodeInfo]\n        self._last_call_id = None\n        self._ipython_cell_value = None\n        self.num_samples = num_samples or dict(\n            big=dict(\n                attributes=50,\n                dict=50,\n                list=30,\n                set=30,\n                pandas_rows=20,\n                pandas_cols=100,\n            ),\n            small=dict(\n                attributes=50,\n                dict=10,\n                list=6,\n                set=6,\n                pandas_rows=6,\n                pandas_cols=10,\n            ),\n        )"
    ],
    [
        "LOAD_NAME",
        "cached_property"
    ],
    [
        "CALL_FUNCTION",
        "cached_property"
    ],
    [
        "STORE_NAME",
        "    @cached_property\n    def db(self):\n        return Database(self._db_uri)"
    ],
    [
        "STORE_NAME",
        "    def parse_extra(self, root, source, filename):\n        # type: (ast.Module, str, str) -> None\n        for node in ast.walk(root):  # type: ast.AST\n            node._loops = tracer.loops(node)\n            if isinstance(node, ast.expr):\n                node._is_interesting_expression = is_interesting_expression(node)"
    ],
    [
        "LOAD_NAME",
        "lru_cache"
    ],
    [
        "CALL_FUNCTION",
        "lru_cache()"
    ],
    [
        "CALL_FUNCTION",
        "lru_cache()"
    ],
    [
        "STORE_NAME",
        "    @lru_cache()\n    def compile(self, source, filename, flags=0):\n        traced_file = super(BirdsEye, self).compile(source, filename, flags)\n        traced_file.tokens = ASTTokens(source, tree=traced_file.root)\n        return traced_file"
    ],
    [
        "STORE_NAME",
        "    def before_stmt(self, node, frame):\n        # type: (ast.stmt, FrameType) -> None\n        if frame.f_code not in self._code_infos:\n            return\n        if isinstance(node.parent, ast.For) and node is node.parent.body[0]:\n            self._add_iteration(node._loops, frame)"
    ],
    [
        "STORE_NAME",
        "    def before_expr(self, node, frame):\n        if isinstance(node.parent, ast.While) and node is node.parent.test:\n            self._add_iteration(node._loops, frame)"
    ],
    [
        "STORE_NAME",
        "    def _add_iteration(self, loops, frame):\n        # type: (typing.Sequence[Loop], FrameType) -> None\n        \"\"\"\n        Given one or more nested loops, add an iteration for the innermost\n        loop (the last in the sequence).\n        \"\"\"\n        iteration = self.stack[frame].iteration  # type: Iteration\n        for i, loop_node in enumerate(loops):\n            loop = iteration.loops[loop_node._tree_index]\n            if i == len(loops) - 1:\n                loop.append(Iteration())\n            else:\n                iteration = loop.last()"
    ],
    [
        "STORE_NAME",
        "    def after_expr(self, node, frame, value, exc_value, exc_tb):\n        # type: (ast.expr, FrameType, Any, Optional[BaseException], Optional[TracebackType]) -> Optional[ChangeValue]\n\n        if _tracing_recursively(frame):\n            return None\n\n        if frame.f_code not in self._code_infos:\n            return None\n\n        if node._is_interesting_expression:\n            # If this is an expression statement and the last statement\n            # in the body, the value is returned from the cell magic\n            # to be displayed as usual\n            if (self._code_infos[frame.f_code].traced_file.is_ipython_cell\n                    and isinstance(node.parent, ast.Expr)\n                    and node.parent is node.parent.parent.body[-1]):\n                self._ipython_cell_value = value\n\n            if is_obvious_builtin(node, self.stack[frame].expression_values[node]):\n                return None\n\n            frame_info = self.stack[frame]\n            if exc_value:\n                node_value = self._exception_value(node, frame, exc_value)\n            else:\n                node_value = NodeValue.expression(\n                    self.num_samples,\n                    value,\n                    level=max(1, 3 - len(node._loops) * (not self._is_first_loop_iteration(node, frame))),\n                )\n                self._set_node_value(node, frame, node_value)\n            self._check_inner_call(frame_info, node, node_value)\n\n        # i.e. is `node` the `y` in `[f(x) for x in y]`, making `node.parent` the `for x in y`\n        is_special_comprehension_iter = (\n                isinstance(node.parent, ast.comprehension) and\n                node is node.parent.iter and\n\n                # Generators execute in their own time and aren't directly attached to the parent frame\n                not isinstance(node.parent.parent, ast.GeneratorExp))\n\n        if not is_special_comprehension_iter:\n            return None\n\n        # Mark `for x in y` as a bit that executed, so it doesn't show as grey\n        self._set_node_value(node.parent, frame, NodeValue.covered())\n\n        if exc_value:\n            return None\n\n        # Track each iteration over `y` so that the 'loop' can be stepped through\n        loops = node._loops + (node.parent,)  # type: Tuple[Loop, ...]\n\n        def comprehension_iter_proxy():\n            for item in value:\n                self._add_iteration(loops, frame)\n                yield item\n\n        # This effectively changes to code to `for x in comprehension_iter_proxy()`\n        return ChangeValue(comprehension_iter_proxy())"
    ],
    [
        "STORE_NAME",
        "    def _check_inner_call(self, frame_info, node, node_value):\n        # type: (FrameInfo, Union[ast.stmt, ast.expr], NodeValue) -> None\n        inner_calls = frame_info.inner_calls.pop(node, None)\n        if inner_calls:\n            node_value.set_meta('inner_calls', inner_calls)"
    ],
    [
        "STORE_NAME",
        "    def _is_first_loop_iteration(self, node, frame):\n        # type: (ast.AST, FrameType) -> bool\n        iteration = self.stack[frame].iteration  # type: Iteration\n        for loop_node in node._loops:  # type: ast.AST\n            loop = iteration.loops[loop_node._tree_index]\n            iteration = loop.last()\n            if iteration.index > 0:\n                return False\n        return True"
    ],
    [
        "STORE_NAME",
        "    def _set_node_value(self, node, frame, value):\n        # type: (ast.AST, FrameType, NodeValue) -> None\n        iteration = self.stack[frame].iteration  # type: Iteration\n        for loop_node in node._loops:  # type: ast.AST\n            loop = iteration.loops[loop_node._tree_index]\n            loop.recorded_node(node)\n            iteration = loop.last()\n        iteration.vals[node._tree_index] = value"
    ],
    [
        "STORE_NAME",
        "    def _exception_value(self, node, frame, exc_value):\n        # type: (Union[ast.expr, ast.stmt], FrameType, BaseException) -> NodeValue\n        value = NodeValue.exception(exc_value)\n        self._set_node_value(node, frame, value)\n        return value"
    ],
    [
        "STORE_NAME",
        "    def after_stmt(self, node, frame, exc_value, exc_traceback, exc_node):\n        # type: (ast.stmt, FrameType, Optional[BaseException], Optional[TracebackType], Optional[ast.AST]) -> Optional[bool]\n        if frame.f_code not in self._code_infos or _tracing_recursively(frame):\n            return None\n        if exc_value and node is exc_node:\n            value = self._exception_value(node, frame, exc_value)\n        else:\n            value = NodeValue.covered()\n            self._set_node_value(node, frame, value)\n        self._check_inner_call(self.stack[frame], node, value)\n        return None"
    ],
    [
        "STORE_NAME",
        "    def enter_call(self, enter_info):\n        # type: (EnterCallInfo) -> None\n        frame = enter_info.current_frame  # type: FrameType\n        if frame.f_code not in self._code_infos or _tracing_recursively(frame):\n            return\n        frame_info = self.stack[frame]\n        frame_info.start_time = get_unfrozen_datetime()\n        frame_info.iteration = Iteration()\n\n        code_info = self._code_infos[frame.f_code]\n        if isinstance(enter_info.enter_node.parent, ast.Module):\n            arguments = []\n        else:\n            f_locals = frame.f_locals.copy()  # type: Dict[str, Any]\n            arguments = [(name, f_locals.pop(name))\n                         for name in code_info.arg_names\n                         if name] + [\n\n                            # Local variables other than actual arguments. These are variables from\n                            # the enclosing scope. It's handy to treat them like arguments in the UI\n                            it for it in f_locals.items()\n                            if it[0][0] != '.'  # Appears when using nested tuple arguments\n                        ]\n        frame_info.arguments = json.dumps([[k, cheap_repr(v)] for k, v in arguments])\n        frame_info.call_id = self._call_id()\n        frame_info.inner_calls = defaultdict(list)\n        prev = self.stack.get(enter_info.caller_frame)\n        if prev:\n            inner_calls = getattr(prev, 'inner_calls', None)\n            if inner_calls is not None:\n                inner_calls[enter_info.call_node].append(frame_info.call_id)"
    ],
    [
        "STORE_NAME",
        "    def _call_id(self):\n        # type: () -> Text\n        return uuid4().hex"
    ],
    [
        "STORE_NAME",
        "    def exit_call(self, exit_info):\n        # type: (ExitCallInfo) -> None\n        \"\"\"\n        This is where all the data collected during the call is gathered up\n        and sent to the database.\n        \"\"\"\n        frame = exit_info.current_frame  # type: FrameType\n        if frame.f_code not in self._code_infos or _tracing_recursively(frame):\n            return\n        frame_info = self.stack[frame]\n\n        top_iteration = frame_info.iteration  # type: Iteration\n        node_values = _deep_dict()\n        self._extract_node_values(top_iteration, (), node_values)\n\n        db_func = self._code_infos[frame.f_code].db_func\n        exc = exit_info.exc_value  # type: Optional[Exception]\n        if exc:\n            traceback_str = ''.join(traceback.format_exception(type(exc), exc, exit_info.exc_tb))\n            exception = exception_string(exc)\n        else:\n            traceback_str = exception = None\n\n        @retry_db\n        def add_call():\n            Call = self.db.Call\n            call = Call(id=frame_info.call_id,\n                        function_id=db_func,\n                        arguments=frame_info.arguments,\n                        return_value=cheap_repr(exit_info.return_value),\n                        exception=exception,\n                        traceback=traceback_str,\n                        data=json.dumps(\n                            dict(\n                                node_values=node_values,\n                                loop_iterations=top_iteration.extract_iterations()['loops'],\n                                type_names=type_registry.names(),\n                                num_special_types=type_registry.num_special_types,\n                            ),\n                            cls=ProtocolEncoder,\n                            separators=(',', ':')\n                        ),\n                        start_time=frame_info.start_time)\n            with self.db.session_scope() as session:\n                session.add(call)\n\n        add_call()\n\n        self._last_call_id = frame_info.call_id"
    ],
    [
        "STORE_NAME",
        "    def _extract_node_values(self, iteration, path, node_values):\n        # type: (Iteration, Tuple[int, ...], dict) -> None\n        \"\"\"\n        Populates node_values with values inside iteration.\n        \"\"\"\n        # Each element of `path` is an index of a loop iteration\n        # e.g. given the nested loops:\n        #\n        # for i in [0, 1, 2]:\n        #     for j in [0, 1, 2, 3]:\n        #\n        # path may be (i, j) for each of the iterations\n        for tree_index, node_value in iteration.vals.items():\n\n            # So this `full_path` is a tuple of ints, but the first\n            # int has a different meaning from the others\n            full_path = (tree_index,) + path\n\n            # Given a path (a, b, c) we're making node_values 'contain'\n            # this structure:\n            # {a: {b: {c: node_value}}}\n            d = node_values\n            for path_k in full_path[:-1]:\n                d = d[path_k]\n            d[full_path[-1]] = node_value\n\n        for loop in iteration.loops.values():\n            for i, iteration in enumerate(loop):\n                self._extract_node_values(iteration, path + (i,), node_values)"
    ],
    [
        "STORE_NAME",
        "    def trace_function(self, func):\n        # type: (FunctionType) -> FunctionType\n        new_func = super(BirdsEye, self).trace_function(func)\n        code_info = self._code_infos.get(new_func.__code__)\n        if code_info:\n            return new_func\n\n        lines, start_lineno = inspect.getsourcelines(func)  # type: List[Text], int\n        end_lineno = start_lineno + len(lines)\n        name = safe_qualname(func)\n        source_file = inspect.getsourcefile(func)\n        if source_file.startswith('<ipython-input'):\n            filename = IPYTHON_FILE_PATH\n        else:\n            filename = os.path.abspath(source_file)\n        traced_file = new_func.traced_file\n\n        arg_info = inspect.getargs(new_func.__code__)\n        arg_names = list(chain(flatten_list(arg_info[0]), arg_info[1:]))  # type: List[str]\n        self._trace(name, filename, traced_file, new_func.__code__, typ='function',\n                    start_lineno=start_lineno, end_lineno=end_lineno,\n                    arg_names=arg_names)\n\n        return new_func"
    ],
    [
        "STORE_NAME",
        "    def exec_ipython_cell(self, source, callback):\n        from IPython import get_ipython\n        shell = get_ipython()\n        filename = name = shell.compile.cache(source)\n        flags = shell.compile.flags\n\n        traced_file = self.compile(source, filename, flags)\n        traced_file.is_ipython_cell = True\n\n        for node in traced_file.root.body:\n            if is_future_import(node):\n                raise ValueError('from __future__ import ... statements '\n                                 'are not allowed in cells traced with %%eye')\n\n        shell.user_global_ns.update(self._trace_methods_dict(traced_file))\n\n        self._trace(name, filename, traced_file, traced_file.code, 'module', source)\n\n        try:\n            shell.ex(traced_file.code)\n            return self._ipython_cell_value\n        finally:\n            callback(self._last_call_id)\n            self._ipython_cell_value = None"
    ],
    [
        "STORE_NAME",
        "    def trace_this_module(self, context=0, deep=False):\n        frame = inspect.currentframe()\n\n        filename = None\n        while context >= 0:\n            frame = frame.f_back\n            filename = inspect.getsourcefile(frame)\n            if filename is not None:\n                context -= 1\n        filename = os.path.abspath(filename)\n\n        if frame.f_globals.get('__name__') != '__main__':\n            if PY3 and self._treetrace_hidden_with_stmt.__name__ not in frame.f_globals:\n                raise RuntimeError(\n                    'To trace an imported module, you must import birdseye before '\n                    'importing that module.')\n            return\n\n        lines = read_source_file(filename).splitlines()\n        lines[:frame.f_lineno] = [''] * frame.f_lineno\n        source = '\\n'.join(lines)\n        self.exec_string(source, filename, frame.f_globals, frame.f_locals, deep)\n        sys.exit(0)"
    ],
    [
        "STORE_NAME",
        "    def exec_string(self, source, filename, globs=None, locs=None, deep=False):\n        globs = globs or {}\n        locs = locs or {}\n\n        traced_file = self.compile(source, filename)\n\n        globs.update(self._trace_methods_dict(traced_file))\n\n        self._trace(FILE_SENTINEL_NAME, filename, traced_file, traced_file.code, 'module', source)\n\n        if deep:\n            nodes_by_lineno = {\n                node.lineno: node\n                for node in traced_file.nodes\n                if isinstance(node, ast.FunctionDef)\n            }\n\n            def find_code(root_code):\n                # type: (CodeType) -> None\n                for code in root_code.co_consts:  # type: CodeType\n                    if not inspect.iscode(code) or code.co_name.startswith('<'):\n                        continue\n\n                    find_code(code)\n\n                    lineno = code.co_firstlineno\n                    node = nodes_by_lineno.get(lineno)\n                    if not node:\n                        continue\n\n                    self._trace(\n                        code.co_name, filename, traced_file, code,\n                        typ='function',\n                        source=source,\n                        start_lineno=lineno,\n                        end_lineno=node.last_token.end[0] + 1,\n                    )\n\n            find_code(traced_file.code)\n\n        exec(traced_file.code, globs, locs)"
    ],
    [
        "STORE_NAME",
        "    def _trace(\n            self,\n            name,\n            filename,\n            traced_file,\n            code,\n            typ,\n            source='',\n            start_lineno=1,\n            end_lineno=None,\n            arg_names=(),\n    ):\n        if not end_lineno:\n            end_lineno = start_lineno + len(source.splitlines())\n        nodes = list(self._nodes_of_interest(traced_file, start_lineno, end_lineno))\n        html_body = self._nodes_html(nodes, start_lineno, end_lineno, traced_file)\n\n        data_dict = dict(\n            # This maps each node to the loops enclosing that node\n            node_loops={\n                node._tree_index: [n._tree_index for n in node._loops]\n                for node, _ in nodes\n                if node._loops\n            },\n        )\n        if typ == 'function':\n            tokens = traced_file.tokens\n            func_node = only(node\n                             for node, _ in nodes\n                             if isinstance(node, ast.FunctionDef)\n                             and node.first_token.start[0] == start_lineno)\n            func_startpos, source = source_without_decorators(tokens, func_node)\n            # These are for the PyCharm plugin\n            data_dict.update(\n                node_ranges=list(self._node_ranges(nodes, tokens, func_startpos)),\n                loop_ranges=list(self._loop_ranges(nodes, tokens, func_startpos)),\n            )\n\n        data = json.dumps(data_dict, sort_keys=True)\n        db_func = self._db_func(data, filename, html_body, name, start_lineno, source, typ)\n        self._code_infos[code] = CodeInfo(db_func, traced_file, arg_names)"
    ],
    [
        "STORE_NAME",
        "    def _loop_ranges(self, nodes, tokens, func_start):\n        # For a for loop, e.g.\n        #\n        #     for x in y:\n        #\n        # this yields the range of the target 'x'.\n        #\n        # For a while loop, e.g.\n        #\n        #     while x < 10:\n        #\n        # this yields the range of the condition 'x < 10'.\n        for node, (classes, _, __) in nodes:\n            if 'loop' not in classes:\n                continue\n\n            try:\n                target = node.target  # for loop\n            except AttributeError:\n                target = node.test  # while loop\n\n            start, end = tokens.get_text_range(target)\n            start -= func_start\n            end -= func_start\n\n            yield dict(\n                tree_index=node._tree_index,\n                start=start,\n                end=end\n            )"
    ],
    [
        "STORE_NAME",
        "    def _node_ranges(self, nodes, tokens, func_start):\n        for node, (classes, _, __) in nodes:\n            start, end = tokens.get_text_range(node)\n            start -= func_start\n            end -= func_start\n\n            if start < 0:\n                assert (end < 0  # nodes before the def, i.e. decorators\n                        or isinstance(node, ast.FunctionDef))\n                continue\n\n            yield dict(\n                tree_index=node._tree_index,\n                start=start,\n                end=end,\n                depth=node._depth,\n                classes=classes,\n            )"
    ],
    [
        "LOAD_NAME",
        "retry_db"
    ],
    [
        "CALL_FUNCTION",
        "retry_db"
    ],
    [
        "STORE_NAME",
        "    @retry_db\n    def _db_func(self, data, filename, html_body, name, start_lineno, source, typ):\n        \"\"\"\n        Retrieve the Function object from the database if one exists, or create one.\n        \"\"\"\n\n        def h(s):\n            return hashlib.sha256(s.encode('utf8')).hexdigest()\n\n        function_hash = h(filename + name + html_body + data + str(start_lineno))\n\n        Function = self.db.Function\n\n        with self.db.session_scope() as session:\n            db_func = one_or_none(session.query(Function).filter_by(hash=function_hash))  # type: Optional[Function]\n            if not db_func:\n                db_func = Function(file=filename,\n                                   name=name,\n                                   type=typ,\n                                   html_body=html_body,\n                                   lineno=start_lineno,\n                                   data=data,\n                                   body_hash=h(source),\n                                   hash=function_hash)\n                session.add(db_func)\n                session.commit()  # ensure .id exists\n            assert isinstance(db_func.id, int)\n            return db_func.id"
    ],
    [
        "STORE_NAME",
        "    def _nodes_of_interest(self, traced_file, start_lineno, end_lineno):\n        # type: (TracedFile, int, int) -> Iterator[Tuple[ast.AST, Tuple]]\n        \"\"\"\n        Nodes that may have a value, show up as a box in the UI, and lie within the\n        given line range.\n        \"\"\"\n        for node in traced_file.nodes:\n            classes = []\n\n            if (isinstance(node, (ast.While, ast.For, ast.comprehension)) and\n                    not isinstance(node.parent, ast.GeneratorExp)):\n                classes.append('loop')\n            if isinstance(node, ast.stmt):\n                classes.append('stmt')\n\n            if isinstance(node, ast.expr):\n                if not node._is_interesting_expression:\n                    continue\n            elif not classes:\n                continue\n\n            assert isinstance(node, ast.AST)\n\n            # In particular FormattedValue is missing this\n            if not hasattr(node, 'first_token'):\n                continue\n\n            if not start_lineno <= node.first_token.start[0] <= end_lineno:\n                continue\n\n            start, end = traced_file.tokens.get_text_range(node)  # type: int, int\n            if start == end == 0:\n                continue\n\n            yield node, (classes, start, end)"
    ],
    [
        "STORE_NAME",
        "    def _nodes_html(self, nodes, start_lineno, end_lineno, traced_file):\n        # type: (list, int, int, TracedFile) -> str\n        \"\"\"\n        The algorithm for generating the HTML works as follows. We generate a list\n        of HTMLPositions, which are essentially places to insert HTML into the source plus some\n        metadata. The order of the fields of HTMLPosition ensure that when the list is sorted,\n        the resulting HTML is valid and correct. Specifically, the fields are:\n        \n          1. index: the index in the source string where the HTML would be inserted\n          2. is_start: Indicates if this piece of HTML is the start of a tag, rather than the end.\n             Ends should appear first, so that the resulting HTML looks like:\n                <span> ... </span><span> ... </span>\n             rather than:\n                <span> ... <span></span> ... </span>\n             (I think this might actually be unnecessary, since I can't think of any cases of two\n              expressions right next to each other with nothing in between)\n          3. depth: the depth of the corresponding node in the AST. We want the start of a tag from\n             a node to appear before the start of a tag nested within, e.g. `foo()` should become:\n                <span [for foo()]><span [for foo]>foo</span>()</span>\n             rather than:   \n                <span [for foo]><span [for foo()]>foo</span>()</span>\n          4. html: the actual HTML to insert. Not important for ordering.\n          \n        Mostly the list contains pairs of HTMLPositions corresponding to AST nodes, one for the\n        start and one for the end.\n        \n        After the list is sorted, the HTML generated is essentially:\n        \n        source[0:positions[0].index] + positions[0].html + source[positions[0].index:positions[1].index] + positions[1].html + ...\n        \"\"\"\n\n        traced_file.root._depth = 0\n        for node in ast.walk(traced_file.root):  # type: ast.AST\n            for child in ast.iter_child_nodes(node):\n                child._depth = node._depth + 1\n\n        positions = []  # type: List[HTMLPosition]\n\n        for node, (classes, start, end) in nodes:\n            # noinspection PyArgumentList\n            positions.extend(map(\n                HTMLPosition,\n                [start, end],\n                [True, False],  # is_start\n                [node._depth, node._depth],\n                ['<span data-index=\"%s\" class=\"%s\">' % (node._tree_index, ' '.join(classes)),\n                 '</span>']))\n\n        end_lineno = self._separate_comprehensions(\n            [n[0] for n in nodes],\n            end_lineno, positions, traced_file)\n\n        # This just makes the loop below simpler\n        positions.append(HTMLPosition(len(traced_file.source), False, 0, ''))\n\n        positions.sort()\n\n        html_parts = []\n        start = 0\n        for position in positions:\n            html_parts.append(html.escape(traced_file.source[start:position.index]))\n            html_parts.append(position.html)\n            start = position.index\n        html_body = ''.join(html_parts)\n        html_body = '\\n'.join(html_body.split('\\n')[start_lineno - 1:end_lineno - 1])\n\n        return html_body.strip('\\n')"
    ],
    [
        "STORE_NAME",
        "    def _separate_comprehensions(self, nodes, end_lineno, positions, traced_file):\n        # type: (list, int, List[HTMLPosition], TracedFile) -> int\n        \"\"\"\n        Comprehensions (e.g. list comprehensions) are troublesome because they can\n        be navigated like loops, and the buttons for these need to be on separate lines.\n        This function inserts newlines to turn:\n\n        [x + y for x in range(3) for y in range(5)] and\n        [[x + y for x in range(3)] for y in range(5)]\n\n        into\n\n        [x + y for x in range(3)\n         for y in range(5)] and\n        [[x + y for x in range(3)]\n         for y in range(5)]\n        \"\"\"\n\n        comprehensions = group_by_key_func(of_type((ast.comprehension, ast.While, ast.For), nodes),\n                                           lambda c: c.first_token.start[0]\n                                           )  # type: Dict[Any, Iterable[ast.comprehension]]\n\n        def get_start(n):\n            # type: (ast.AST) -> int\n            return traced_file.tokens.get_text_range(n)[0]\n\n        for comp_list in comprehensions.values():\n            prev_start = None  # type: Optional[int]\n            for comp in sorted(comp_list, key=lambda c: c.first_token.startpos):\n                if isinstance(comp, ast.comprehension) and comp is comp.parent.generators[0]:\n                    start = get_start(comp.parent)\n                    if prev_start is not None and start < prev_start:\n                        start = get_start(comp)\n                else:\n                    start = get_start(comp)\n                if prev_start is not None:\n                    positions.append(HTMLPosition(start, True, 0, '\\n '))\n                    end_lineno += 1\n                prev_start = start\n\n        return end_lineno"
    ],
    [
        "LOAD_GLOBAL",
        "super"
    ],
    [
        "LOAD_GLOBAL",
        "BirdsEye"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "CALL_FUNCTION",
        "super(BirdsEye, self)"
    ],
    [
        "LOAD_METHOD",
        "super(BirdsEye, self).__init__"
    ],
    [
        "CALL_METHOD",
        "super(BirdsEye, self).__init__()"
    ],
    [
        "LOAD_FAST",
        "db_uri"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._db_uri"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._code_infos"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._last_call_id"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._ipython_cell_value"
    ],
    [
        "LOAD_FAST",
        "num_samples"
    ],
    [
        "LOAD_GLOBAL",
        "dict"
    ],
    [
        "LOAD_GLOBAL",
        "dict"
    ],
    [
        "CALL_FUNCTION_KW",
        "dict(\n                attributes=50,\n                dict=50,\n                list=30,\n                set=30,\n                pandas_rows=20,\n                pandas_cols=100,\n            )"
    ],
    [
        "LOAD_GLOBAL",
        "dict"
    ],
    [
        "CALL_FUNCTION_KW",
        "dict(\n                attributes=50,\n                dict=10,\n                list=6,\n                set=6,\n                pandas_rows=6,\n                pandas_cols=10,\n            )"
    ],
    [
        "CALL_FUNCTION_KW",
        "dict(\n            big=dict(\n                attributes=50,\n                dict=50,\n                list=30,\n                set=30,\n                pandas_rows=20,\n                pandas_cols=100,\n            ),\n            small=dict(\n                attributes=50,\n                dict=10,\n                list=6,\n                set=6,\n                pandas_rows=6,\n                pandas_cols=10,\n            ),\n        )"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.num_samples"
    ],
    [
        "LOAD_GLOBAL",
        "Database"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._db_uri"
    ],
    [
        "CALL_FUNCTION",
        "Database(self._db_uri)"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_METHOD",
        "ast.walk"
    ],
    [
        "LOAD_FAST",
        "root"
    ],
    [
        "CALL_METHOD",
        "ast.walk(root)"
    ],
    [
        "STORE_FAST",
        "node"
    ],
    [
        "LOAD_GLOBAL",
        "tracer"
    ],
    [
        "LOAD_METHOD",
        "tracer.loops"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "CALL_METHOD",
        "tracer.loops(node)"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "STORE_ATTR",
        "node._loops"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.expr"
    ],
    [
        "CALL_FUNCTION",
        "isinstance(node, ast.expr)"
    ],
    [
        "LOAD_GLOBAL",
        "is_interesting_expression"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "CALL_FUNCTION",
        "is_interesting_expression(node)"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "STORE_ATTR",
        "node._is_interesting_expression"
    ],
    [
        "LOAD_GLOBAL",
        "super"
    ],
    [
        "LOAD_GLOBAL",
        "BirdsEye"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "CALL_FUNCTION",
        "super(BirdsEye, self)"
    ],
    [
        "LOAD_METHOD",
        "super(BirdsEye, self).compile"
    ],
    [
        "LOAD_FAST",
        "source"
    ],
    [
        "LOAD_FAST",
        "filename"
    ],
    [
        "LOAD_FAST",
        "flags"
    ],
    [
        "CALL_METHOD",
        "super(BirdsEye, self).compile(source, filename, flags)"
    ],
    [
        "STORE_FAST",
        "traced_file"
    ],
    [
        "LOAD_GLOBAL",
        "ASTTokens"
    ],
    [
        "LOAD_FAST",
        "source"
    ],
    [
        "LOAD_FAST",
        "traced_file"
    ],
    [
        "LOAD_ATTR",
        "traced_file.root"
    ],
    [
        "CALL_FUNCTION_KW",
        "ASTTokens(source, tree=traced_file.root)"
    ],
    [
        "LOAD_FAST",
        "traced_file"
    ],
    [
        "STORE_ATTR",
        "traced_file.tokens"
    ],
    [
        "LOAD_FAST",
        "traced_file"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "LOAD_ATTR",
        "frame.f_code"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._code_infos"
    ],
    [
        "CONTAINS_OP",
        "frame.f_code not in self._code_infos"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node.parent"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.For"
    ],
    [
        "CALL_FUNCTION",
        "isinstance(node.parent, ast.For)"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node.parent"
    ],
    [
        "LOAD_ATTR",
        "node.parent.body"
    ],
    [
        "BINARY_SUBSCR",
        "node.parent.body[0]"
    ],
    [
        "IS_OP",
        "node is node.parent.body[0]"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self._add_iteration"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node._loops"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "CALL_METHOD",
        "self._add_iteration(node._loops, frame)"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node.parent"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.While"
    ],
    [
        "CALL_FUNCTION",
        "isinstance(node.parent, ast.While)"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node.parent"
    ],
    [
        "LOAD_ATTR",
        "node.parent.test"
    ],
    [
        "IS_OP",
        "node is node.parent.test"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self._add_iteration"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node._loops"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "CALL_METHOD",
        "self._add_iteration(node._loops, frame)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.stack"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "BINARY_SUBSCR",
        "self.stack[frame]"
    ],
    [
        "LOAD_ATTR",
        "self.stack[frame].iteration"
    ],
    [
        "STORE_FAST",
        "iteration"
    ],
    [
        "LOAD_GLOBAL",
        "enumerate"
    ],
    [
        "LOAD_FAST",
        "loops"
    ],
    [
        "CALL_FUNCTION",
        "enumerate(loops)"
    ],
    [
        "STORE_FAST",
        "i"
    ],
    [
        "STORE_FAST",
        "loop_node"
    ],
    [
        "LOAD_FAST",
        "iteration"
    ],
    [
        "LOAD_ATTR",
        "iteration.loops"
    ],
    [
        "LOAD_FAST",
        "loop_node"
    ],
    [
        "LOAD_ATTR",
        "loop_node._tree_index"
    ],
    [
        "BINARY_SUBSCR",
        "iteration.loops[loop_node._tree_index]"
    ],
    [
        "STORE_FAST",
        "loop"
    ],
    [
        "LOAD_FAST",
        "i"
    ],
    [
        "LOAD_GLOBAL",
        "len"
    ],
    [
        "LOAD_FAST",
        "loops"
    ],
    [
        "CALL_FUNCTION",
        "len(loops)"
    ],
    [
        "BINARY_SUBTRACT",
        "len(loops) - 1"
    ],
    [
        "COMPARE_OP",
        "i == len(loops) - 1"
    ],
    [
        "LOAD_FAST",
        "loop"
    ],
    [
        "LOAD_METHOD",
        "loop.append"
    ],
    [
        "LOAD_GLOBAL",
        "Iteration"
    ],
    [
        "CALL_FUNCTION",
        "Iteration()"
    ],
    [
        "CALL_METHOD",
        "loop.append(Iteration())"
    ],
    [
        "LOAD_FAST",
        "loop"
    ],
    [
        "LOAD_METHOD",
        "loop.last"
    ],
    [
        "CALL_METHOD",
        "loop.last()"
    ],
    [
        "STORE_FAST",
        "iteration"
    ],
    [
        "LOAD_GLOBAL",
        "_tracing_recursively"
    ],
    [
        "LOAD_DEREF",
        "frame"
    ],
    [
        "CALL_FUNCTION",
        "_tracing_recursively(frame)"
    ],
    [
        "LOAD_DEREF",
        "frame"
    ],
    [
        "LOAD_ATTR",
        "frame.f_code"
    ],
    [
        "LOAD_DEREF",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._code_infos"
    ],
    [
        "CONTAINS_OP",
        "frame.f_code not in self._code_infos"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node._is_interesting_expression"
    ],
    [
        "LOAD_DEREF",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._code_infos"
    ],
    [
        "LOAD_DEREF",
        "frame"
    ],
    [
        "LOAD_ATTR",
        "frame.f_code"
    ],
    [
        "BINARY_SUBSCR",
        "self._code_infos[frame.f_code]"
    ],
    [
        "LOAD_ATTR",
        "self._code_infos[frame.f_code].traced_file"
    ],
    [
        "LOAD_ATTR",
        "self._code_infos[frame.f_code].traced_file.is_ipython_cell"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node.parent"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.Expr"
    ],
    [
        "CALL_FUNCTION",
        "isinstance(node.parent, ast.Expr)"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node.parent"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node.parent"
    ],
    [
        "LOAD_ATTR",
        "node.parent.parent"
    ],
    [
        "LOAD_ATTR",
        "node.parent.parent.body"
    ],
    [
        "BINARY_SUBSCR",
        "node.parent.parent.body[-1]"
    ],
    [
        "IS_OP",
        "node.parent is node.parent.parent.body[-1]"
    ],
    [
        "LOAD_DEREF",
        "value"
    ],
    [
        "LOAD_DEREF",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._ipython_cell_value"
    ],
    [
        "LOAD_GLOBAL",
        "is_obvious_builtin"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_DEREF",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.stack"
    ],
    [
        "LOAD_DEREF",
        "frame"
    ],
    [
        "BINARY_SUBSCR",
        "self.stack[frame]"
    ],
    [
        "LOAD_ATTR",
        "self.stack[frame].expression_values"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "BINARY_SUBSCR",
        "self.stack[frame].expression_values[node]"
    ],
    [
        "CALL_FUNCTION",
        "is_obvious_builtin(node, self.stack[frame].expression_values[node])"
    ],
    [
        "LOAD_DEREF",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.stack"
    ],
    [
        "LOAD_DEREF",
        "frame"
    ],
    [
        "BINARY_SUBSCR",
        "self.stack[frame]"
    ],
    [
        "STORE_FAST",
        "frame_info"
    ],
    [
        "LOAD_FAST",
        "exc_value"
    ],
    [
        "LOAD_DEREF",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self._exception_value"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_DEREF",
        "frame"
    ],
    [
        "LOAD_FAST",
        "exc_value"
    ],
    [
        "CALL_METHOD",
        "self._exception_value(node, frame, exc_value)"
    ],
    [
        "STORE_FAST",
        "node_value"
    ],
    [
        "LOAD_GLOBAL",
        "NodeValue"
    ],
    [
        "LOAD_ATTR",
        "NodeValue.expression"
    ],
    [
        "LOAD_DEREF",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.num_samples"
    ],
    [
        "LOAD_DEREF",
        "value"
    ],
    [
        "LOAD_GLOBAL",
        "max"
    ],
    [
        "LOAD_GLOBAL",
        "len"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node._loops"
    ],
    [
        "CALL_FUNCTION",
        "len(node._loops)"
    ],
    [
        "LOAD_DEREF",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self._is_first_loop_iteration"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_DEREF",
        "frame"
    ],
    [
        "CALL_METHOD",
        "self._is_first_loop_iteration(node, frame)"
    ],
    [
        "UNARY_NOT",
        "not self._is_first_loop_iteration(node, frame)"
    ],
    [
        "BINARY_MULTIPLY",
        "len(node._loops) * (not self._is_first_loop_iteration(node, frame))"
    ],
    [
        "BINARY_SUBTRACT",
        "3 - len(node._loops) * (not self._is_first_loop_iteration(node, frame))"
    ],
    [
        "CALL_FUNCTION",
        "max(1, 3 - len(node._loops) * (not self._is_first_loop_iteration(node, frame)))"
    ],
    [
        "CALL_FUNCTION_KW",
        "NodeValue.expression(\n                    self.num_samples,\n                    value,\n                    level=max(1, 3 - len(node._loops) * (not self._is_first_loop_iteration(node, frame))),\n                )"
    ],
    [
        "STORE_FAST",
        "node_value"
    ],
    [
        "LOAD_DEREF",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self._set_node_value"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_DEREF",
        "frame"
    ],
    [
        "LOAD_FAST",
        "node_value"
    ],
    [
        "CALL_METHOD",
        "self._set_node_value(node, frame, node_value)"
    ],
    [
        "LOAD_DEREF",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self._check_inner_call"
    ],
    [
        "LOAD_FAST",
        "frame_info"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_FAST",
        "node_value"
    ],
    [
        "CALL_METHOD",
        "self._check_inner_call(frame_info, node, node_value)"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node.parent"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.comprehension"
    ],
    [
        "CALL_FUNCTION",
        "isinstance(node.parent, ast.comprehension)"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node.parent"
    ],
    [
        "LOAD_ATTR",
        "node.parent.iter"
    ],
    [
        "IS_OP",
        "node is node.parent.iter"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node.parent"
    ],
    [
        "LOAD_ATTR",
        "node.parent.parent"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.GeneratorExp"
    ],
    [
        "CALL_FUNCTION",
        "isinstance(node.parent.parent, ast.GeneratorExp)"
    ],
    [
        "UNARY_NOT",
        "not isinstance(node.parent.parent, ast.GeneratorExp)"
    ],
    [
        "STORE_FAST",
        "is_special_comprehension_iter"
    ],
    [
        "LOAD_FAST",
        "is_special_comprehension_iter"
    ],
    [
        "LOAD_DEREF",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self._set_node_value"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node.parent"
    ],
    [
        "LOAD_DEREF",
        "frame"
    ],
    [
        "LOAD_GLOBAL",
        "NodeValue"
    ],
    [
        "LOAD_METHOD",
        "NodeValue.covered"
    ],
    [
        "CALL_METHOD",
        "NodeValue.covered()"
    ],
    [
        "CALL_METHOD",
        "self._set_node_value(node.parent, frame, NodeValue.covered())"
    ],
    [
        "LOAD_FAST",
        "exc_value"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node._loops"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node.parent"
    ],
    [
        "BINARY_ADD",
        "node._loops + (node.parent,)"
    ],
    [
        "STORE_DEREF",
        "loops"
    ],
    [
        "STORE_FAST",
        "        def comprehension_iter_proxy():\n            for item in value:\n                self._add_iteration(loops, frame)\n                yield item"
    ],
    [
        "LOAD_GLOBAL",
        "ChangeValue"
    ],
    [
        "LOAD_FAST",
        "comprehension_iter_proxy"
    ],
    [
        "CALL_FUNCTION",
        "comprehension_iter_proxy()"
    ],
    [
        "CALL_FUNCTION",
        "ChangeValue(comprehension_iter_proxy())"
    ],
    [
        "LOAD_DEREF",
        "value"
    ],
    [
        "STORE_FAST",
        "item"
    ],
    [
        "LOAD_DEREF",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self._add_iteration"
    ],
    [
        "LOAD_DEREF",
        "loops"
    ],
    [
        "LOAD_DEREF",
        "frame"
    ],
    [
        "CALL_METHOD",
        "self._add_iteration(loops, frame)"
    ],
    [
        "LOAD_FAST",
        "item"
    ],
    [
        "LOAD_FAST",
        "frame_info"
    ],
    [
        "LOAD_ATTR",
        "frame_info.inner_calls"
    ],
    [
        "LOAD_METHOD",
        "frame_info.inner_calls.pop"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "CALL_METHOD",
        "frame_info.inner_calls.pop(node, None)"
    ],
    [
        "STORE_FAST",
        "inner_calls"
    ],
    [
        "LOAD_FAST",
        "inner_calls"
    ],
    [
        "LOAD_FAST",
        "node_value"
    ],
    [
        "LOAD_METHOD",
        "node_value.set_meta"
    ],
    [
        "LOAD_FAST",
        "inner_calls"
    ],
    [
        "CALL_METHOD",
        "node_value.set_meta('inner_calls', inner_calls)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.stack"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "BINARY_SUBSCR",
        "self.stack[frame]"
    ],
    [
        "LOAD_ATTR",
        "self.stack[frame].iteration"
    ],
    [
        "STORE_FAST",
        "iteration"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node._loops"
    ],
    [
        "STORE_FAST",
        "loop_node"
    ],
    [
        "LOAD_FAST",
        "iteration"
    ],
    [
        "LOAD_ATTR",
        "iteration.loops"
    ],
    [
        "LOAD_FAST",
        "loop_node"
    ],
    [
        "LOAD_ATTR",
        "loop_node._tree_index"
    ],
    [
        "BINARY_SUBSCR",
        "iteration.loops[loop_node._tree_index]"
    ],
    [
        "STORE_FAST",
        "loop"
    ],
    [
        "LOAD_FAST",
        "loop"
    ],
    [
        "LOAD_METHOD",
        "loop.last"
    ],
    [
        "CALL_METHOD",
        "loop.last()"
    ],
    [
        "STORE_FAST",
        "iteration"
    ],
    [
        "LOAD_FAST",
        "iteration"
    ],
    [
        "LOAD_ATTR",
        "iteration.index"
    ],
    [
        "COMPARE_OP",
        "iteration.index > 0"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.stack"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "BINARY_SUBSCR",
        "self.stack[frame]"
    ],
    [
        "LOAD_ATTR",
        "self.stack[frame].iteration"
    ],
    [
        "STORE_FAST",
        "iteration"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node._loops"
    ],
    [
        "STORE_FAST",
        "loop_node"
    ],
    [
        "LOAD_FAST",
        "iteration"
    ],
    [
        "LOAD_ATTR",
        "iteration.loops"
    ],
    [
        "LOAD_FAST",
        "loop_node"
    ],
    [
        "LOAD_ATTR",
        "loop_node._tree_index"
    ],
    [
        "BINARY_SUBSCR",
        "iteration.loops[loop_node._tree_index]"
    ],
    [
        "STORE_FAST",
        "loop"
    ],
    [
        "LOAD_FAST",
        "loop"
    ],
    [
        "LOAD_METHOD",
        "loop.recorded_node"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "CALL_METHOD",
        "loop.recorded_node(node)"
    ],
    [
        "LOAD_FAST",
        "loop"
    ],
    [
        "LOAD_METHOD",
        "loop.last"
    ],
    [
        "CALL_METHOD",
        "loop.last()"
    ],
    [
        "STORE_FAST",
        "iteration"
    ],
    [
        "LOAD_FAST",
        "value"
    ],
    [
        "LOAD_FAST",
        "iteration"
    ],
    [
        "LOAD_ATTR",
        "iteration.vals"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node._tree_index"
    ],
    [
        "STORE_SUBSCR",
        "iteration.vals[node._tree_index]"
    ],
    [
        "LOAD_GLOBAL",
        "NodeValue"
    ],
    [
        "LOAD_METHOD",
        "NodeValue.exception"
    ],
    [
        "LOAD_FAST",
        "exc_value"
    ],
    [
        "CALL_METHOD",
        "NodeValue.exception(exc_value)"
    ],
    [
        "STORE_FAST",
        "value"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self._set_node_value"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "LOAD_FAST",
        "value"
    ],
    [
        "CALL_METHOD",
        "self._set_node_value(node, frame, value)"
    ],
    [
        "LOAD_FAST",
        "value"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "LOAD_ATTR",
        "frame.f_code"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._code_infos"
    ],
    [
        "CONTAINS_OP",
        "frame.f_code not in self._code_infos"
    ],
    [
        "LOAD_GLOBAL",
        "_tracing_recursively"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "CALL_FUNCTION",
        "_tracing_recursively(frame)"
    ],
    [
        "LOAD_FAST",
        "exc_value"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_FAST",
        "exc_node"
    ],
    [
        "IS_OP",
        "node is exc_node"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self._exception_value"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "LOAD_FAST",
        "exc_value"
    ],
    [
        "CALL_METHOD",
        "self._exception_value(node, frame, exc_value)"
    ],
    [
        "STORE_FAST",
        "value"
    ],
    [
        "LOAD_GLOBAL",
        "NodeValue"
    ],
    [
        "LOAD_METHOD",
        "NodeValue.covered"
    ],
    [
        "CALL_METHOD",
        "NodeValue.covered()"
    ],
    [
        "STORE_FAST",
        "value"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self._set_node_value"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "LOAD_FAST",
        "value"
    ],
    [
        "CALL_METHOD",
        "self._set_node_value(node, frame, value)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self._check_inner_call"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.stack"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "BINARY_SUBSCR",
        "self.stack[frame]"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_FAST",
        "value"
    ],
    [
        "CALL_METHOD",
        "self._check_inner_call(self.stack[frame], node, value)"
    ],
    [
        "LOAD_FAST",
        "enter_info"
    ],
    [
        "LOAD_ATTR",
        "enter_info.current_frame"
    ],
    [
        "STORE_FAST",
        "frame"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "LOAD_ATTR",
        "frame.f_code"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._code_infos"
    ],
    [
        "CONTAINS_OP",
        "frame.f_code not in self._code_infos"
    ],
    [
        "LOAD_GLOBAL",
        "_tracing_recursively"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "CALL_FUNCTION",
        "_tracing_recursively(frame)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.stack"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "BINARY_SUBSCR",
        "self.stack[frame]"
    ],
    [
        "STORE_FAST",
        "frame_info"
    ],
    [
        "LOAD_GLOBAL",
        "get_unfrozen_datetime"
    ],
    [
        "CALL_FUNCTION",
        "get_unfrozen_datetime()"
    ],
    [
        "LOAD_FAST",
        "frame_info"
    ],
    [
        "STORE_ATTR",
        "frame_info.start_time"
    ],
    [
        "LOAD_GLOBAL",
        "Iteration"
    ],
    [
        "CALL_FUNCTION",
        "Iteration()"
    ],
    [
        "LOAD_FAST",
        "frame_info"
    ],
    [
        "STORE_ATTR",
        "frame_info.iteration"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._code_infos"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "LOAD_ATTR",
        "frame.f_code"
    ],
    [
        "BINARY_SUBSCR",
        "self._code_infos[frame.f_code]"
    ],
    [
        "STORE_FAST",
        "code_info"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "enter_info"
    ],
    [
        "LOAD_ATTR",
        "enter_info.enter_node"
    ],
    [
        "LOAD_ATTR",
        "enter_info.enter_node.parent"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.Module"
    ],
    [
        "CALL_FUNCTION",
        "isinstance(enter_info.enter_node.parent, ast.Module)"
    ],
    [
        "STORE_FAST",
        "arguments"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "LOAD_ATTR",
        "frame.f_locals"
    ],
    [
        "LOAD_METHOD",
        "frame.f_locals.copy"
    ],
    [
        "CALL_METHOD",
        "frame.f_locals.copy()"
    ],
    [
        "STORE_DEREF",
        "f_locals"
    ],
    [
        "LOAD_FAST",
        "code_info"
    ],
    [
        "LOAD_ATTR",
        "code_info.arg_names"
    ],
    [
        "CALL_FUNCTION",
        "[(name, f_locals.pop(name))\n                         for name in code_info.arg_names\n                         if name]"
    ],
    [
        "LOAD_DEREF",
        "f_locals"
    ],
    [
        "LOAD_METHOD",
        "f_locals.items"
    ],
    [
        "CALL_METHOD",
        "f_locals.items()"
    ],
    [
        "CALL_FUNCTION",
        "[\n\n                            # Local variables other than actual arguments. These are variables from\n                            # the enclosing scope. It's handy to treat them like arguments in the UI\n                            it for it in f_locals.items()\n                            if it[0][0] != '.'  # Appears when using nested tuple arguments\n                        ]"
    ],
    [
        "BINARY_ADD",
        "[(name, f_locals.pop(name))\n                         for name in code_info.arg_names\n                         if name] + [\n\n                            # Local variables other than actual arguments. These are variables from\n                            # the enclosing scope. It's handy to treat them like arguments in the UI\n                            it for it in f_locals.items()\n                            if it[0][0] != '.'  # Appears when using nested tuple arguments\n                        ]"
    ],
    [
        "STORE_FAST",
        "arguments"
    ],
    [
        "LOAD_GLOBAL",
        "json"
    ],
    [
        "LOAD_METHOD",
        "json.dumps"
    ],
    [
        "LOAD_FAST",
        "arguments"
    ],
    [
        "CALL_FUNCTION",
        "[[k, cheap_repr(v)] for k, v in arguments]"
    ],
    [
        "CALL_METHOD",
        "json.dumps([[k, cheap_repr(v)] for k, v in arguments])"
    ],
    [
        "LOAD_FAST",
        "frame_info"
    ],
    [
        "STORE_ATTR",
        "frame_info.arguments"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self._call_id"
    ],
    [
        "CALL_METHOD",
        "self._call_id()"
    ],
    [
        "LOAD_FAST",
        "frame_info"
    ],
    [
        "STORE_ATTR",
        "frame_info.call_id"
    ],
    [
        "LOAD_GLOBAL",
        "defaultdict"
    ],
    [
        "LOAD_GLOBAL",
        "list"
    ],
    [
        "CALL_FUNCTION",
        "defaultdict(list)"
    ],
    [
        "LOAD_FAST",
        "frame_info"
    ],
    [
        "STORE_ATTR",
        "frame_info.inner_calls"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.stack"
    ],
    [
        "LOAD_METHOD",
        "self.stack.get"
    ],
    [
        "LOAD_FAST",
        "enter_info"
    ],
    [
        "LOAD_ATTR",
        "enter_info.caller_frame"
    ],
    [
        "CALL_METHOD",
        "self.stack.get(enter_info.caller_frame)"
    ],
    [
        "STORE_FAST",
        "prev"
    ],
    [
        "LOAD_FAST",
        "prev"
    ],
    [
        "LOAD_GLOBAL",
        "getattr"
    ],
    [
        "LOAD_FAST",
        "prev"
    ],
    [
        "CALL_FUNCTION",
        "getattr(prev, 'inner_calls', None)"
    ],
    [
        "STORE_FAST",
        "inner_calls"
    ],
    [
        "LOAD_FAST",
        "inner_calls"
    ],
    [
        "IS_OP",
        "inner_calls is not None"
    ],
    [
        "LOAD_FAST",
        "inner_calls"
    ],
    [
        "LOAD_FAST",
        "enter_info"
    ],
    [
        "LOAD_ATTR",
        "enter_info.call_node"
    ],
    [
        "BINARY_SUBSCR",
        "inner_calls[enter_info.call_node]"
    ],
    [
        "LOAD_METHOD",
        "inner_calls[enter_info.call_node].append"
    ],
    [
        "LOAD_FAST",
        "frame_info"
    ],
    [
        "LOAD_ATTR",
        "frame_info.call_id"
    ],
    [
        "CALL_METHOD",
        "inner_calls[enter_info.call_node].append(frame_info.call_id)"
    ],
    [
        "LOAD_FAST",
        "[(name, f_locals.pop(name))\n                         for name in code_info.arg_names\n                         if name]"
    ],
    [
        "STORE_FAST",
        "name"
    ],
    [
        "LOAD_FAST",
        "name"
    ],
    [
        "LOAD_FAST",
        "name"
    ],
    [
        "LOAD_DEREF",
        "f_locals"
    ],
    [
        "LOAD_METHOD",
        "f_locals.pop"
    ],
    [
        "LOAD_FAST",
        "name"
    ],
    [
        "CALL_METHOD",
        "f_locals.pop(name)"
    ],
    [
        "LOAD_FAST",
        "[\n\n                            # Local variables other than actual arguments. These are variables from\n                            # the enclosing scope. It's handy to treat them like arguments in the UI\n                            it for it in f_locals.items()\n                            if it[0][0] != '.'  # Appears when using nested tuple arguments\n                        ]"
    ],
    [
        "STORE_FAST",
        "it"
    ],
    [
        "LOAD_FAST",
        "it"
    ],
    [
        "BINARY_SUBSCR",
        "it[0]"
    ],
    [
        "BINARY_SUBSCR",
        "it[0][0]"
    ],
    [
        "COMPARE_OP",
        "it[0][0] != '.'"
    ],
    [
        "LOAD_FAST",
        "it"
    ],
    [
        "LOAD_FAST",
        "[[k, cheap_repr(v)] for k, v in arguments]"
    ],
    [
        "STORE_FAST",
        "k"
    ],
    [
        "STORE_FAST",
        "v"
    ],
    [
        "LOAD_FAST",
        "k"
    ],
    [
        "LOAD_GLOBAL",
        "cheap_repr"
    ],
    [
        "LOAD_FAST",
        "v"
    ],
    [
        "CALL_FUNCTION",
        "cheap_repr(v)"
    ],
    [
        "LOAD_GLOBAL",
        "uuid4"
    ],
    [
        "CALL_FUNCTION",
        "uuid4()"
    ],
    [
        "LOAD_ATTR",
        "uuid4().hex"
    ],
    [
        "LOAD_DEREF",
        "exit_info"
    ],
    [
        "LOAD_ATTR",
        "exit_info.current_frame"
    ],
    [
        "STORE_FAST",
        "frame"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "LOAD_ATTR",
        "frame.f_code"
    ],
    [
        "LOAD_DEREF",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._code_infos"
    ],
    [
        "CONTAINS_OP",
        "frame.f_code not in self._code_infos"
    ],
    [
        "LOAD_GLOBAL",
        "_tracing_recursively"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "CALL_FUNCTION",
        "_tracing_recursively(frame)"
    ],
    [
        "LOAD_DEREF",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.stack"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "BINARY_SUBSCR",
        "self.stack[frame]"
    ],
    [
        "STORE_DEREF",
        "frame_info"
    ],
    [
        "LOAD_DEREF",
        "frame_info"
    ],
    [
        "LOAD_ATTR",
        "frame_info.iteration"
    ],
    [
        "STORE_DEREF",
        "top_iteration"
    ],
    [
        "LOAD_GLOBAL",
        "_deep_dict"
    ],
    [
        "CALL_FUNCTION",
        "_deep_dict()"
    ],
    [
        "STORE_DEREF",
        "node_values"
    ],
    [
        "LOAD_DEREF",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self._extract_node_values"
    ],
    [
        "LOAD_DEREF",
        "top_iteration"
    ],
    [
        "LOAD_DEREF",
        "node_values"
    ],
    [
        "CALL_METHOD",
        "self._extract_node_values(top_iteration, (), node_values)"
    ],
    [
        "LOAD_DEREF",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._code_infos"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "LOAD_ATTR",
        "frame.f_code"
    ],
    [
        "BINARY_SUBSCR",
        "self._code_infos[frame.f_code]"
    ],
    [
        "LOAD_ATTR",
        "self._code_infos[frame.f_code].db_func"
    ],
    [
        "STORE_DEREF",
        "db_func"
    ],
    [
        "LOAD_DEREF",
        "exit_info"
    ],
    [
        "LOAD_ATTR",
        "exit_info.exc_value"
    ],
    [
        "STORE_FAST",
        "exc"
    ],
    [
        "LOAD_FAST",
        "exc"
    ],
    [
        "LOAD_METHOD",
        "''.join"
    ],
    [
        "LOAD_GLOBAL",
        "traceback"
    ],
    [
        "LOAD_METHOD",
        "traceback.format_exception"
    ],
    [
        "LOAD_GLOBAL",
        "type"
    ],
    [
        "LOAD_FAST",
        "exc"
    ],
    [
        "CALL_FUNCTION",
        "type(exc)"
    ],
    [
        "LOAD_FAST",
        "exc"
    ],
    [
        "LOAD_DEREF",
        "exit_info"
    ],
    [
        "LOAD_ATTR",
        "exit_info.exc_tb"
    ],
    [
        "CALL_METHOD",
        "traceback.format_exception(type(exc), exc, exit_info.exc_tb)"
    ],
    [
        "CALL_METHOD",
        "''.join(traceback.format_exception(type(exc), exc, exit_info.exc_tb))"
    ],
    [
        "STORE_DEREF",
        "traceback_str"
    ],
    [
        "LOAD_GLOBAL",
        "exception_string"
    ],
    [
        "LOAD_FAST",
        "exc"
    ],
    [
        "CALL_FUNCTION",
        "exception_string(exc)"
    ],
    [
        "STORE_DEREF",
        "exception"
    ],
    [
        "STORE_DEREF",
        "traceback_str"
    ],
    [
        "STORE_DEREF",
        "exception"
    ],
    [
        "LOAD_GLOBAL",
        "retry_db"
    ],
    [
        "CALL_FUNCTION",
        "retry_db"
    ],
    [
        "STORE_FAST",
        "        @retry_db\n        def add_call():\n            Call = self.db.Call\n            call = Call(id=frame_info.call_id,\n                        function_id=db_func,\n                        arguments=frame_info.arguments,\n                        return_value=cheap_repr(exit_info.return_value),\n                        exception=exception,\n                        traceback=traceback_str,\n                        data=json.dumps(\n                            dict(\n                                node_values=node_values,\n                                loop_iterations=top_iteration.extract_iterations()['loops'],\n                                type_names=type_registry.names(),\n                                num_special_types=type_registry.num_special_types,\n                            ),\n                            cls=ProtocolEncoder,\n                            separators=(',', ':')\n                        ),\n                        start_time=frame_info.start_time)\n            with self.db.session_scope() as session:\n                session.add(call)"
    ],
    [
        "LOAD_FAST",
        "add_call"
    ],
    [
        "CALL_FUNCTION",
        "add_call()"
    ],
    [
        "LOAD_DEREF",
        "frame_info"
    ],
    [
        "LOAD_ATTR",
        "frame_info.call_id"
    ],
    [
        "LOAD_DEREF",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._last_call_id"
    ],
    [
        "LOAD_DEREF",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.db"
    ],
    [
        "LOAD_ATTR",
        "self.db.Call"
    ],
    [
        "STORE_FAST",
        "Call"
    ],
    [
        "LOAD_FAST",
        "Call"
    ],
    [
        "LOAD_DEREF",
        "frame_info"
    ],
    [
        "LOAD_ATTR",
        "frame_info.call_id"
    ],
    [
        "LOAD_DEREF",
        "db_func"
    ],
    [
        "LOAD_DEREF",
        "frame_info"
    ],
    [
        "LOAD_ATTR",
        "frame_info.arguments"
    ],
    [
        "LOAD_GLOBAL",
        "cheap_repr"
    ],
    [
        "LOAD_DEREF",
        "exit_info"
    ],
    [
        "LOAD_ATTR",
        "exit_info.return_value"
    ],
    [
        "CALL_FUNCTION",
        "cheap_repr(exit_info.return_value)"
    ],
    [
        "LOAD_DEREF",
        "exception"
    ],
    [
        "LOAD_DEREF",
        "traceback_str"
    ],
    [
        "LOAD_GLOBAL",
        "json"
    ],
    [
        "LOAD_ATTR",
        "json.dumps"
    ],
    [
        "LOAD_GLOBAL",
        "dict"
    ],
    [
        "LOAD_DEREF",
        "node_values"
    ],
    [
        "LOAD_DEREF",
        "top_iteration"
    ],
    [
        "LOAD_METHOD",
        "top_iteration.extract_iterations"
    ],
    [
        "CALL_METHOD",
        "top_iteration.extract_iterations()"
    ],
    [
        "BINARY_SUBSCR",
        "top_iteration.extract_iterations()['loops']"
    ],
    [
        "LOAD_GLOBAL",
        "type_registry"
    ],
    [
        "LOAD_METHOD",
        "type_registry.names"
    ],
    [
        "CALL_METHOD",
        "type_registry.names()"
    ],
    [
        "LOAD_GLOBAL",
        "type_registry"
    ],
    [
        "LOAD_ATTR",
        "type_registry.num_special_types"
    ],
    [
        "CALL_FUNCTION_KW",
        "dict(\n                                node_values=node_values,\n                                loop_iterations=top_iteration.extract_iterations()['loops'],\n                                type_names=type_registry.names(),\n                                num_special_types=type_registry.num_special_types,\n                            )"
    ],
    [
        "LOAD_GLOBAL",
        "ProtocolEncoder"
    ],
    [
        "CALL_FUNCTION_KW",
        "json.dumps(\n                            dict(\n                                node_values=node_values,\n                                loop_iterations=top_iteration.extract_iterations()['loops'],\n                                type_names=type_registry.names(),\n                                num_special_types=type_registry.num_special_types,\n                            ),\n                            cls=ProtocolEncoder,\n                            separators=(',', ':')\n                        )"
    ],
    [
        "LOAD_DEREF",
        "frame_info"
    ],
    [
        "LOAD_ATTR",
        "frame_info.start_time"
    ],
    [
        "CALL_FUNCTION_KW",
        "Call(id=frame_info.call_id,\n                        function_id=db_func,\n                        arguments=frame_info.arguments,\n                        return_value=cheap_repr(exit_info.return_value),\n                        exception=exception,\n                        traceback=traceback_str,\n                        data=json.dumps(\n                            dict(\n                                node_values=node_values,\n                                loop_iterations=top_iteration.extract_iterations()['loops'],\n                                type_names=type_registry.names(),\n                                num_special_types=type_registry.num_special_types,\n                            ),\n                            cls=ProtocolEncoder,\n                            separators=(',', ':')\n                        ),\n                        start_time=frame_info.start_time)"
    ],
    [
        "STORE_FAST",
        "call"
    ],
    [
        "LOAD_DEREF",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.db"
    ],
    [
        "LOAD_METHOD",
        "self.db.session_scope"
    ],
    [
        "CALL_METHOD",
        "self.db.session_scope()"
    ],
    [
        "STORE_FAST",
        "session"
    ],
    [
        "LOAD_FAST",
        "session"
    ],
    [
        "LOAD_METHOD",
        "session.add"
    ],
    [
        "LOAD_FAST",
        "call"
    ],
    [
        "CALL_METHOD",
        "session.add(call)"
    ],
    [
        "LOAD_FAST",
        "iteration"
    ],
    [
        "LOAD_ATTR",
        "iteration.vals"
    ],
    [
        "LOAD_METHOD",
        "iteration.vals.items"
    ],
    [
        "CALL_METHOD",
        "iteration.vals.items()"
    ],
    [
        "STORE_FAST",
        "tree_index"
    ],
    [
        "STORE_FAST",
        "node_value"
    ],
    [
        "LOAD_FAST",
        "tree_index"
    ],
    [
        "LOAD_FAST",
        "path"
    ],
    [
        "BINARY_ADD",
        "(tree_index,) + path"
    ],
    [
        "STORE_FAST",
        "full_path"
    ],
    [
        "LOAD_FAST",
        "node_values"
    ],
    [
        "STORE_FAST",
        "d"
    ],
    [
        "LOAD_FAST",
        "full_path"
    ],
    [
        "BINARY_SUBSCR",
        "full_path[:-1]"
    ],
    [
        "STORE_FAST",
        "path_k"
    ],
    [
        "LOAD_FAST",
        "d"
    ],
    [
        "LOAD_FAST",
        "path_k"
    ],
    [
        "BINARY_SUBSCR",
        "d[path_k]"
    ],
    [
        "STORE_FAST",
        "d"
    ],
    [
        "LOAD_FAST",
        "node_value"
    ],
    [
        "LOAD_FAST",
        "d"
    ],
    [
        "LOAD_FAST",
        "full_path"
    ],
    [
        "BINARY_SUBSCR",
        "full_path[-1]"
    ],
    [
        "STORE_SUBSCR",
        "d[full_path[-1]]"
    ],
    [
        "LOAD_FAST",
        "iteration"
    ],
    [
        "LOAD_ATTR",
        "iteration.loops"
    ],
    [
        "LOAD_METHOD",
        "iteration.loops.values"
    ],
    [
        "CALL_METHOD",
        "iteration.loops.values()"
    ],
    [
        "STORE_FAST",
        "loop"
    ],
    [
        "LOAD_GLOBAL",
        "enumerate"
    ],
    [
        "LOAD_FAST",
        "loop"
    ],
    [
        "CALL_FUNCTION",
        "enumerate(loop)"
    ],
    [
        "STORE_FAST",
        "i"
    ],
    [
        "STORE_FAST",
        "iteration"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self._extract_node_values"
    ],
    [
        "LOAD_FAST",
        "iteration"
    ],
    [
        "LOAD_FAST",
        "path"
    ],
    [
        "LOAD_FAST",
        "i"
    ],
    [
        "BINARY_ADD",
        "path + (i,)"
    ],
    [
        "LOAD_FAST",
        "node_values"
    ],
    [
        "CALL_METHOD",
        "self._extract_node_values(iteration, path + (i,), node_values)"
    ],
    [
        "LOAD_GLOBAL",
        "super"
    ],
    [
        "LOAD_GLOBAL",
        "BirdsEye"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "CALL_FUNCTION",
        "super(BirdsEye, self)"
    ],
    [
        "LOAD_METHOD",
        "super(BirdsEye, self).trace_function"
    ],
    [
        "LOAD_FAST",
        "func"
    ],
    [
        "CALL_METHOD",
        "super(BirdsEye, self).trace_function(func)"
    ],
    [
        "STORE_FAST",
        "new_func"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._code_infos"
    ],
    [
        "LOAD_METHOD",
        "self._code_infos.get"
    ],
    [
        "LOAD_FAST",
        "new_func"
    ],
    [
        "LOAD_ATTR",
        "new_func.__code__"
    ],
    [
        "CALL_METHOD",
        "self._code_infos.get(new_func.__code__)"
    ],
    [
        "STORE_FAST",
        "code_info"
    ],
    [
        "LOAD_FAST",
        "code_info"
    ],
    [
        "LOAD_FAST",
        "new_func"
    ],
    [
        "LOAD_GLOBAL",
        "inspect"
    ],
    [
        "LOAD_METHOD",
        "inspect.getsourcelines"
    ],
    [
        "LOAD_FAST",
        "func"
    ],
    [
        "CALL_METHOD",
        "inspect.getsourcelines(func)"
    ],
    [
        "STORE_FAST",
        "lines"
    ],
    [
        "STORE_FAST",
        "start_lineno"
    ],
    [
        "LOAD_FAST",
        "start_lineno"
    ],
    [
        "LOAD_GLOBAL",
        "len"
    ],
    [
        "LOAD_FAST",
        "lines"
    ],
    [
        "CALL_FUNCTION",
        "len(lines)"
    ],
    [
        "BINARY_ADD",
        "start_lineno + len(lines)"
    ],
    [
        "STORE_FAST",
        "end_lineno"
    ],
    [
        "LOAD_GLOBAL",
        "safe_qualname"
    ],
    [
        "LOAD_FAST",
        "func"
    ],
    [
        "CALL_FUNCTION",
        "safe_qualname(func)"
    ],
    [
        "STORE_FAST",
        "name"
    ],
    [
        "LOAD_GLOBAL",
        "inspect"
    ],
    [
        "LOAD_METHOD",
        "inspect.getsourcefile"
    ],
    [
        "LOAD_FAST",
        "func"
    ],
    [
        "CALL_METHOD",
        "inspect.getsourcefile(func)"
    ],
    [
        "STORE_FAST",
        "source_file"
    ],
    [
        "LOAD_FAST",
        "source_file"
    ],
    [
        "LOAD_METHOD",
        "source_file.startswith"
    ],
    [
        "CALL_METHOD",
        "source_file.startswith('<ipython-input')"
    ],
    [
        "LOAD_GLOBAL",
        "IPYTHON_FILE_PATH"
    ],
    [
        "STORE_FAST",
        "filename"
    ],
    [
        "LOAD_GLOBAL",
        "os"
    ],
    [
        "LOAD_ATTR",
        "os.path"
    ],
    [
        "LOAD_METHOD",
        "os.path.abspath"
    ],
    [
        "LOAD_FAST",
        "source_file"
    ],
    [
        "CALL_METHOD",
        "os.path.abspath(source_file)"
    ],
    [
        "STORE_FAST",
        "filename"
    ],
    [
        "LOAD_FAST",
        "new_func"
    ],
    [
        "LOAD_ATTR",
        "new_func.traced_file"
    ],
    [
        "STORE_FAST",
        "traced_file"
    ],
    [
        "LOAD_GLOBAL",
        "inspect"
    ],
    [
        "LOAD_METHOD",
        "inspect.getargs"
    ],
    [
        "LOAD_FAST",
        "new_func"
    ],
    [
        "LOAD_ATTR",
        "new_func.__code__"
    ],
    [
        "CALL_METHOD",
        "inspect.getargs(new_func.__code__)"
    ],
    [
        "STORE_FAST",
        "arg_info"
    ],
    [
        "LOAD_GLOBAL",
        "list"
    ],
    [
        "LOAD_GLOBAL",
        "chain"
    ],
    [
        "LOAD_GLOBAL",
        "flatten_list"
    ],
    [
        "LOAD_FAST",
        "arg_info"
    ],
    [
        "BINARY_SUBSCR",
        "arg_info[0]"
    ],
    [
        "CALL_FUNCTION",
        "flatten_list(arg_info[0])"
    ],
    [
        "LOAD_FAST",
        "arg_info"
    ],
    [
        "BINARY_SUBSCR",
        "arg_info[1:]"
    ],
    [
        "CALL_FUNCTION",
        "chain(flatten_list(arg_info[0]), arg_info[1:])"
    ],
    [
        "CALL_FUNCTION",
        "list(chain(flatten_list(arg_info[0]), arg_info[1:]))"
    ],
    [
        "STORE_FAST",
        "arg_names"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._trace"
    ],
    [
        "LOAD_FAST",
        "name"
    ],
    [
        "LOAD_FAST",
        "filename"
    ],
    [
        "LOAD_FAST",
        "traced_file"
    ],
    [
        "LOAD_FAST",
        "new_func"
    ],
    [
        "LOAD_ATTR",
        "new_func.__code__"
    ],
    [
        "LOAD_FAST",
        "start_lineno"
    ],
    [
        "LOAD_FAST",
        "end_lineno"
    ],
    [
        "LOAD_FAST",
        "arg_names"
    ],
    [
        "CALL_FUNCTION_KW",
        "self._trace(name, filename, traced_file, new_func.__code__, typ='function',\n                    start_lineno=start_lineno, end_lineno=end_lineno,\n                    arg_names=arg_names)"
    ],
    [
        "LOAD_FAST",
        "new_func"
    ],
    [
        "STORE_FAST",
        "from IPython import get_ipython"
    ],
    [
        "LOAD_FAST",
        "get_ipython"
    ],
    [
        "CALL_FUNCTION",
        "get_ipython()"
    ],
    [
        "STORE_FAST",
        "shell"
    ],
    [
        "LOAD_FAST",
        "shell"
    ],
    [
        "LOAD_ATTR",
        "shell.compile"
    ],
    [
        "LOAD_METHOD",
        "shell.compile.cache"
    ],
    [
        "LOAD_FAST",
        "source"
    ],
    [
        "CALL_METHOD",
        "shell.compile.cache(source)"
    ],
    [
        "STORE_FAST",
        "filename"
    ],
    [
        "STORE_FAST",
        "name"
    ],
    [
        "LOAD_FAST",
        "shell"
    ],
    [
        "LOAD_ATTR",
        "shell.compile"
    ],
    [
        "LOAD_ATTR",
        "shell.compile.flags"
    ],
    [
        "STORE_FAST",
        "flags"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.compile"
    ],
    [
        "LOAD_FAST",
        "source"
    ],
    [
        "LOAD_FAST",
        "filename"
    ],
    [
        "LOAD_FAST",
        "flags"
    ],
    [
        "CALL_METHOD",
        "self.compile(source, filename, flags)"
    ],
    [
        "STORE_FAST",
        "traced_file"
    ],
    [
        "LOAD_FAST",
        "traced_file"
    ],
    [
        "STORE_ATTR",
        "traced_file.is_ipython_cell"
    ],
    [
        "LOAD_FAST",
        "traced_file"
    ],
    [
        "LOAD_ATTR",
        "traced_file.root"
    ],
    [
        "LOAD_ATTR",
        "traced_file.root.body"
    ],
    [
        "STORE_FAST",
        "node"
    ],
    [
        "LOAD_GLOBAL",
        "is_future_import"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "CALL_FUNCTION",
        "is_future_import(node)"
    ],
    [
        "LOAD_GLOBAL",
        "ValueError"
    ],
    [
        "CALL_FUNCTION",
        "ValueError('from __future__ import ... statements '\n                                 'are not allowed in cells traced with %%eye')"
    ],
    [
        "LOAD_FAST",
        "shell"
    ],
    [
        "LOAD_ATTR",
        "shell.user_global_ns"
    ],
    [
        "LOAD_METHOD",
        "shell.user_global_ns.update"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self._trace_methods_dict"
    ],
    [
        "LOAD_FAST",
        "traced_file"
    ],
    [
        "CALL_METHOD",
        "self._trace_methods_dict(traced_file)"
    ],
    [
        "CALL_METHOD",
        "shell.user_global_ns.update(self._trace_methods_dict(traced_file))"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self._trace"
    ],
    [
        "LOAD_FAST",
        "name"
    ],
    [
        "LOAD_FAST",
        "filename"
    ],
    [
        "LOAD_FAST",
        "traced_file"
    ],
    [
        "LOAD_FAST",
        "traced_file"
    ],
    [
        "LOAD_ATTR",
        "traced_file.code"
    ],
    [
        "LOAD_FAST",
        "source"
    ],
    [
        "CALL_METHOD",
        "self._trace(name, filename, traced_file, traced_file.code, 'module', source)"
    ],
    [
        "LOAD_FAST",
        "shell"
    ],
    [
        "LOAD_METHOD",
        "shell.ex"
    ],
    [
        "LOAD_FAST",
        "traced_file"
    ],
    [
        "LOAD_ATTR",
        "traced_file.code"
    ],
    [
        "CALL_METHOD",
        "shell.ex(traced_file.code)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._ipython_cell_value"
    ],
    [
        "LOAD_FAST",
        "callback"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._last_call_id"
    ],
    [
        "CALL_FUNCTION",
        "callback(self._last_call_id)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._ipython_cell_value"
    ],
    [
        "LOAD_FAST",
        "callback"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._last_call_id"
    ],
    [
        "CALL_FUNCTION",
        "callback(self._last_call_id)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self._ipython_cell_value"
    ],
    [
        "LOAD_GLOBAL",
        "inspect"
    ],
    [
        "LOAD_METHOD",
        "inspect.currentframe"
    ],
    [
        "CALL_METHOD",
        "inspect.currentframe()"
    ],
    [
        "STORE_FAST",
        "frame"
    ],
    [
        "STORE_FAST",
        "filename"
    ],
    [
        "LOAD_FAST",
        "context"
    ],
    [
        "COMPARE_OP",
        "context >= 0"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "LOAD_ATTR",
        "frame.f_back"
    ],
    [
        "STORE_FAST",
        "frame"
    ],
    [
        "LOAD_GLOBAL",
        "inspect"
    ],
    [
        "LOAD_METHOD",
        "inspect.getsourcefile"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "CALL_METHOD",
        "inspect.getsourcefile(frame)"
    ],
    [
        "STORE_FAST",
        "filename"
    ],
    [
        "LOAD_FAST",
        "filename"
    ],
    [
        "IS_OP",
        "filename is not None"
    ],
    [
        "LOAD_FAST",
        "context"
    ],
    [
        "STORE_FAST",
        "context"
    ],
    [
        "LOAD_GLOBAL",
        "os"
    ],
    [
        "LOAD_ATTR",
        "os.path"
    ],
    [
        "LOAD_METHOD",
        "os.path.abspath"
    ],
    [
        "LOAD_FAST",
        "filename"
    ],
    [
        "CALL_METHOD",
        "os.path.abspath(filename)"
    ],
    [
        "STORE_FAST",
        "filename"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "LOAD_ATTR",
        "frame.f_globals"
    ],
    [
        "LOAD_METHOD",
        "frame.f_globals.get"
    ],
    [
        "CALL_METHOD",
        "frame.f_globals.get('__name__')"
    ],
    [
        "COMPARE_OP",
        "frame.f_globals.get('__name__') != '__main__'"
    ],
    [
        "LOAD_GLOBAL",
        "PY3"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._treetrace_hidden_with_stmt"
    ],
    [
        "LOAD_ATTR",
        "self._treetrace_hidden_with_stmt.__name__"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "LOAD_ATTR",
        "frame.f_globals"
    ],
    [
        "CONTAINS_OP",
        "self._treetrace_hidden_with_stmt.__name__ not in frame.f_globals"
    ],
    [
        "LOAD_GLOBAL",
        "RuntimeError"
    ],
    [
        "CALL_FUNCTION",
        "RuntimeError(\n                    'To trace an imported module, you must import birdseye before '\n                    'importing that module.')"
    ],
    [
        "LOAD_GLOBAL",
        "read_source_file"
    ],
    [
        "LOAD_FAST",
        "filename"
    ],
    [
        "CALL_FUNCTION",
        "read_source_file(filename)"
    ],
    [
        "LOAD_METHOD",
        "read_source_file(filename).splitlines"
    ],
    [
        "CALL_METHOD",
        "read_source_file(filename).splitlines()"
    ],
    [
        "STORE_FAST",
        "lines"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "LOAD_ATTR",
        "frame.f_lineno"
    ],
    [
        "BINARY_MULTIPLY",
        "[''] * frame.f_lineno"
    ],
    [
        "LOAD_FAST",
        "lines"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "LOAD_ATTR",
        "frame.f_lineno"
    ],
    [
        "STORE_SUBSCR",
        "lines[:frame.f_lineno]"
    ],
    [
        "LOAD_METHOD",
        "'\\n'.join"
    ],
    [
        "LOAD_FAST",
        "lines"
    ],
    [
        "CALL_METHOD",
        "'\\n'.join(lines)"
    ],
    [
        "STORE_FAST",
        "source"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.exec_string"
    ],
    [
        "LOAD_FAST",
        "source"
    ],
    [
        "LOAD_FAST",
        "filename"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "LOAD_ATTR",
        "frame.f_globals"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "LOAD_ATTR",
        "frame.f_locals"
    ],
    [
        "LOAD_FAST",
        "deep"
    ],
    [
        "CALL_METHOD",
        "self.exec_string(source, filename, frame.f_globals, frame.f_locals, deep)"
    ],
    [
        "LOAD_GLOBAL",
        "sys"
    ],
    [
        "LOAD_METHOD",
        "sys.exit"
    ],
    [
        "CALL_METHOD",
        "sys.exit(0)"
    ],
    [
        "LOAD_FAST",
        "globs"
    ],
    [
        "STORE_FAST",
        "globs"
    ],
    [
        "LOAD_FAST",
        "locs"
    ],
    [
        "STORE_FAST",
        "locs"
    ],
    [
        "LOAD_DEREF",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.compile"
    ],
    [
        "LOAD_DEREF",
        "source"
    ],
    [
        "LOAD_DEREF",
        "filename"
    ],
    [
        "CALL_METHOD",
        "self.compile(source, filename)"
    ],
    [
        "STORE_DEREF",
        "traced_file"
    ],
    [
        "LOAD_FAST",
        "globs"
    ],
    [
        "LOAD_METHOD",
        "globs.update"
    ],
    [
        "LOAD_DEREF",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self._trace_methods_dict"
    ],
    [
        "LOAD_DEREF",
        "traced_file"
    ],
    [
        "CALL_METHOD",
        "self._trace_methods_dict(traced_file)"
    ],
    [
        "CALL_METHOD",
        "globs.update(self._trace_methods_dict(traced_file))"
    ],
    [
        "LOAD_DEREF",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self._trace"
    ],
    [
        "LOAD_GLOBAL",
        "FILE_SENTINEL_NAME"
    ],
    [
        "LOAD_DEREF",
        "filename"
    ],
    [
        "LOAD_DEREF",
        "traced_file"
    ],
    [
        "LOAD_DEREF",
        "traced_file"
    ],
    [
        "LOAD_ATTR",
        "traced_file.code"
    ],
    [
        "LOAD_DEREF",
        "source"
    ],
    [
        "CALL_METHOD",
        "self._trace(FILE_SENTINEL_NAME, filename, traced_file, traced_file.code, 'module', source)"
    ],
    [
        "LOAD_FAST",
        "deep"
    ],
    [
        "LOAD_DEREF",
        "traced_file"
    ],
    [
        "LOAD_ATTR",
        "traced_file.nodes"
    ],
    [
        "CALL_FUNCTION",
        "{\n                node.lineno: node\n                for node in traced_file.nodes\n                if isinstance(node, ast.FunctionDef)\n            }"
    ],
    [
        "STORE_DEREF",
        "nodes_by_lineno"
    ],
    [
        "STORE_DEREF",
        "            def find_code(root_code):\n                # type: (CodeType) -> None\n                for code in root_code.co_consts:  # type: CodeType\n                    if not inspect.iscode(code) or code.co_name.startswith('<'):\n                        continue\n\n                    find_code(code)\n\n                    lineno = code.co_firstlineno\n                    node = nodes_by_lineno.get(lineno)\n                    if not node:\n                        continue\n\n                    self._trace(\n                        code.co_name, filename, traced_file, code,\n                        typ='function',\n                        source=source,\n                        start_lineno=lineno,\n                        end_lineno=node.last_token.end[0] + 1,\n                    )"
    ],
    [
        "LOAD_DEREF",
        "find_code"
    ],
    [
        "LOAD_DEREF",
        "traced_file"
    ],
    [
        "LOAD_ATTR",
        "traced_file.code"
    ],
    [
        "CALL_FUNCTION",
        "find_code(traced_file.code)"
    ],
    [
        "LOAD_GLOBAL",
        "exec"
    ],
    [
        "LOAD_DEREF",
        "traced_file"
    ],
    [
        "LOAD_ATTR",
        "traced_file.code"
    ],
    [
        "LOAD_FAST",
        "globs"
    ],
    [
        "LOAD_FAST",
        "locs"
    ],
    [
        "CALL_FUNCTION",
        "exec(traced_file.code, globs, locs)"
    ],
    [
        "LOAD_FAST",
        "{\n                node.lineno: node\n                for node in traced_file.nodes\n                if isinstance(node, ast.FunctionDef)\n            }"
    ],
    [
        "STORE_FAST",
        "node"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.FunctionDef"
    ],
    [
        "CALL_FUNCTION",
        "isinstance(node, ast.FunctionDef)"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node.lineno"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_FAST",
        "root_code"
    ],
    [
        "LOAD_ATTR",
        "root_code.co_consts"
    ],
    [
        "STORE_FAST",
        "code"
    ],
    [
        "LOAD_GLOBAL",
        "inspect"
    ],
    [
        "LOAD_METHOD",
        "inspect.iscode"
    ],
    [
        "LOAD_FAST",
        "code"
    ],
    [
        "CALL_METHOD",
        "inspect.iscode(code)"
    ],
    [
        "LOAD_FAST",
        "code"
    ],
    [
        "LOAD_ATTR",
        "code.co_name"
    ],
    [
        "LOAD_METHOD",
        "code.co_name.startswith"
    ],
    [
        "CALL_METHOD",
        "code.co_name.startswith('<')"
    ],
    [
        "LOAD_DEREF",
        "find_code"
    ],
    [
        "LOAD_FAST",
        "code"
    ],
    [
        "CALL_FUNCTION",
        "find_code(code)"
    ],
    [
        "LOAD_FAST",
        "code"
    ],
    [
        "LOAD_ATTR",
        "code.co_firstlineno"
    ],
    [
        "STORE_FAST",
        "lineno"
    ],
    [
        "LOAD_DEREF",
        "nodes_by_lineno"
    ],
    [
        "LOAD_METHOD",
        "nodes_by_lineno.get"
    ],
    [
        "LOAD_FAST",
        "lineno"
    ],
    [
        "CALL_METHOD",
        "nodes_by_lineno.get(lineno)"
    ],
    [
        "STORE_FAST",
        "node"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_DEREF",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._trace"
    ],
    [
        "LOAD_FAST",
        "code"
    ],
    [
        "LOAD_ATTR",
        "code.co_name"
    ],
    [
        "LOAD_DEREF",
        "filename"
    ],
    [
        "LOAD_DEREF",
        "traced_file"
    ],
    [
        "LOAD_FAST",
        "code"
    ],
    [
        "LOAD_DEREF",
        "source"
    ],
    [
        "LOAD_FAST",
        "lineno"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node.last_token"
    ],
    [
        "LOAD_ATTR",
        "node.last_token.end"
    ],
    [
        "BINARY_SUBSCR",
        "node.last_token.end[0]"
    ],
    [
        "BINARY_ADD",
        "node.last_token.end[0] + 1"
    ],
    [
        "CALL_FUNCTION_KW",
        "self._trace(\n                        code.co_name, filename, traced_file, code,\n                        typ='function',\n                        source=source,\n                        start_lineno=lineno,\n                        end_lineno=node.last_token.end[0] + 1,\n                    )"
    ],
    [
        "LOAD_FAST",
        "end_lineno"
    ],
    [
        "LOAD_DEREF",
        "start_lineno"
    ],
    [
        "LOAD_GLOBAL",
        "len"
    ],
    [
        "LOAD_FAST",
        "source"
    ],
    [
        "LOAD_METHOD",
        "source.splitlines"
    ],
    [
        "CALL_METHOD",
        "source.splitlines()"
    ],
    [
        "CALL_FUNCTION",
        "len(source.splitlines())"
    ],
    [
        "BINARY_ADD",
        "start_lineno + len(source.splitlines())"
    ],
    [
        "STORE_FAST",
        "end_lineno"
    ],
    [
        "LOAD_GLOBAL",
        "list"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self._nodes_of_interest"
    ],
    [
        "LOAD_FAST",
        "traced_file"
    ],
    [
        "LOAD_DEREF",
        "start_lineno"
    ],
    [
        "LOAD_FAST",
        "end_lineno"
    ],
    [
        "CALL_METHOD",
        "self._nodes_of_interest(traced_file, start_lineno, end_lineno)"
    ],
    [
        "CALL_FUNCTION",
        "list(self._nodes_of_interest(traced_file, start_lineno, end_lineno))"
    ],
    [
        "STORE_FAST",
        "nodes"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self._nodes_html"
    ],
    [
        "LOAD_FAST",
        "nodes"
    ],
    [
        "LOAD_DEREF",
        "start_lineno"
    ],
    [
        "LOAD_FAST",
        "end_lineno"
    ],
    [
        "LOAD_FAST",
        "traced_file"
    ],
    [
        "CALL_METHOD",
        "self._nodes_html(nodes, start_lineno, end_lineno, traced_file)"
    ],
    [
        "STORE_FAST",
        "html_body"
    ],
    [
        "LOAD_GLOBAL",
        "dict"
    ],
    [
        "LOAD_FAST",
        "nodes"
    ],
    [
        "CALL_FUNCTION",
        "{\n                node._tree_index: [n._tree_index for n in node._loops]\n                for node, _ in nodes\n                if node._loops\n            }"
    ],
    [
        "CALL_FUNCTION_KW",
        "dict(\n            # This maps each node to the loops enclosing that node\n            node_loops={\n                node._tree_index: [n._tree_index for n in node._loops]\n                for node, _ in nodes\n                if node._loops\n            },\n        )"
    ],
    [
        "STORE_FAST",
        "data_dict"
    ],
    [
        "LOAD_FAST",
        "typ"
    ],
    [
        "COMPARE_OP",
        "typ == 'function'"
    ],
    [
        "LOAD_FAST",
        "traced_file"
    ],
    [
        "LOAD_ATTR",
        "traced_file.tokens"
    ],
    [
        "STORE_FAST",
        "tokens"
    ],
    [
        "LOAD_GLOBAL",
        "only"
    ],
    [
        "LOAD_FAST",
        "nodes"
    ],
    [
        "CALL_FUNCTION",
        "(node\n                             for node, _ in nodes\n                             if isinstance(node, ast.FunctionDef)\n                             and node.first_token.start[0] == start_lineno)"
    ],
    [
        "CALL_FUNCTION",
        "only(node\n                             for node, _ in nodes\n                             if isinstance(node, ast.FunctionDef)\n                             and node.first_token.start[0] == start_lineno)"
    ],
    [
        "STORE_FAST",
        "func_node"
    ],
    [
        "LOAD_GLOBAL",
        "source_without_decorators"
    ],
    [
        "LOAD_FAST",
        "tokens"
    ],
    [
        "LOAD_FAST",
        "func_node"
    ],
    [
        "CALL_FUNCTION",
        "source_without_decorators(tokens, func_node)"
    ],
    [
        "STORE_FAST",
        "func_startpos"
    ],
    [
        "STORE_FAST",
        "source"
    ],
    [
        "LOAD_FAST",
        "data_dict"
    ],
    [
        "LOAD_ATTR",
        "data_dict.update"
    ],
    [
        "LOAD_GLOBAL",
        "list"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self._node_ranges"
    ],
    [
        "LOAD_FAST",
        "nodes"
    ],
    [
        "LOAD_FAST",
        "tokens"
    ],
    [
        "LOAD_FAST",
        "func_startpos"
    ],
    [
        "CALL_METHOD",
        "self._node_ranges(nodes, tokens, func_startpos)"
    ],
    [
        "CALL_FUNCTION",
        "list(self._node_ranges(nodes, tokens, func_startpos))"
    ],
    [
        "LOAD_GLOBAL",
        "list"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self._loop_ranges"
    ],
    [
        "LOAD_FAST",
        "nodes"
    ],
    [
        "LOAD_FAST",
        "tokens"
    ],
    [
        "LOAD_FAST",
        "func_startpos"
    ],
    [
        "CALL_METHOD",
        "self._loop_ranges(nodes, tokens, func_startpos)"
    ],
    [
        "CALL_FUNCTION",
        "list(self._loop_ranges(nodes, tokens, func_startpos))"
    ],
    [
        "CALL_FUNCTION_KW",
        "data_dict.update(\n                node_ranges=list(self._node_ranges(nodes, tokens, func_startpos)),\n                loop_ranges=list(self._loop_ranges(nodes, tokens, func_startpos)),\n            )"
    ],
    [
        "LOAD_GLOBAL",
        "json"
    ],
    [
        "LOAD_ATTR",
        "json.dumps"
    ],
    [
        "LOAD_FAST",
        "data_dict"
    ],
    [
        "CALL_FUNCTION_KW",
        "json.dumps(data_dict, sort_keys=True)"
    ],
    [
        "STORE_FAST",
        "data"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self._db_func"
    ],
    [
        "LOAD_FAST",
        "data"
    ],
    [
        "LOAD_FAST",
        "filename"
    ],
    [
        "LOAD_FAST",
        "html_body"
    ],
    [
        "LOAD_FAST",
        "name"
    ],
    [
        "LOAD_DEREF",
        "start_lineno"
    ],
    [
        "LOAD_FAST",
        "source"
    ],
    [
        "LOAD_FAST",
        "typ"
    ],
    [
        "CALL_METHOD",
        "self._db_func(data, filename, html_body, name, start_lineno, source, typ)"
    ],
    [
        "STORE_FAST",
        "db_func"
    ],
    [
        "LOAD_GLOBAL",
        "CodeInfo"
    ],
    [
        "LOAD_FAST",
        "db_func"
    ],
    [
        "LOAD_FAST",
        "traced_file"
    ],
    [
        "LOAD_FAST",
        "arg_names"
    ],
    [
        "CALL_FUNCTION",
        "CodeInfo(db_func, traced_file, arg_names)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self._code_infos"
    ],
    [
        "LOAD_FAST",
        "code"
    ],
    [
        "STORE_SUBSCR",
        "self._code_infos[code]"
    ],
    [
        "LOAD_FAST",
        "{\n                node._tree_index: [n._tree_index for n in node._loops]\n                for node, _ in nodes\n                if node._loops\n            }"
    ],
    [
        "STORE_FAST",
        "node"
    ],
    [
        "STORE_FAST",
        "_"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node._loops"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node._tree_index"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node._loops"
    ],
    [
        "CALL_FUNCTION",
        "[n._tree_index for n in node._loops]"
    ],
    [
        "LOAD_FAST",
        "[n._tree_index for n in node._loops]"
    ],
    [
        "STORE_FAST",
        "n"
    ],
    [
        "LOAD_FAST",
        "n"
    ],
    [
        "LOAD_ATTR",
        "n._tree_index"
    ],
    [
        "LOAD_FAST",
        "(node\n                             for node, _ in nodes\n                             if isinstance(node, ast.FunctionDef)\n                             and node.first_token.start[0] == start_lineno)"
    ],
    [
        "STORE_FAST",
        "node"
    ],
    [
        "STORE_FAST",
        "_"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.FunctionDef"
    ],
    [
        "CALL_FUNCTION",
        "isinstance(node, ast.FunctionDef)"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node.first_token"
    ],
    [
        "LOAD_ATTR",
        "node.first_token.start"
    ],
    [
        "BINARY_SUBSCR",
        "node.first_token.start[0]"
    ],
    [
        "LOAD_DEREF",
        "start_lineno"
    ],
    [
        "COMPARE_OP",
        "node.first_token.start[0] == start_lineno"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_FAST",
        "nodes"
    ],
    [
        "STORE_FAST",
        "node"
    ],
    [
        "STORE_FAST",
        "classes"
    ],
    [
        "STORE_FAST",
        "_"
    ],
    [
        "STORE_FAST",
        "__"
    ],
    [
        "LOAD_FAST",
        "classes"
    ],
    [
        "CONTAINS_OP",
        "'loop' not in classes"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node.target"
    ],
    [
        "STORE_FAST",
        "target"
    ],
    [
        "LOAD_GLOBAL",
        "AttributeError"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node.test"
    ],
    [
        "STORE_FAST",
        "target"
    ],
    [
        "LOAD_FAST",
        "tokens"
    ],
    [
        "LOAD_METHOD",
        "tokens.get_text_range"
    ],
    [
        "LOAD_FAST",
        "target"
    ],
    [
        "CALL_METHOD",
        "tokens.get_text_range(target)"
    ],
    [
        "STORE_FAST",
        "start"
    ],
    [
        "STORE_FAST",
        "end"
    ],
    [
        "LOAD_FAST",
        "start"
    ],
    [
        "LOAD_FAST",
        "func_start"
    ],
    [
        "STORE_FAST",
        "start"
    ],
    [
        "LOAD_FAST",
        "end"
    ],
    [
        "LOAD_FAST",
        "func_start"
    ],
    [
        "STORE_FAST",
        "end"
    ],
    [
        "LOAD_GLOBAL",
        "dict"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node._tree_index"
    ],
    [
        "LOAD_FAST",
        "start"
    ],
    [
        "LOAD_FAST",
        "end"
    ],
    [
        "CALL_FUNCTION_KW",
        "dict(\n                tree_index=node._tree_index,\n                start=start,\n                end=end\n            )"
    ],
    [
        "LOAD_FAST",
        "nodes"
    ],
    [
        "STORE_FAST",
        "node"
    ],
    [
        "STORE_FAST",
        "classes"
    ],
    [
        "STORE_FAST",
        "_"
    ],
    [
        "STORE_FAST",
        "__"
    ],
    [
        "LOAD_FAST",
        "tokens"
    ],
    [
        "LOAD_METHOD",
        "tokens.get_text_range"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "CALL_METHOD",
        "tokens.get_text_range(node)"
    ],
    [
        "STORE_FAST",
        "start"
    ],
    [
        "STORE_FAST",
        "end"
    ],
    [
        "LOAD_FAST",
        "start"
    ],
    [
        "LOAD_FAST",
        "func_start"
    ],
    [
        "STORE_FAST",
        "start"
    ],
    [
        "LOAD_FAST",
        "end"
    ],
    [
        "LOAD_FAST",
        "func_start"
    ],
    [
        "STORE_FAST",
        "end"
    ],
    [
        "LOAD_FAST",
        "start"
    ],
    [
        "COMPARE_OP",
        "start < 0"
    ],
    [
        "LOAD_FAST",
        "end"
    ],
    [
        "COMPARE_OP",
        "end < 0"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.FunctionDef"
    ],
    [
        "CALL_FUNCTION",
        "isinstance(node, ast.FunctionDef)"
    ],
    [
        "LOAD_GLOBAL",
        "dict"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node._tree_index"
    ],
    [
        "LOAD_FAST",
        "start"
    ],
    [
        "LOAD_FAST",
        "end"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node._depth"
    ],
    [
        "LOAD_FAST",
        "classes"
    ],
    [
        "CALL_FUNCTION_KW",
        "dict(\n                tree_index=node._tree_index,\n                start=start,\n                end=end,\n                depth=node._depth,\n                classes=classes,\n            )"
    ],
    [
        "STORE_FAST",
        "        def h(s):\n            return hashlib.sha256(s.encode('utf8')).hexdigest()"
    ],
    [
        "LOAD_FAST",
        "h"
    ],
    [
        "LOAD_FAST",
        "filename"
    ],
    [
        "LOAD_FAST",
        "name"
    ],
    [
        "BINARY_ADD",
        "filename + name"
    ],
    [
        "LOAD_FAST",
        "html_body"
    ],
    [
        "BINARY_ADD",
        "filename + name + html_body"
    ],
    [
        "LOAD_FAST",
        "data"
    ],
    [
        "BINARY_ADD",
        "filename + name + html_body + data"
    ],
    [
        "LOAD_GLOBAL",
        "str"
    ],
    [
        "LOAD_FAST",
        "start_lineno"
    ],
    [
        "CALL_FUNCTION",
        "str(start_lineno)"
    ],
    [
        "BINARY_ADD",
        "filename + name + html_body + data + str(start_lineno)"
    ],
    [
        "CALL_FUNCTION",
        "h(filename + name + html_body + data + str(start_lineno))"
    ],
    [
        "STORE_FAST",
        "function_hash"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.db"
    ],
    [
        "LOAD_ATTR",
        "self.db.Function"
    ],
    [
        "STORE_FAST",
        "Function"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.db"
    ],
    [
        "LOAD_METHOD",
        "self.db.session_scope"
    ],
    [
        "CALL_METHOD",
        "self.db.session_scope()"
    ],
    [
        "STORE_FAST",
        "session"
    ],
    [
        "LOAD_GLOBAL",
        "one_or_none"
    ],
    [
        "LOAD_FAST",
        "session"
    ],
    [
        "LOAD_METHOD",
        "session.query"
    ],
    [
        "LOAD_FAST",
        "Function"
    ],
    [
        "CALL_METHOD",
        "session.query(Function)"
    ],
    [
        "LOAD_ATTR",
        "session.query(Function).filter_by"
    ],
    [
        "LOAD_FAST",
        "function_hash"
    ],
    [
        "CALL_FUNCTION_KW",
        "session.query(Function).filter_by(hash=function_hash)"
    ],
    [
        "CALL_FUNCTION",
        "one_or_none(session.query(Function).filter_by(hash=function_hash))"
    ],
    [
        "STORE_FAST",
        "db_func"
    ],
    [
        "LOAD_FAST",
        "db_func"
    ],
    [
        "LOAD_FAST",
        "Function"
    ],
    [
        "LOAD_FAST",
        "filename"
    ],
    [
        "LOAD_FAST",
        "name"
    ],
    [
        "LOAD_FAST",
        "typ"
    ],
    [
        "LOAD_FAST",
        "html_body"
    ],
    [
        "LOAD_FAST",
        "start_lineno"
    ],
    [
        "LOAD_FAST",
        "data"
    ],
    [
        "LOAD_FAST",
        "h"
    ],
    [
        "LOAD_FAST",
        "source"
    ],
    [
        "CALL_FUNCTION",
        "h(source)"
    ],
    [
        "LOAD_FAST",
        "function_hash"
    ],
    [
        "CALL_FUNCTION_KW",
        "Function(file=filename,\n                                   name=name,\n                                   type=typ,\n                                   html_body=html_body,\n                                   lineno=start_lineno,\n                                   data=data,\n                                   body_hash=h(source),\n                                   hash=function_hash)"
    ],
    [
        "STORE_FAST",
        "db_func"
    ],
    [
        "LOAD_FAST",
        "session"
    ],
    [
        "LOAD_METHOD",
        "session.add"
    ],
    [
        "LOAD_FAST",
        "db_func"
    ],
    [
        "CALL_METHOD",
        "session.add(db_func)"
    ],
    [
        "LOAD_FAST",
        "session"
    ],
    [
        "LOAD_METHOD",
        "session.commit"
    ],
    [
        "CALL_METHOD",
        "session.commit()"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "db_func"
    ],
    [
        "LOAD_ATTR",
        "db_func.id"
    ],
    [
        "LOAD_GLOBAL",
        "int"
    ],
    [
        "CALL_FUNCTION",
        "isinstance(db_func.id, int)"
    ],
    [
        "LOAD_FAST",
        "db_func"
    ],
    [
        "LOAD_ATTR",
        "db_func.id"
    ],
    [
        "LOAD_GLOBAL",
        "hashlib"
    ],
    [
        "LOAD_METHOD",
        "hashlib.sha256"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "LOAD_METHOD",
        "s.encode"
    ],
    [
        "CALL_METHOD",
        "s.encode('utf8')"
    ],
    [
        "CALL_METHOD",
        "hashlib.sha256(s.encode('utf8'))"
    ],
    [
        "LOAD_METHOD",
        "hashlib.sha256(s.encode('utf8')).hexdigest"
    ],
    [
        "CALL_METHOD",
        "hashlib.sha256(s.encode('utf8')).hexdigest()"
    ],
    [
        "LOAD_FAST",
        "traced_file"
    ],
    [
        "LOAD_ATTR",
        "traced_file.nodes"
    ],
    [
        "STORE_FAST",
        "node"
    ],
    [
        "STORE_FAST",
        "classes"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.While"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.For"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.comprehension"
    ],
    [
        "CALL_FUNCTION",
        "isinstance(node, (ast.While, ast.For, ast.comprehension))"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node.parent"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.GeneratorExp"
    ],
    [
        "CALL_FUNCTION",
        "isinstance(node.parent, ast.GeneratorExp)"
    ],
    [
        "LOAD_FAST",
        "classes"
    ],
    [
        "LOAD_METHOD",
        "classes.append"
    ],
    [
        "CALL_METHOD",
        "classes.append('loop')"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.stmt"
    ],
    [
        "CALL_FUNCTION",
        "isinstance(node, ast.stmt)"
    ],
    [
        "LOAD_FAST",
        "classes"
    ],
    [
        "LOAD_METHOD",
        "classes.append"
    ],
    [
        "CALL_METHOD",
        "classes.append('stmt')"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.expr"
    ],
    [
        "CALL_FUNCTION",
        "isinstance(node, ast.expr)"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node._is_interesting_expression"
    ],
    [
        "LOAD_FAST",
        "classes"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.AST"
    ],
    [
        "CALL_FUNCTION",
        "isinstance(node, ast.AST)"
    ],
    [
        "LOAD_GLOBAL",
        "hasattr"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "CALL_FUNCTION",
        "hasattr(node, 'first_token')"
    ],
    [
        "LOAD_FAST",
        "start_lineno"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node.first_token"
    ],
    [
        "LOAD_ATTR",
        "node.first_token.start"
    ],
    [
        "BINARY_SUBSCR",
        "node.first_token.start[0]"
    ],
    [
        "LOAD_FAST",
        "end_lineno"
    ],
    [
        "LOAD_FAST",
        "traced_file"
    ],
    [
        "LOAD_ATTR",
        "traced_file.tokens"
    ],
    [
        "LOAD_METHOD",
        "traced_file.tokens.get_text_range"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "CALL_METHOD",
        "traced_file.tokens.get_text_range(node)"
    ],
    [
        "STORE_FAST",
        "start"
    ],
    [
        "STORE_FAST",
        "end"
    ],
    [
        "LOAD_FAST",
        "start"
    ],
    [
        "LOAD_FAST",
        "end"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_FAST",
        "classes"
    ],
    [
        "LOAD_FAST",
        "start"
    ],
    [
        "LOAD_FAST",
        "end"
    ],
    [
        "LOAD_FAST",
        "traced_file"
    ],
    [
        "LOAD_ATTR",
        "traced_file.root"
    ],
    [
        "STORE_ATTR",
        "traced_file.root._depth"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_METHOD",
        "ast.walk"
    ],
    [
        "LOAD_FAST",
        "traced_file"
    ],
    [
        "LOAD_ATTR",
        "traced_file.root"
    ],
    [
        "CALL_METHOD",
        "ast.walk(traced_file.root)"
    ],
    [
        "STORE_FAST",
        "node"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_METHOD",
        "ast.iter_child_nodes"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "CALL_METHOD",
        "ast.iter_child_nodes(node)"
    ],
    [
        "STORE_FAST",
        "child"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node._depth"
    ],
    [
        "BINARY_ADD",
        "node._depth + 1"
    ],
    [
        "LOAD_FAST",
        "child"
    ],
    [
        "STORE_ATTR",
        "child._depth"
    ],
    [
        "STORE_FAST",
        "positions"
    ],
    [
        "LOAD_FAST",
        "nodes"
    ],
    [
        "STORE_FAST",
        "node"
    ],
    [
        "STORE_FAST",
        "classes"
    ],
    [
        "STORE_FAST",
        "start"
    ],
    [
        "STORE_FAST",
        "end"
    ],
    [
        "LOAD_FAST",
        "positions"
    ],
    [
        "LOAD_METHOD",
        "positions.extend"
    ],
    [
        "LOAD_GLOBAL",
        "map"
    ],
    [
        "LOAD_GLOBAL",
        "HTMLPosition"
    ],
    [
        "LOAD_FAST",
        "start"
    ],
    [
        "LOAD_FAST",
        "end"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node._depth"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node._depth"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node._tree_index"
    ],
    [
        "LOAD_METHOD",
        "' '.join"
    ],
    [
        "LOAD_FAST",
        "classes"
    ],
    [
        "CALL_METHOD",
        "' '.join(classes)"
    ],
    [
        "BINARY_MODULO",
        "'<span data-index=\"%s\" class=\"%s\">' % (node._tree_index, ' '.join(classes))"
    ],
    [
        "CALL_FUNCTION",
        "map(\n                HTMLPosition,\n                [start, end],\n                [True, False],  # is_start\n                [node._depth, node._depth],\n                ['<span data-index=\"%s\" class=\"%s\">' % (node._tree_index, ' '.join(classes)),\n                 '</span>'])"
    ],
    [
        "CALL_METHOD",
        "positions.extend(map(\n                HTMLPosition,\n                [start, end],\n                [True, False],  # is_start\n                [node._depth, node._depth],\n                ['<span data-index=\"%s\" class=\"%s\">' % (node._tree_index, ' '.join(classes)),\n                 '</span>']))"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self._separate_comprehensions"
    ],
    [
        "LOAD_FAST",
        "nodes"
    ],
    [
        "CALL_FUNCTION",
        "[n[0] for n in nodes]"
    ],
    [
        "LOAD_FAST",
        "end_lineno"
    ],
    [
        "LOAD_FAST",
        "positions"
    ],
    [
        "LOAD_FAST",
        "traced_file"
    ],
    [
        "CALL_METHOD",
        "self._separate_comprehensions(\n            [n[0] for n in nodes],\n            end_lineno, positions, traced_file)"
    ],
    [
        "STORE_FAST",
        "end_lineno"
    ],
    [
        "LOAD_FAST",
        "positions"
    ],
    [
        "LOAD_METHOD",
        "positions.append"
    ],
    [
        "LOAD_GLOBAL",
        "HTMLPosition"
    ],
    [
        "LOAD_GLOBAL",
        "len"
    ],
    [
        "LOAD_FAST",
        "traced_file"
    ],
    [
        "LOAD_ATTR",
        "traced_file.source"
    ],
    [
        "CALL_FUNCTION",
        "len(traced_file.source)"
    ],
    [
        "CALL_FUNCTION",
        "HTMLPosition(len(traced_file.source), False, 0, '')"
    ],
    [
        "CALL_METHOD",
        "positions.append(HTMLPosition(len(traced_file.source), False, 0, ''))"
    ],
    [
        "LOAD_FAST",
        "positions"
    ],
    [
        "LOAD_METHOD",
        "positions.sort"
    ],
    [
        "CALL_METHOD",
        "positions.sort()"
    ],
    [
        "STORE_FAST",
        "html_parts"
    ],
    [
        "STORE_FAST",
        "start"
    ],
    [
        "LOAD_FAST",
        "positions"
    ],
    [
        "STORE_FAST",
        "position"
    ],
    [
        "LOAD_FAST",
        "html_parts"
    ],
    [
        "LOAD_METHOD",
        "html_parts.append"
    ],
    [
        "LOAD_GLOBAL",
        "html"
    ],
    [
        "LOAD_METHOD",
        "html.escape"
    ],
    [
        "LOAD_FAST",
        "traced_file"
    ],
    [
        "LOAD_ATTR",
        "traced_file.source"
    ],
    [
        "LOAD_FAST",
        "start"
    ],
    [
        "LOAD_FAST",
        "position"
    ],
    [
        "LOAD_ATTR",
        "position.index"
    ],
    [
        "BINARY_SUBSCR",
        "traced_file.source[start:position.index]"
    ],
    [
        "CALL_METHOD",
        "html.escape(traced_file.source[start:position.index])"
    ],
    [
        "CALL_METHOD",
        "html_parts.append(html.escape(traced_file.source[start:position.index]))"
    ],
    [
        "LOAD_FAST",
        "html_parts"
    ],
    [
        "LOAD_METHOD",
        "html_parts.append"
    ],
    [
        "LOAD_FAST",
        "position"
    ],
    [
        "LOAD_ATTR",
        "position.html"
    ],
    [
        "CALL_METHOD",
        "html_parts.append(position.html)"
    ],
    [
        "LOAD_FAST",
        "position"
    ],
    [
        "LOAD_ATTR",
        "position.index"
    ],
    [
        "STORE_FAST",
        "start"
    ],
    [
        "LOAD_METHOD",
        "''.join"
    ],
    [
        "LOAD_FAST",
        "html_parts"
    ],
    [
        "CALL_METHOD",
        "''.join(html_parts)"
    ],
    [
        "STORE_FAST",
        "html_body"
    ],
    [
        "LOAD_METHOD",
        "'\\n'.join"
    ],
    [
        "LOAD_FAST",
        "html_body"
    ],
    [
        "LOAD_METHOD",
        "html_body.split"
    ],
    [
        "CALL_METHOD",
        "html_body.split('\\n')"
    ],
    [
        "LOAD_FAST",
        "start_lineno"
    ],
    [
        "BINARY_SUBTRACT",
        "start_lineno - 1"
    ],
    [
        "LOAD_FAST",
        "end_lineno"
    ],
    [
        "BINARY_SUBTRACT",
        "end_lineno - 1"
    ],
    [
        "BINARY_SUBSCR",
        "html_body.split('\\n')[start_lineno - 1:end_lineno - 1]"
    ],
    [
        "CALL_METHOD",
        "'\\n'.join(html_body.split('\\n')[start_lineno - 1:end_lineno - 1])"
    ],
    [
        "STORE_FAST",
        "html_body"
    ],
    [
        "LOAD_FAST",
        "html_body"
    ],
    [
        "LOAD_METHOD",
        "html_body.strip"
    ],
    [
        "CALL_METHOD",
        "html_body.strip('\\n')"
    ],
    [
        "LOAD_FAST",
        "[n[0] for n in nodes]"
    ],
    [
        "STORE_FAST",
        "n"
    ],
    [
        "LOAD_FAST",
        "n"
    ],
    [
        "BINARY_SUBSCR",
        "n[0]"
    ],
    [
        "LOAD_GLOBAL",
        "group_by_key_func"
    ],
    [
        "LOAD_GLOBAL",
        "of_type"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.comprehension"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.While"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.For"
    ],
    [
        "LOAD_FAST",
        "nodes"
    ],
    [
        "CALL_FUNCTION",
        "of_type((ast.comprehension, ast.While, ast.For), nodes)"
    ],
    [
        "CALL_FUNCTION",
        "group_by_key_func(of_type((ast.comprehension, ast.While, ast.For), nodes),\n                                           lambda c: c.first_token.start[0]\n                                           )"
    ],
    [
        "STORE_FAST",
        "comprehensions"
    ],
    [
        "STORE_FAST",
        "        def get_start(n):\n            # type: (ast.AST) -> int\n            return traced_file.tokens.get_text_range(n)[0]"
    ],
    [
        "LOAD_FAST",
        "comprehensions"
    ],
    [
        "LOAD_METHOD",
        "comprehensions.values"
    ],
    [
        "CALL_METHOD",
        "comprehensions.values()"
    ],
    [
        "STORE_FAST",
        "comp_list"
    ],
    [
        "STORE_FAST",
        "prev_start"
    ],
    [
        "LOAD_GLOBAL",
        "sorted"
    ],
    [
        "LOAD_FAST",
        "comp_list"
    ],
    [
        "CALL_FUNCTION_KW",
        "sorted(comp_list, key=lambda c: c.first_token.startpos)"
    ],
    [
        "STORE_FAST",
        "comp"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "comp"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.comprehension"
    ],
    [
        "CALL_FUNCTION",
        "isinstance(comp, ast.comprehension)"
    ],
    [
        "LOAD_FAST",
        "comp"
    ],
    [
        "LOAD_FAST",
        "comp"
    ],
    [
        "LOAD_ATTR",
        "comp.parent"
    ],
    [
        "LOAD_ATTR",
        "comp.parent.generators"
    ],
    [
        "BINARY_SUBSCR",
        "comp.parent.generators[0]"
    ],
    [
        "IS_OP",
        "comp is comp.parent.generators[0]"
    ],
    [
        "LOAD_FAST",
        "get_start"
    ],
    [
        "LOAD_FAST",
        "comp"
    ],
    [
        "LOAD_ATTR",
        "comp.parent"
    ],
    [
        "CALL_FUNCTION",
        "get_start(comp.parent)"
    ],
    [
        "STORE_FAST",
        "start"
    ],
    [
        "LOAD_FAST",
        "prev_start"
    ],
    [
        "IS_OP",
        "prev_start is not None"
    ],
    [
        "LOAD_FAST",
        "start"
    ],
    [
        "LOAD_FAST",
        "prev_start"
    ],
    [
        "COMPARE_OP",
        "start < prev_start"
    ],
    [
        "LOAD_FAST",
        "get_start"
    ],
    [
        "LOAD_FAST",
        "comp"
    ],
    [
        "CALL_FUNCTION",
        "get_start(comp)"
    ],
    [
        "STORE_FAST",
        "start"
    ],
    [
        "LOAD_FAST",
        "get_start"
    ],
    [
        "LOAD_FAST",
        "comp"
    ],
    [
        "CALL_FUNCTION",
        "get_start(comp)"
    ],
    [
        "STORE_FAST",
        "start"
    ],
    [
        "LOAD_FAST",
        "prev_start"
    ],
    [
        "IS_OP",
        "prev_start is not None"
    ],
    [
        "LOAD_FAST",
        "positions"
    ],
    [
        "LOAD_METHOD",
        "positions.append"
    ],
    [
        "LOAD_GLOBAL",
        "HTMLPosition"
    ],
    [
        "LOAD_FAST",
        "start"
    ],
    [
        "CALL_FUNCTION",
        "HTMLPosition(start, True, 0, '\\n ')"
    ],
    [
        "CALL_METHOD",
        "positions.append(HTMLPosition(start, True, 0, '\\n '))"
    ],
    [
        "LOAD_FAST",
        "end_lineno"
    ],
    [
        "STORE_FAST",
        "end_lineno"
    ],
    [
        "LOAD_FAST",
        "start"
    ],
    [
        "STORE_FAST",
        "prev_start"
    ],
    [
        "LOAD_FAST",
        "end_lineno"
    ],
    [
        "LOAD_FAST",
        "c"
    ],
    [
        "LOAD_ATTR",
        "c.first_token"
    ],
    [
        "LOAD_ATTR",
        "c.first_token.start"
    ],
    [
        "BINARY_SUBSCR",
        "c.first_token.start[0]"
    ],
    [
        "LOAD_DEREF",
        "traced_file"
    ],
    [
        "LOAD_ATTR",
        "traced_file.tokens"
    ],
    [
        "LOAD_METHOD",
        "traced_file.tokens.get_text_range"
    ],
    [
        "LOAD_FAST",
        "n"
    ],
    [
        "CALL_METHOD",
        "traced_file.tokens.get_text_range(n)"
    ],
    [
        "BINARY_SUBSCR",
        "traced_file.tokens.get_text_range(n)[0]"
    ],
    [
        "LOAD_FAST",
        "c"
    ],
    [
        "LOAD_ATTR",
        "c.first_token"
    ],
    [
        "LOAD_ATTR",
        "c.first_token.startpos"
    ],
    [
        "LOAD_GLOBAL",
        "defaultdict"
    ],
    [
        "LOAD_GLOBAL",
        "_deep_dict"
    ],
    [
        "CALL_FUNCTION",
        "defaultdict(_deep_dict)"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "LOAD_ATTR",
        "frame.f_code"
    ],
    [
        "LOAD_GLOBAL",
        "_bad_codes"
    ],
    [
        "CONTAINS_OP",
        "frame.f_code in _bad_codes"
    ],
    [
        "LOAD_FAST",
        "frame"
    ],
    [
        "LOAD_ATTR",
        "frame.f_back"
    ],
    [
        "STORE_FAST",
        "frame"
    ],
    [
        "LOAD_NAME",
        "class Iteration(object):\n    \"\"\"\n    Corresponds to an iteration of a loop during a call, OR\n    the call itself (FrameInfo.iteration).\n    \"\"\"\n\n    def __init__(self):\n        # Mapping of nodes (via node._tree_index) to the value of that\n        # node in this iteration. Only contains nodes within the corresponding\n        # loop or at the top of the function, but not in loops further within\n        # (those will be somewhere within self.loops)\n        # Therefore those nodes have at most one value.\n        self.vals = {}  # type: Dict[int, NodeValue]\n\n        # Mapping of loop nodes (via node._tree_index) to IterationLists\n        # for loops that happened during this iteration\n        self.loops = defaultdict(IterationList)  # type: Dict[int, IterationList]\n\n        # 0-based index of this iteration\n        self.index = None  # type: int\n        self.keep = False\n\n    def extract_iterations(self):\n        # type: () -> Dict[str, Union[int, Dict]]\n        return {\n            'index': self.index,\n            'loops': {\n                tree_index: [iteration.extract_iterations()\n                             for iteration in iteration_list]\n                for tree_index, iteration_list in self.loops.items()\n            }\n        }"
    ],
    [
        "STORE_NAME",
        "class Iteration(object):\n    \"\"\"\n    Corresponds to an iteration of a loop during a call, OR\n    the call itself (FrameInfo.iteration).\n    \"\"\"\n\n    def __init__(self):\n        # Mapping of nodes (via node._tree_index) to the value of that\n        # node in this iteration. Only contains nodes within the corresponding\n        # loop or at the top of the function, but not in loops further within\n        # (those will be somewhere within self.loops)\n        # Therefore those nodes have at most one value.\n        self.vals = {}  # type: Dict[int, NodeValue]\n\n        # Mapping of loop nodes (via node._tree_index) to IterationLists\n        # for loops that happened during this iteration\n        self.loops = defaultdict(IterationList)  # type: Dict[int, IterationList]\n\n        # 0-based index of this iteration\n        self.index = None  # type: int\n        self.keep = False\n\n    def extract_iterations(self):\n        # type: () -> Dict[str, Union[int, Dict]]\n        return {\n            'index': self.index,\n            'loops': {\n                tree_index: [iteration.extract_iterations()\n                             for iteration in iteration_list]\n                for tree_index, iteration_list in self.loops.items()\n            }\n        }"
    ],
    [
        "STORE_NAME",
        "class Iteration(object):\n    \"\"\"\n    Corresponds to an iteration of a loop during a call, OR\n    the call itself (FrameInfo.iteration).\n    \"\"\"\n\n    def __init__(self):\n        # Mapping of nodes (via node._tree_index) to the value of that\n        # node in this iteration. Only contains nodes within the corresponding\n        # loop or at the top of the function, but not in loops further within\n        # (those will be somewhere within self.loops)\n        # Therefore those nodes have at most one value.\n        self.vals = {}  # type: Dict[int, NodeValue]\n\n        # Mapping of loop nodes (via node._tree_index) to IterationLists\n        # for loops that happened during this iteration\n        self.loops = defaultdict(IterationList)  # type: Dict[int, IterationList]\n\n        # 0-based index of this iteration\n        self.index = None  # type: int\n        self.keep = False\n\n    def extract_iterations(self):\n        # type: () -> Dict[str, Union[int, Dict]]\n        return {\n            'index': self.index,\n            'loops': {\n                tree_index: [iteration.extract_iterations()\n                             for iteration in iteration_list]\n                for tree_index, iteration_list in self.loops.items()\n            }\n        }"
    ],
    [
        "STORE_NAME",
        "\"\"\"\n    Corresponds to an iteration of a loop during a call, OR\n    the call itself (FrameInfo.iteration).\n    \"\"\""
    ],
    [
        "STORE_NAME",
        "    def __init__(self):\n        # Mapping of nodes (via node._tree_index) to the value of that\n        # node in this iteration. Only contains nodes within the corresponding\n        # loop or at the top of the function, but not in loops further within\n        # (those will be somewhere within self.loops)\n        # Therefore those nodes have at most one value.\n        self.vals = {}  # type: Dict[int, NodeValue]\n\n        # Mapping of loop nodes (via node._tree_index) to IterationLists\n        # for loops that happened during this iteration\n        self.loops = defaultdict(IterationList)  # type: Dict[int, IterationList]\n\n        # 0-based index of this iteration\n        self.index = None  # type: int\n        self.keep = False"
    ],
    [
        "STORE_NAME",
        "    def extract_iterations(self):\n        # type: () -> Dict[str, Union[int, Dict]]\n        return {\n            'index': self.index,\n            'loops': {\n                tree_index: [iteration.extract_iterations()\n                             for iteration in iteration_list]\n                for tree_index, iteration_list in self.loops.items()\n            }\n        }"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.vals"
    ],
    [
        "LOAD_GLOBAL",
        "defaultdict"
    ],
    [
        "LOAD_GLOBAL",
        "IterationList"
    ],
    [
        "CALL_FUNCTION",
        "defaultdict(IterationList)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.loops"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.index"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.keep"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.index"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.loops"
    ],
    [
        "LOAD_METHOD",
        "self.loops.items"
    ],
    [
        "CALL_METHOD",
        "self.loops.items()"
    ],
    [
        "CALL_FUNCTION",
        "{\n                tree_index: [iteration.extract_iterations()\n                             for iteration in iteration_list]\n                for tree_index, iteration_list in self.loops.items()\n            }"
    ],
    [
        "LOAD_FAST",
        "{\n                tree_index: [iteration.extract_iterations()\n                             for iteration in iteration_list]\n                for tree_index, iteration_list in self.loops.items()\n            }"
    ],
    [
        "STORE_FAST",
        "tree_index"
    ],
    [
        "STORE_FAST",
        "iteration_list"
    ],
    [
        "LOAD_FAST",
        "tree_index"
    ],
    [
        "LOAD_FAST",
        "iteration_list"
    ],
    [
        "CALL_FUNCTION",
        "[iteration.extract_iterations()\n                             for iteration in iteration_list]"
    ],
    [
        "LOAD_FAST",
        "[iteration.extract_iterations()\n                             for iteration in iteration_list]"
    ],
    [
        "STORE_FAST",
        "iteration"
    ],
    [
        "LOAD_FAST",
        "iteration"
    ],
    [
        "LOAD_METHOD",
        "iteration.extract_iterations"
    ],
    [
        "CALL_METHOD",
        "iteration.extract_iterations()"
    ],
    [
        "LOAD_NAME",
        "class IterationList(Iterable[Iteration]):\n    \"\"\"\n    A list of Iterations, corresponding to a run of a loop.\n    If the loop has many iterations, only contains the first and last few\n    and any in the middle where unique nodes had values, so that\n    any node which appeared during this loop exists in at least some iterations.\n    \"\"\"\n    side_len = 3\n\n    def __init__(self):\n        # Contains the first few iterations\n        # and any after that have unique nodes in them\n        self.start = []  # type: List[Iteration]\n\n        # Contains the last few iterations\n        self.end = deque(maxlen=self.side_len)  # type: Deque[Iteration]\n\n        # Total number of iterations in the loop, not all of which\n        # are kept\n        self.length = 0  # type: int\n\n        # Number of times each node has been recorded in this loop\n        self.recorded = Counter()\n\n    def append(self, iteration):\n        # type: (Iteration) -> None\n        if self.length < self.side_len:\n            self.start.append(iteration)\n        else:\n            # If self.end is too long, the first element self.end[0]\n            # is about to be dropped by the deque. If that iteration\n            # should be kept because of some node that was recorded,\n            # add it to self.start\n            if len(self.end) >= self.side_len and self.end[0].keep:\n                self.start.append(self.end[0])\n\n            self.end.append(iteration)\n        iteration.index = self.length\n        self.length += 1\n\n    def __iter__(self):\n        # type: () -> Iterator[Iteration]\n        return chain(self.start, self.end)\n\n    def last(self):\n        # type: () -> Iteration\n        if self.end:\n            return self.end[-1]\n        else:\n            return self.start[-1]\n\n    def recorded_node(self, node):\n        # type: (ast.AST) -> None\n        if self.recorded[node] >= 2:\n            # We've already seen this node enough\n            return\n\n        # This node is new(ish), make sure we keep this iteration\n        self.last().keep = True\n        self.recorded[node] += 1"
    ],
    [
        "STORE_NAME",
        "class IterationList(Iterable[Iteration]):\n    \"\"\"\n    A list of Iterations, corresponding to a run of a loop.\n    If the loop has many iterations, only contains the first and last few\n    and any in the middle where unique nodes had values, so that\n    any node which appeared during this loop exists in at least some iterations.\n    \"\"\"\n    side_len = 3\n\n    def __init__(self):\n        # Contains the first few iterations\n        # and any after that have unique nodes in them\n        self.start = []  # type: List[Iteration]\n\n        # Contains the last few iterations\n        self.end = deque(maxlen=self.side_len)  # type: Deque[Iteration]\n\n        # Total number of iterations in the loop, not all of which\n        # are kept\n        self.length = 0  # type: int\n\n        # Number of times each node has been recorded in this loop\n        self.recorded = Counter()\n\n    def append(self, iteration):\n        # type: (Iteration) -> None\n        if self.length < self.side_len:\n            self.start.append(iteration)\n        else:\n            # If self.end is too long, the first element self.end[0]\n            # is about to be dropped by the deque. If that iteration\n            # should be kept because of some node that was recorded,\n            # add it to self.start\n            if len(self.end) >= self.side_len and self.end[0].keep:\n                self.start.append(self.end[0])\n\n            self.end.append(iteration)\n        iteration.index = self.length\n        self.length += 1\n\n    def __iter__(self):\n        # type: () -> Iterator[Iteration]\n        return chain(self.start, self.end)\n\n    def last(self):\n        # type: () -> Iteration\n        if self.end:\n            return self.end[-1]\n        else:\n            return self.start[-1]\n\n    def recorded_node(self, node):\n        # type: (ast.AST) -> None\n        if self.recorded[node] >= 2:\n            # We've already seen this node enough\n            return\n\n        # This node is new(ish), make sure we keep this iteration\n        self.last().keep = True\n        self.recorded[node] += 1"
    ],
    [
        "STORE_NAME",
        "class IterationList(Iterable[Iteration]):\n    \"\"\"\n    A list of Iterations, corresponding to a run of a loop.\n    If the loop has many iterations, only contains the first and last few\n    and any in the middle where unique nodes had values, so that\n    any node which appeared during this loop exists in at least some iterations.\n    \"\"\"\n    side_len = 3\n\n    def __init__(self):\n        # Contains the first few iterations\n        # and any after that have unique nodes in them\n        self.start = []  # type: List[Iteration]\n\n        # Contains the last few iterations\n        self.end = deque(maxlen=self.side_len)  # type: Deque[Iteration]\n\n        # Total number of iterations in the loop, not all of which\n        # are kept\n        self.length = 0  # type: int\n\n        # Number of times each node has been recorded in this loop\n        self.recorded = Counter()\n\n    def append(self, iteration):\n        # type: (Iteration) -> None\n        if self.length < self.side_len:\n            self.start.append(iteration)\n        else:\n            # If self.end is too long, the first element self.end[0]\n            # is about to be dropped by the deque. If that iteration\n            # should be kept because of some node that was recorded,\n            # add it to self.start\n            if len(self.end) >= self.side_len and self.end[0].keep:\n                self.start.append(self.end[0])\n\n            self.end.append(iteration)\n        iteration.index = self.length\n        self.length += 1\n\n    def __iter__(self):\n        # type: () -> Iterator[Iteration]\n        return chain(self.start, self.end)\n\n    def last(self):\n        # type: () -> Iteration\n        if self.end:\n            return self.end[-1]\n        else:\n            return self.start[-1]\n\n    def recorded_node(self, node):\n        # type: (ast.AST) -> None\n        if self.recorded[node] >= 2:\n            # We've already seen this node enough\n            return\n\n        # This node is new(ish), make sure we keep this iteration\n        self.last().keep = True\n        self.recorded[node] += 1"
    ],
    [
        "STORE_NAME",
        "\"\"\"\n    A list of Iterations, corresponding to a run of a loop.\n    If the loop has many iterations, only contains the first and last few\n    and any in the middle where unique nodes had values, so that\n    any node which appeared during this loop exists in at least some iterations.\n    \"\"\""
    ],
    [
        "STORE_NAME",
        "side_len"
    ],
    [
        "STORE_NAME",
        "    def __init__(self):\n        # Contains the first few iterations\n        # and any after that have unique nodes in them\n        self.start = []  # type: List[Iteration]\n\n        # Contains the last few iterations\n        self.end = deque(maxlen=self.side_len)  # type: Deque[Iteration]\n\n        # Total number of iterations in the loop, not all of which\n        # are kept\n        self.length = 0  # type: int\n\n        # Number of times each node has been recorded in this loop\n        self.recorded = Counter()"
    ],
    [
        "STORE_NAME",
        "    def append(self, iteration):\n        # type: (Iteration) -> None\n        if self.length < self.side_len:\n            self.start.append(iteration)\n        else:\n            # If self.end is too long, the first element self.end[0]\n            # is about to be dropped by the deque. If that iteration\n            # should be kept because of some node that was recorded,\n            # add it to self.start\n            if len(self.end) >= self.side_len and self.end[0].keep:\n                self.start.append(self.end[0])\n\n            self.end.append(iteration)\n        iteration.index = self.length\n        self.length += 1"
    ],
    [
        "STORE_NAME",
        "    def __iter__(self):\n        # type: () -> Iterator[Iteration]\n        return chain(self.start, self.end)"
    ],
    [
        "STORE_NAME",
        "    def last(self):\n        # type: () -> Iteration\n        if self.end:\n            return self.end[-1]\n        else:\n            return self.start[-1]"
    ],
    [
        "STORE_NAME",
        "    def recorded_node(self, node):\n        # type: (ast.AST) -> None\n        if self.recorded[node] >= 2:\n            # We've already seen this node enough\n            return\n\n        # This node is new(ish), make sure we keep this iteration\n        self.last().keep = True\n        self.recorded[node] += 1"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.start"
    ],
    [
        "LOAD_GLOBAL",
        "deque"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.side_len"
    ],
    [
        "CALL_FUNCTION_KW",
        "deque(maxlen=self.side_len)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.end"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.length"
    ],
    [
        "LOAD_GLOBAL",
        "Counter"
    ],
    [
        "CALL_FUNCTION",
        "Counter()"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.recorded"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.length"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.side_len"
    ],
    [
        "COMPARE_OP",
        "self.length < self.side_len"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.start"
    ],
    [
        "LOAD_METHOD",
        "self.start.append"
    ],
    [
        "LOAD_FAST",
        "iteration"
    ],
    [
        "CALL_METHOD",
        "self.start.append(iteration)"
    ],
    [
        "LOAD_GLOBAL",
        "len"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.end"
    ],
    [
        "CALL_FUNCTION",
        "len(self.end)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.side_len"
    ],
    [
        "COMPARE_OP",
        "len(self.end) >= self.side_len"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.end"
    ],
    [
        "BINARY_SUBSCR",
        "self.end[0]"
    ],
    [
        "LOAD_ATTR",
        "self.end[0].keep"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.start"
    ],
    [
        "LOAD_METHOD",
        "self.start.append"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.end"
    ],
    [
        "BINARY_SUBSCR",
        "self.end[0]"
    ],
    [
        "CALL_METHOD",
        "self.start.append(self.end[0])"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.end"
    ],
    [
        "LOAD_METHOD",
        "self.end.append"
    ],
    [
        "LOAD_FAST",
        "iteration"
    ],
    [
        "CALL_METHOD",
        "self.end.append(iteration)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.length"
    ],
    [
        "LOAD_FAST",
        "iteration"
    ],
    [
        "STORE_ATTR",
        "iteration.index"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.length"
    ],
    [
        "STORE_ATTR",
        "self.length"
    ],
    [
        "LOAD_GLOBAL",
        "chain"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.start"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.end"
    ],
    [
        "CALL_FUNCTION",
        "chain(self.start, self.end)"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.end"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.end"
    ],
    [
        "BINARY_SUBSCR",
        "self.end[-1]"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.start"
    ],
    [
        "BINARY_SUBSCR",
        "self.start[-1]"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.recorded"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "BINARY_SUBSCR",
        "self.recorded[node]"
    ],
    [
        "COMPARE_OP",
        "self.recorded[node] >= 2"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_METHOD",
        "self.last"
    ],
    [
        "CALL_METHOD",
        "self.last()"
    ],
    [
        "STORE_ATTR",
        "self.last().keep"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.recorded"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "BINARY_SUBSCR",
        "self.recorded[node]"
    ],
    [
        "STORE_SUBSCR",
        "self.recorded[node]"
    ],
    [
        "LOAD_NAME",
        "class TypeRegistry(object):\n    basic_types = (type(None), bool, int, float, complex)\n    if PY2:\n        basic_types += (long,)\n    special_types = basic_types + (list, dict, tuple, set, frozenset, str)\n    if PY2:\n        special_types += (unicode if PY2 else bytes,)\n\n    num_special_types = len(special_types)\n\n    def __init__(self):\n        self.lock = Lock()\n        self.data = defaultdict(lambda: len(self.data))  # type: Dict[type, int]\n\n        for t in self.special_types:\n            _ = self.data[t]\n\n    def __getitem__(self, item):\n        t = correct_type(item)\n        with self.lock:\n            return self.data[t]\n\n    def names(self):\n        # type: () -> List[str]\n        rev = dict((v, k) for k, v in self.data.items())\n        return [safe_qualname(rev[i]) for i in range(len(rev))]"
    ],
    [
        "STORE_NAME",
        "class TypeRegistry(object):\n    basic_types = (type(None), bool, int, float, complex)\n    if PY2:\n        basic_types += (long,)\n    special_types = basic_types + (list, dict, tuple, set, frozenset, str)\n    if PY2:\n        special_types += (unicode if PY2 else bytes,)\n\n    num_special_types = len(special_types)\n\n    def __init__(self):\n        self.lock = Lock()\n        self.data = defaultdict(lambda: len(self.data))  # type: Dict[type, int]\n\n        for t in self.special_types:\n            _ = self.data[t]\n\n    def __getitem__(self, item):\n        t = correct_type(item)\n        with self.lock:\n            return self.data[t]\n\n    def names(self):\n        # type: () -> List[str]\n        rev = dict((v, k) for k, v in self.data.items())\n        return [safe_qualname(rev[i]) for i in range(len(rev))]"
    ],
    [
        "STORE_NAME",
        "class TypeRegistry(object):\n    basic_types = (type(None), bool, int, float, complex)\n    if PY2:\n        basic_types += (long,)\n    special_types = basic_types + (list, dict, tuple, set, frozenset, str)\n    if PY2:\n        special_types += (unicode if PY2 else bytes,)\n\n    num_special_types = len(special_types)\n\n    def __init__(self):\n        self.lock = Lock()\n        self.data = defaultdict(lambda: len(self.data))  # type: Dict[type, int]\n\n        for t in self.special_types:\n            _ = self.data[t]\n\n    def __getitem__(self, item):\n        t = correct_type(item)\n        with self.lock:\n            return self.data[t]\n\n    def names(self):\n        # type: () -> List[str]\n        rev = dict((v, k) for k, v in self.data.items())\n        return [safe_qualname(rev[i]) for i in range(len(rev))]"
    ],
    [
        "LOAD_NAME",
        "type"
    ],
    [
        "CALL_FUNCTION",
        "type(None)"
    ],
    [
        "LOAD_NAME",
        "bool"
    ],
    [
        "LOAD_NAME",
        "int"
    ],
    [
        "LOAD_NAME",
        "float"
    ],
    [
        "LOAD_NAME",
        "complex"
    ],
    [
        "STORE_NAME",
        "basic_types"
    ],
    [
        "LOAD_NAME",
        "PY2"
    ],
    [
        "LOAD_NAME",
        "basic_types"
    ],
    [
        "LOAD_NAME",
        "long"
    ],
    [
        "STORE_NAME",
        "basic_types"
    ],
    [
        "LOAD_NAME",
        "basic_types"
    ],
    [
        "LOAD_NAME",
        "list"
    ],
    [
        "LOAD_NAME",
        "dict"
    ],
    [
        "LOAD_NAME",
        "tuple"
    ],
    [
        "LOAD_NAME",
        "set"
    ],
    [
        "LOAD_NAME",
        "frozenset"
    ],
    [
        "LOAD_NAME",
        "str"
    ],
    [
        "BINARY_ADD",
        "basic_types + (list, dict, tuple, set, frozenset, str)"
    ],
    [
        "STORE_NAME",
        "special_types"
    ],
    [
        "LOAD_NAME",
        "PY2"
    ],
    [
        "LOAD_NAME",
        "special_types"
    ],
    [
        "LOAD_NAME",
        "PY2"
    ],
    [
        "LOAD_NAME",
        "unicode"
    ],
    [
        "LOAD_NAME",
        "bytes"
    ],
    [
        "STORE_NAME",
        "special_types"
    ],
    [
        "LOAD_NAME",
        "len"
    ],
    [
        "LOAD_NAME",
        "special_types"
    ],
    [
        "CALL_FUNCTION",
        "len(special_types)"
    ],
    [
        "STORE_NAME",
        "num_special_types"
    ],
    [
        "STORE_NAME",
        "    def __init__(self):\n        self.lock = Lock()\n        self.data = defaultdict(lambda: len(self.data))  # type: Dict[type, int]\n\n        for t in self.special_types:\n            _ = self.data[t]"
    ],
    [
        "STORE_NAME",
        "    def __getitem__(self, item):\n        t = correct_type(item)\n        with self.lock:\n            return self.data[t]"
    ],
    [
        "STORE_NAME",
        "    def names(self):\n        # type: () -> List[str]\n        rev = dict((v, k) for k, v in self.data.items())\n        return [safe_qualname(rev[i]) for i in range(len(rev))]"
    ],
    [
        "LOAD_GLOBAL",
        "Lock"
    ],
    [
        "CALL_FUNCTION",
        "Lock()"
    ],
    [
        "LOAD_DEREF",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.lock"
    ],
    [
        "LOAD_GLOBAL",
        "defaultdict"
    ],
    [
        "CALL_FUNCTION",
        "defaultdict(lambda: len(self.data))"
    ],
    [
        "LOAD_DEREF",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.data"
    ],
    [
        "LOAD_DEREF",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.special_types"
    ],
    [
        "STORE_FAST",
        "t"
    ],
    [
        "LOAD_DEREF",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.data"
    ],
    [
        "LOAD_FAST",
        "t"
    ],
    [
        "BINARY_SUBSCR",
        "self.data[t]"
    ],
    [
        "STORE_FAST",
        "_"
    ],
    [
        "LOAD_GLOBAL",
        "len"
    ],
    [
        "LOAD_DEREF",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.data"
    ],
    [
        "CALL_FUNCTION",
        "len(self.data)"
    ],
    [
        "LOAD_GLOBAL",
        "correct_type"
    ],
    [
        "LOAD_FAST",
        "item"
    ],
    [
        "CALL_FUNCTION",
        "correct_type(item)"
    ],
    [
        "STORE_FAST",
        "t"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.lock"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.data"
    ],
    [
        "LOAD_FAST",
        "t"
    ],
    [
        "BINARY_SUBSCR",
        "self.data[t]"
    ],
    [
        "LOAD_GLOBAL",
        "dict"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.data"
    ],
    [
        "LOAD_METHOD",
        "self.data.items"
    ],
    [
        "CALL_METHOD",
        "self.data.items()"
    ],
    [
        "CALL_FUNCTION",
        "((v, k) for k, v in self.data.items())"
    ],
    [
        "CALL_FUNCTION",
        "dict((v, k) for k, v in self.data.items())"
    ],
    [
        "STORE_DEREF",
        "rev"
    ],
    [
        "LOAD_GLOBAL",
        "range"
    ],
    [
        "LOAD_GLOBAL",
        "len"
    ],
    [
        "LOAD_DEREF",
        "rev"
    ],
    [
        "CALL_FUNCTION",
        "len(rev)"
    ],
    [
        "CALL_FUNCTION",
        "range(len(rev))"
    ],
    [
        "CALL_FUNCTION",
        "[safe_qualname(rev[i]) for i in range(len(rev))]"
    ],
    [
        "LOAD_FAST",
        "((v, k) for k, v in self.data.items())"
    ],
    [
        "STORE_FAST",
        "k"
    ],
    [
        "STORE_FAST",
        "v"
    ],
    [
        "LOAD_FAST",
        "v"
    ],
    [
        "LOAD_FAST",
        "k"
    ],
    [
        "LOAD_FAST",
        "[safe_qualname(rev[i]) for i in range(len(rev))]"
    ],
    [
        "STORE_FAST",
        "i"
    ],
    [
        "LOAD_GLOBAL",
        "safe_qualname"
    ],
    [
        "LOAD_DEREF",
        "rev"
    ],
    [
        "LOAD_FAST",
        "i"
    ],
    [
        "BINARY_SUBSCR",
        "rev[i]"
    ],
    [
        "CALL_FUNCTION",
        "safe_qualname(rev[i])"
    ],
    [
        "LOAD_NAME",
        "class NodeValue(object):\n    \"\"\"\n    The 'value' of a node during a particular iteration.\n    This can mean different things, see the classmethods.\n    Can also contain some metadata, including links to other calls.\n    \"\"\"\n    __slots__ = ('val_repr', 'type_index', 'meta', 'children')\n\n    def __init__(self, val_repr, type_index):\n        self.val_repr = val_repr  # type: str\n        self.type_index = type_index  # type: int\n        self.meta = None  # type: Optional[Dict[str, Any]]\n        self.children = None  # type: Optional[List[Tuple[str, NodeValue]]]\n\n    def set_meta(self, key, value):\n        # type: (str, Any) -> None\n        self.meta = self.meta or {}\n        self.meta[key] = value\n\n    def add_child(self, samples, level, key, value):\n        # type: (dict, int, str, Any) -> None\n        self.children = self.children or []\n        self.children.append((key, NodeValue.expression(samples, value, level)))\n\n    def as_json(self):\n        result = [self.val_repr, self.type_index, self.meta or {}]  # type: list\n        if self.children:\n            result.extend(self.children)\n        return result\n\n    @classmethod\n    def covered(cls):\n        \"\"\"\n        Represents a bit of code, usually a statement, that executed successfully but\n        doesn't have an actual value.\n        \"\"\"\n        return cls('', -2)\n\n    @classmethod\n    def exception(cls, exc_value):\n        \"\"\"\n        Means that exc_value was raised by a node when executing, and not any inner node.\n        \"\"\"\n        return cls(exception_string(exc_value), -1)\n\n    @classmethod\n    def expression(cls, samples, val, level):\n        # type: (dict, Any, int) -> NodeValue\n        \"\"\"\n        The value of an expression or one of its children, with attributes,\n        dictionary items, etc as children. Has a max depth of `level` levels.\n        \"\"\"\n        result = cls(cheap_repr(val), type_registry[val])\n        if isinstance(val, (TypeRegistry.basic_types, BirdsEye)):\n            return result\n\n        length = None\n        if not isinstance(val, QuerySet):  # len triggers a database query\n            try:\n                length = len(val)\n            except:\n                pass\n            else:\n                result.set_meta('len', length)\n\n        if isinstance(val, ModuleType):\n            level = min(level, 2)\n\n        add_child = partial(result.add_child, samples, level - 1)\n\n        if isinstance(val, (Series, ndarray)):\n            attrs = ['dtype']\n            if isinstance(val, ndarray):\n                attrs.append('shape')\n            for name in attrs:\n                try:\n                    attr = getattr(val, name)\n                except AttributeError:\n                    pass\n                else:\n                    add_child(name, attr)\n\n        if level >= 3 or level >= 2 and isinstance(val, Series):\n            sample_type = 'big'\n        else:\n            sample_type = 'small'\n\n        samples = samples[sample_type]\n\n        # Always expand DataFrames and Series regardless of level to\n        # make the table view of DataFrames work\n\n        if isinstance(val, DataFrame):\n            meta = {}\n            result.set_meta('dataframe', meta)\n\n            max_rows = samples['pandas_rows']\n            max_cols = samples['pandas_cols']\n\n            if length > max_rows + 2:\n                meta['row_break'] = max_rows // 2\n\n            columns = val.columns\n            num_cols = len(columns)\n            if num_cols > max_cols + 2:\n                meta['col_break'] = max_cols // 2\n\n            indices = set(_sample_indices(num_cols, max_cols))\n            for i, (formatted_name, label) in enumerate(zip(val.columns.format(sparsify=False),\n                                                            val.columns)):\n                if i in indices:\n                    add_child(formatted_name, val[label])\n\n            return result\n\n        if isinstance(val, Series):\n            for i in _sample_indices(length, samples['pandas_rows']):\n                try:\n                    k = val.index[i:i + 1].format(sparsify=False)[0]\n                    v = val.iloc[i]\n                except:\n                    pass\n                else:\n                    add_child(k, v)\n            return result\n\n        if (level <= 0 or\n                isinstance(val,\n                           (str, bytes, range)\n                           if PY3 else\n                           (str, unicode, xrange))):\n            return result\n\n        if isinstance(val, (Sequence, ndarray)) and length is not None:\n            for i in _sample_indices(length, samples['list']):\n                try:\n                    v = val[i]\n                except:\n                    pass\n                else:\n                    add_child(str(i), v)\n\n        if isinstance(val, Mapping):\n            for k, v in islice(_safe_iter(val, iteritems), samples['dict']):\n                add_child(cheap_repr(k), v)\n\n        if isinstance(val, Set):\n            vals = _safe_iter(val)\n            num_items = samples['set']\n            if length is None or length > num_items + 2:\n                vals = islice(vals, num_items)\n            for i, v in enumerate(vals):\n                add_child('<%s>' % i, v)\n\n        d = getattr(val, '__dict__', None)\n        if d:\n            for k in sorted(islice(_safe_iter(d),\n                                   samples['attributes']),\n                            key=str):\n                v = d[k]\n                if isinstance(v, TracedFile):\n                    continue\n                add_child(str(k), v)\n        else:\n            for s in sorted(getattr(type(val), '__slots__', None) or ()):\n                try:\n                    attr = getattr(val, s)\n                except AttributeError:\n                    pass\n                else:\n                    add_child(str(s), attr)\n        return result"
    ],
    [
        "STORE_NAME",
        "class NodeValue(object):\n    \"\"\"\n    The 'value' of a node during a particular iteration.\n    This can mean different things, see the classmethods.\n    Can also contain some metadata, including links to other calls.\n    \"\"\"\n    __slots__ = ('val_repr', 'type_index', 'meta', 'children')\n\n    def __init__(self, val_repr, type_index):\n        self.val_repr = val_repr  # type: str\n        self.type_index = type_index  # type: int\n        self.meta = None  # type: Optional[Dict[str, Any]]\n        self.children = None  # type: Optional[List[Tuple[str, NodeValue]]]\n\n    def set_meta(self, key, value):\n        # type: (str, Any) -> None\n        self.meta = self.meta or {}\n        self.meta[key] = value\n\n    def add_child(self, samples, level, key, value):\n        # type: (dict, int, str, Any) -> None\n        self.children = self.children or []\n        self.children.append((key, NodeValue.expression(samples, value, level)))\n\n    def as_json(self):\n        result = [self.val_repr, self.type_index, self.meta or {}]  # type: list\n        if self.children:\n            result.extend(self.children)\n        return result\n\n    @classmethod\n    def covered(cls):\n        \"\"\"\n        Represents a bit of code, usually a statement, that executed successfully but\n        doesn't have an actual value.\n        \"\"\"\n        return cls('', -2)\n\n    @classmethod\n    def exception(cls, exc_value):\n        \"\"\"\n        Means that exc_value was raised by a node when executing, and not any inner node.\n        \"\"\"\n        return cls(exception_string(exc_value), -1)\n\n    @classmethod\n    def expression(cls, samples, val, level):\n        # type: (dict, Any, int) -> NodeValue\n        \"\"\"\n        The value of an expression or one of its children, with attributes,\n        dictionary items, etc as children. Has a max depth of `level` levels.\n        \"\"\"\n        result = cls(cheap_repr(val), type_registry[val])\n        if isinstance(val, (TypeRegistry.basic_types, BirdsEye)):\n            return result\n\n        length = None\n        if not isinstance(val, QuerySet):  # len triggers a database query\n            try:\n                length = len(val)\n            except:\n                pass\n            else:\n                result.set_meta('len', length)\n\n        if isinstance(val, ModuleType):\n            level = min(level, 2)\n\n        add_child = partial(result.add_child, samples, level - 1)\n\n        if isinstance(val, (Series, ndarray)):\n            attrs = ['dtype']\n            if isinstance(val, ndarray):\n                attrs.append('shape')\n            for name in attrs:\n                try:\n                    attr = getattr(val, name)\n                except AttributeError:\n                    pass\n                else:\n                    add_child(name, attr)\n\n        if level >= 3 or level >= 2 and isinstance(val, Series):\n            sample_type = 'big'\n        else:\n            sample_type = 'small'\n\n        samples = samples[sample_type]\n\n        # Always expand DataFrames and Series regardless of level to\n        # make the table view of DataFrames work\n\n        if isinstance(val, DataFrame):\n            meta = {}\n            result.set_meta('dataframe', meta)\n\n            max_rows = samples['pandas_rows']\n            max_cols = samples['pandas_cols']\n\n            if length > max_rows + 2:\n                meta['row_break'] = max_rows // 2\n\n            columns = val.columns\n            num_cols = len(columns)\n            if num_cols > max_cols + 2:\n                meta['col_break'] = max_cols // 2\n\n            indices = set(_sample_indices(num_cols, max_cols))\n            for i, (formatted_name, label) in enumerate(zip(val.columns.format(sparsify=False),\n                                                            val.columns)):\n                if i in indices:\n                    add_child(formatted_name, val[label])\n\n            return result\n\n        if isinstance(val, Series):\n            for i in _sample_indices(length, samples['pandas_rows']):\n                try:\n                    k = val.index[i:i + 1].format(sparsify=False)[0]\n                    v = val.iloc[i]\n                except:\n                    pass\n                else:\n                    add_child(k, v)\n            return result\n\n        if (level <= 0 or\n                isinstance(val,\n                           (str, bytes, range)\n                           if PY3 else\n                           (str, unicode, xrange))):\n            return result\n\n        if isinstance(val, (Sequence, ndarray)) and length is not None:\n            for i in _sample_indices(length, samples['list']):\n                try:\n                    v = val[i]\n                except:\n                    pass\n                else:\n                    add_child(str(i), v)\n\n        if isinstance(val, Mapping):\n            for k, v in islice(_safe_iter(val, iteritems), samples['dict']):\n                add_child(cheap_repr(k), v)\n\n        if isinstance(val, Set):\n            vals = _safe_iter(val)\n            num_items = samples['set']\n            if length is None or length > num_items + 2:\n                vals = islice(vals, num_items)\n            for i, v in enumerate(vals):\n                add_child('<%s>' % i, v)\n\n        d = getattr(val, '__dict__', None)\n        if d:\n            for k in sorted(islice(_safe_iter(d),\n                                   samples['attributes']),\n                            key=str):\n                v = d[k]\n                if isinstance(v, TracedFile):\n                    continue\n                add_child(str(k), v)\n        else:\n            for s in sorted(getattr(type(val), '__slots__', None) or ()):\n                try:\n                    attr = getattr(val, s)\n                except AttributeError:\n                    pass\n                else:\n                    add_child(str(s), attr)\n        return result"
    ],
    [
        "STORE_NAME",
        "class NodeValue(object):\n    \"\"\"\n    The 'value' of a node during a particular iteration.\n    This can mean different things, see the classmethods.\n    Can also contain some metadata, including links to other calls.\n    \"\"\"\n    __slots__ = ('val_repr', 'type_index', 'meta', 'children')\n\n    def __init__(self, val_repr, type_index):\n        self.val_repr = val_repr  # type: str\n        self.type_index = type_index  # type: int\n        self.meta = None  # type: Optional[Dict[str, Any]]\n        self.children = None  # type: Optional[List[Tuple[str, NodeValue]]]\n\n    def set_meta(self, key, value):\n        # type: (str, Any) -> None\n        self.meta = self.meta or {}\n        self.meta[key] = value\n\n    def add_child(self, samples, level, key, value):\n        # type: (dict, int, str, Any) -> None\n        self.children = self.children or []\n        self.children.append((key, NodeValue.expression(samples, value, level)))\n\n    def as_json(self):\n        result = [self.val_repr, self.type_index, self.meta or {}]  # type: list\n        if self.children:\n            result.extend(self.children)\n        return result\n\n    @classmethod\n    def covered(cls):\n        \"\"\"\n        Represents a bit of code, usually a statement, that executed successfully but\n        doesn't have an actual value.\n        \"\"\"\n        return cls('', -2)\n\n    @classmethod\n    def exception(cls, exc_value):\n        \"\"\"\n        Means that exc_value was raised by a node when executing, and not any inner node.\n        \"\"\"\n        return cls(exception_string(exc_value), -1)\n\n    @classmethod\n    def expression(cls, samples, val, level):\n        # type: (dict, Any, int) -> NodeValue\n        \"\"\"\n        The value of an expression or one of its children, with attributes,\n        dictionary items, etc as children. Has a max depth of `level` levels.\n        \"\"\"\n        result = cls(cheap_repr(val), type_registry[val])\n        if isinstance(val, (TypeRegistry.basic_types, BirdsEye)):\n            return result\n\n        length = None\n        if not isinstance(val, QuerySet):  # len triggers a database query\n            try:\n                length = len(val)\n            except:\n                pass\n            else:\n                result.set_meta('len', length)\n\n        if isinstance(val, ModuleType):\n            level = min(level, 2)\n\n        add_child = partial(result.add_child, samples, level - 1)\n\n        if isinstance(val, (Series, ndarray)):\n            attrs = ['dtype']\n            if isinstance(val, ndarray):\n                attrs.append('shape')\n            for name in attrs:\n                try:\n                    attr = getattr(val, name)\n                except AttributeError:\n                    pass\n                else:\n                    add_child(name, attr)\n\n        if level >= 3 or level >= 2 and isinstance(val, Series):\n            sample_type = 'big'\n        else:\n            sample_type = 'small'\n\n        samples = samples[sample_type]\n\n        # Always expand DataFrames and Series regardless of level to\n        # make the table view of DataFrames work\n\n        if isinstance(val, DataFrame):\n            meta = {}\n            result.set_meta('dataframe', meta)\n\n            max_rows = samples['pandas_rows']\n            max_cols = samples['pandas_cols']\n\n            if length > max_rows + 2:\n                meta['row_break'] = max_rows // 2\n\n            columns = val.columns\n            num_cols = len(columns)\n            if num_cols > max_cols + 2:\n                meta['col_break'] = max_cols // 2\n\n            indices = set(_sample_indices(num_cols, max_cols))\n            for i, (formatted_name, label) in enumerate(zip(val.columns.format(sparsify=False),\n                                                            val.columns)):\n                if i in indices:\n                    add_child(formatted_name, val[label])\n\n            return result\n\n        if isinstance(val, Series):\n            for i in _sample_indices(length, samples['pandas_rows']):\n                try:\n                    k = val.index[i:i + 1].format(sparsify=False)[0]\n                    v = val.iloc[i]\n                except:\n                    pass\n                else:\n                    add_child(k, v)\n            return result\n\n        if (level <= 0 or\n                isinstance(val,\n                           (str, bytes, range)\n                           if PY3 else\n                           (str, unicode, xrange))):\n            return result\n\n        if isinstance(val, (Sequence, ndarray)) and length is not None:\n            for i in _sample_indices(length, samples['list']):\n                try:\n                    v = val[i]\n                except:\n                    pass\n                else:\n                    add_child(str(i), v)\n\n        if isinstance(val, Mapping):\n            for k, v in islice(_safe_iter(val, iteritems), samples['dict']):\n                add_child(cheap_repr(k), v)\n\n        if isinstance(val, Set):\n            vals = _safe_iter(val)\n            num_items = samples['set']\n            if length is None or length > num_items + 2:\n                vals = islice(vals, num_items)\n            for i, v in enumerate(vals):\n                add_child('<%s>' % i, v)\n\n        d = getattr(val, '__dict__', None)\n        if d:\n            for k in sorted(islice(_safe_iter(d),\n                                   samples['attributes']),\n                            key=str):\n                v = d[k]\n                if isinstance(v, TracedFile):\n                    continue\n                add_child(str(k), v)\n        else:\n            for s in sorted(getattr(type(val), '__slots__', None) or ()):\n                try:\n                    attr = getattr(val, s)\n                except AttributeError:\n                    pass\n                else:\n                    add_child(str(s), attr)\n        return result"
    ],
    [
        "STORE_NAME",
        "\"\"\"\n    The 'value' of a node during a particular iteration.\n    This can mean different things, see the classmethods.\n    Can also contain some metadata, including links to other calls.\n    \"\"\""
    ],
    [
        "STORE_NAME",
        "__slots__"
    ],
    [
        "STORE_NAME",
        "    def __init__(self, val_repr, type_index):\n        self.val_repr = val_repr  # type: str\n        self.type_index = type_index  # type: int\n        self.meta = None  # type: Optional[Dict[str, Any]]\n        self.children = None"
    ],
    [
        "STORE_NAME",
        "    def set_meta(self, key, value):\n        # type: (str, Any) -> None\n        self.meta = self.meta or {}\n        self.meta[key] = value"
    ],
    [
        "STORE_NAME",
        "    def add_child(self, samples, level, key, value):\n        # type: (dict, int, str, Any) -> None\n        self.children = self.children or []\n        self.children.append((key, NodeValue.expression(samples, value, level)))"
    ],
    [
        "STORE_NAME",
        "    def as_json(self):\n        result = [self.val_repr, self.type_index, self.meta or {}]  # type: list\n        if self.children:\n            result.extend(self.children)\n        return result"
    ],
    [
        "LOAD_NAME",
        "classmethod"
    ],
    [
        "CALL_FUNCTION",
        "classmethod"
    ],
    [
        "STORE_NAME",
        "    @classmethod\n    def covered(cls):\n        \"\"\"\n        Represents a bit of code, usually a statement, that executed successfully but\n        doesn't have an actual value.\n        \"\"\"\n        return cls('', -2)"
    ],
    [
        "LOAD_NAME",
        "classmethod"
    ],
    [
        "CALL_FUNCTION",
        "classmethod"
    ],
    [
        "STORE_NAME",
        "    @classmethod\n    def exception(cls, exc_value):\n        \"\"\"\n        Means that exc_value was raised by a node when executing, and not any inner node.\n        \"\"\"\n        return cls(exception_string(exc_value), -1)"
    ],
    [
        "LOAD_NAME",
        "classmethod"
    ],
    [
        "CALL_FUNCTION",
        "classmethod"
    ],
    [
        "STORE_NAME",
        "    @classmethod\n    def expression(cls, samples, val, level):\n        # type: (dict, Any, int) -> NodeValue\n        \"\"\"\n        The value of an expression or one of its children, with attributes,\n        dictionary items, etc as children. Has a max depth of `level` levels.\n        \"\"\"\n        result = cls(cheap_repr(val), type_registry[val])\n        if isinstance(val, (TypeRegistry.basic_types, BirdsEye)):\n            return result\n\n        length = None\n        if not isinstance(val, QuerySet):  # len triggers a database query\n            try:\n                length = len(val)\n            except:\n                pass\n            else:\n                result.set_meta('len', length)\n\n        if isinstance(val, ModuleType):\n            level = min(level, 2)\n\n        add_child = partial(result.add_child, samples, level - 1)\n\n        if isinstance(val, (Series, ndarray)):\n            attrs = ['dtype']\n            if isinstance(val, ndarray):\n                attrs.append('shape')\n            for name in attrs:\n                try:\n                    attr = getattr(val, name)\n                except AttributeError:\n                    pass\n                else:\n                    add_child(name, attr)\n\n        if level >= 3 or level >= 2 and isinstance(val, Series):\n            sample_type = 'big'\n        else:\n            sample_type = 'small'\n\n        samples = samples[sample_type]\n\n        # Always expand DataFrames and Series regardless of level to\n        # make the table view of DataFrames work\n\n        if isinstance(val, DataFrame):\n            meta = {}\n            result.set_meta('dataframe', meta)\n\n            max_rows = samples['pandas_rows']\n            max_cols = samples['pandas_cols']\n\n            if length > max_rows + 2:\n                meta['row_break'] = max_rows // 2\n\n            columns = val.columns\n            num_cols = len(columns)\n            if num_cols > max_cols + 2:\n                meta['col_break'] = max_cols // 2\n\n            indices = set(_sample_indices(num_cols, max_cols))\n            for i, (formatted_name, label) in enumerate(zip(val.columns.format(sparsify=False),\n                                                            val.columns)):\n                if i in indices:\n                    add_child(formatted_name, val[label])\n\n            return result\n\n        if isinstance(val, Series):\n            for i in _sample_indices(length, samples['pandas_rows']):\n                try:\n                    k = val.index[i:i + 1].format(sparsify=False)[0]\n                    v = val.iloc[i]\n                except:\n                    pass\n                else:\n                    add_child(k, v)\n            return result\n\n        if (level <= 0 or\n                isinstance(val,\n                           (str, bytes, range)\n                           if PY3 else\n                           (str, unicode, xrange))):\n            return result\n\n        if isinstance(val, (Sequence, ndarray)) and length is not None:\n            for i in _sample_indices(length, samples['list']):\n                try:\n                    v = val[i]\n                except:\n                    pass\n                else:\n                    add_child(str(i), v)\n\n        if isinstance(val, Mapping):\n            for k, v in islice(_safe_iter(val, iteritems), samples['dict']):\n                add_child(cheap_repr(k), v)\n\n        if isinstance(val, Set):\n            vals = _safe_iter(val)\n            num_items = samples['set']\n            if length is None or length > num_items + 2:\n                vals = islice(vals, num_items)\n            for i, v in enumerate(vals):\n                add_child('<%s>' % i, v)\n\n        d = getattr(val, '__dict__', None)\n        if d:\n            for k in sorted(islice(_safe_iter(d),\n                                   samples['attributes']),\n                            key=str):\n                v = d[k]\n                if isinstance(v, TracedFile):\n                    continue\n                add_child(str(k), v)\n        else:\n            for s in sorted(getattr(type(val), '__slots__', None) or ()):\n                try:\n                    attr = getattr(val, s)\n                except AttributeError:\n                    pass\n                else:\n                    add_child(str(s), attr)\n        return result"
    ],
    [
        "LOAD_FAST",
        "val_repr"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.val_repr"
    ],
    [
        "LOAD_FAST",
        "type_index"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.type_index"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.meta"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.children"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.meta"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.meta"
    ],
    [
        "LOAD_FAST",
        "value"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.meta"
    ],
    [
        "LOAD_FAST",
        "key"
    ],
    [
        "STORE_SUBSCR",
        "self.meta[key]"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.children"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "STORE_ATTR",
        "self.children"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.children"
    ],
    [
        "LOAD_METHOD",
        "self.children.append"
    ],
    [
        "LOAD_FAST",
        "key"
    ],
    [
        "LOAD_GLOBAL",
        "NodeValue"
    ],
    [
        "LOAD_METHOD",
        "NodeValue.expression"
    ],
    [
        "LOAD_FAST",
        "samples"
    ],
    [
        "LOAD_FAST",
        "value"
    ],
    [
        "LOAD_FAST",
        "level"
    ],
    [
        "CALL_METHOD",
        "NodeValue.expression(samples, value, level)"
    ],
    [
        "CALL_METHOD",
        "self.children.append((key, NodeValue.expression(samples, value, level)))"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.val_repr"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.type_index"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.meta"
    ],
    [
        "STORE_FAST",
        "result"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.children"
    ],
    [
        "LOAD_FAST",
        "result"
    ],
    [
        "LOAD_METHOD",
        "result.extend"
    ],
    [
        "LOAD_FAST",
        "self"
    ],
    [
        "LOAD_ATTR",
        "self.children"
    ],
    [
        "CALL_METHOD",
        "result.extend(self.children)"
    ],
    [
        "LOAD_FAST",
        "result"
    ],
    [
        "LOAD_FAST",
        "cls"
    ],
    [
        "CALL_FUNCTION",
        "cls('', -2)"
    ],
    [
        "LOAD_FAST",
        "cls"
    ],
    [
        "LOAD_GLOBAL",
        "exception_string"
    ],
    [
        "LOAD_FAST",
        "exc_value"
    ],
    [
        "CALL_FUNCTION",
        "exception_string(exc_value)"
    ],
    [
        "CALL_FUNCTION",
        "cls(exception_string(exc_value), -1)"
    ],
    [
        "LOAD_FAST",
        "cls"
    ],
    [
        "LOAD_GLOBAL",
        "cheap_repr"
    ],
    [
        "LOAD_FAST",
        "val"
    ],
    [
        "CALL_FUNCTION",
        "cheap_repr(val)"
    ],
    [
        "LOAD_GLOBAL",
        "type_registry"
    ],
    [
        "LOAD_FAST",
        "val"
    ],
    [
        "BINARY_SUBSCR",
        "type_registry[val]"
    ],
    [
        "CALL_FUNCTION",
        "cls(cheap_repr(val), type_registry[val])"
    ],
    [
        "STORE_FAST",
        "result"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "val"
    ],
    [
        "LOAD_GLOBAL",
        "TypeRegistry"
    ],
    [
        "LOAD_ATTR",
        "TypeRegistry.basic_types"
    ],
    [
        "LOAD_GLOBAL",
        "BirdsEye"
    ],
    [
        "CALL_FUNCTION",
        "isinstance(val, (TypeRegistry.basic_types, BirdsEye))"
    ],
    [
        "LOAD_FAST",
        "result"
    ],
    [
        "STORE_FAST",
        "length"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "val"
    ],
    [
        "LOAD_GLOBAL",
        "QuerySet"
    ],
    [
        "CALL_FUNCTION",
        "isinstance(val, QuerySet)"
    ],
    [
        "LOAD_GLOBAL",
        "len"
    ],
    [
        "LOAD_FAST",
        "val"
    ],
    [
        "CALL_FUNCTION",
        "len(val)"
    ],
    [
        "STORE_FAST",
        "length"
    ],
    [
        "LOAD_FAST",
        "result"
    ],
    [
        "LOAD_METHOD",
        "result.set_meta"
    ],
    [
        "LOAD_FAST",
        "length"
    ],
    [
        "CALL_METHOD",
        "result.set_meta('len', length)"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "val"
    ],
    [
        "LOAD_GLOBAL",
        "ModuleType"
    ],
    [
        "CALL_FUNCTION",
        "isinstance(val, ModuleType)"
    ],
    [
        "LOAD_GLOBAL",
        "min"
    ],
    [
        "LOAD_FAST",
        "level"
    ],
    [
        "CALL_FUNCTION",
        "min(level, 2)"
    ],
    [
        "STORE_FAST",
        "level"
    ],
    [
        "LOAD_GLOBAL",
        "partial"
    ],
    [
        "LOAD_FAST",
        "result"
    ],
    [
        "LOAD_ATTR",
        "result.add_child"
    ],
    [
        "LOAD_FAST",
        "samples"
    ],
    [
        "LOAD_FAST",
        "level"
    ],
    [
        "BINARY_SUBTRACT",
        "level - 1"
    ],
    [
        "CALL_FUNCTION",
        "partial(result.add_child, samples, level - 1)"
    ],
    [
        "STORE_FAST",
        "add_child"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "val"
    ],
    [
        "LOAD_GLOBAL",
        "Series"
    ],
    [
        "LOAD_GLOBAL",
        "ndarray"
    ],
    [
        "CALL_FUNCTION",
        "isinstance(val, (Series, ndarray))"
    ],
    [
        "STORE_FAST",
        "attrs"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "val"
    ],
    [
        "LOAD_GLOBAL",
        "ndarray"
    ],
    [
        "CALL_FUNCTION",
        "isinstance(val, ndarray)"
    ],
    [
        "LOAD_FAST",
        "attrs"
    ],
    [
        "LOAD_METHOD",
        "attrs.append"
    ],
    [
        "CALL_METHOD",
        "attrs.append('shape')"
    ],
    [
        "LOAD_FAST",
        "attrs"
    ],
    [
        "STORE_FAST",
        "name"
    ],
    [
        "LOAD_GLOBAL",
        "getattr"
    ],
    [
        "LOAD_FAST",
        "val"
    ],
    [
        "LOAD_FAST",
        "name"
    ],
    [
        "CALL_FUNCTION",
        "getattr(val, name)"
    ],
    [
        "STORE_FAST",
        "attr"
    ],
    [
        "LOAD_GLOBAL",
        "AttributeError"
    ],
    [
        "LOAD_FAST",
        "add_child"
    ],
    [
        "LOAD_FAST",
        "name"
    ],
    [
        "LOAD_FAST",
        "attr"
    ],
    [
        "CALL_FUNCTION",
        "add_child(name, attr)"
    ],
    [
        "LOAD_FAST",
        "level"
    ],
    [
        "COMPARE_OP",
        "level >= 3"
    ],
    [
        "LOAD_FAST",
        "level"
    ],
    [
        "COMPARE_OP",
        "level >= 2"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "val"
    ],
    [
        "LOAD_GLOBAL",
        "Series"
    ],
    [
        "CALL_FUNCTION",
        "isinstance(val, Series)"
    ],
    [
        "STORE_FAST",
        "sample_type"
    ],
    [
        "STORE_FAST",
        "sample_type"
    ],
    [
        "LOAD_FAST",
        "samples"
    ],
    [
        "LOAD_FAST",
        "sample_type"
    ],
    [
        "BINARY_SUBSCR",
        "samples[sample_type]"
    ],
    [
        "STORE_FAST",
        "samples"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "val"
    ],
    [
        "LOAD_GLOBAL",
        "DataFrame"
    ],
    [
        "CALL_FUNCTION",
        "isinstance(val, DataFrame)"
    ],
    [
        "STORE_FAST",
        "meta"
    ],
    [
        "LOAD_FAST",
        "result"
    ],
    [
        "LOAD_METHOD",
        "result.set_meta"
    ],
    [
        "LOAD_FAST",
        "meta"
    ],
    [
        "CALL_METHOD",
        "result.set_meta('dataframe', meta)"
    ],
    [
        "LOAD_FAST",
        "samples"
    ],
    [
        "BINARY_SUBSCR",
        "samples['pandas_rows']"
    ],
    [
        "STORE_FAST",
        "max_rows"
    ],
    [
        "LOAD_FAST",
        "samples"
    ],
    [
        "BINARY_SUBSCR",
        "samples['pandas_cols']"
    ],
    [
        "STORE_FAST",
        "max_cols"
    ],
    [
        "LOAD_FAST",
        "length"
    ],
    [
        "LOAD_FAST",
        "max_rows"
    ],
    [
        "BINARY_ADD",
        "max_rows + 2"
    ],
    [
        "COMPARE_OP",
        "length > max_rows + 2"
    ],
    [
        "LOAD_FAST",
        "max_rows"
    ],
    [
        "BINARY_FLOOR_DIVIDE",
        "max_rows // 2"
    ],
    [
        "LOAD_FAST",
        "meta"
    ],
    [
        "STORE_SUBSCR",
        "meta['row_break']"
    ],
    [
        "LOAD_FAST",
        "val"
    ],
    [
        "LOAD_ATTR",
        "val.columns"
    ],
    [
        "STORE_FAST",
        "columns"
    ],
    [
        "LOAD_GLOBAL",
        "len"
    ],
    [
        "LOAD_FAST",
        "columns"
    ],
    [
        "CALL_FUNCTION",
        "len(columns)"
    ],
    [
        "STORE_FAST",
        "num_cols"
    ],
    [
        "LOAD_FAST",
        "num_cols"
    ],
    [
        "LOAD_FAST",
        "max_cols"
    ],
    [
        "BINARY_ADD",
        "max_cols + 2"
    ],
    [
        "COMPARE_OP",
        "num_cols > max_cols + 2"
    ],
    [
        "LOAD_FAST",
        "max_cols"
    ],
    [
        "BINARY_FLOOR_DIVIDE",
        "max_cols // 2"
    ],
    [
        "LOAD_FAST",
        "meta"
    ],
    [
        "STORE_SUBSCR",
        "meta['col_break']"
    ],
    [
        "LOAD_GLOBAL",
        "set"
    ],
    [
        "LOAD_GLOBAL",
        "_sample_indices"
    ],
    [
        "LOAD_FAST",
        "num_cols"
    ],
    [
        "LOAD_FAST",
        "max_cols"
    ],
    [
        "CALL_FUNCTION",
        "_sample_indices(num_cols, max_cols)"
    ],
    [
        "CALL_FUNCTION",
        "set(_sample_indices(num_cols, max_cols))"
    ],
    [
        "STORE_FAST",
        "indices"
    ],
    [
        "LOAD_GLOBAL",
        "enumerate"
    ],
    [
        "LOAD_GLOBAL",
        "zip"
    ],
    [
        "LOAD_FAST",
        "val"
    ],
    [
        "LOAD_ATTR",
        "val.columns"
    ],
    [
        "LOAD_ATTR",
        "val.columns.format"
    ],
    [
        "CALL_FUNCTION_KW",
        "val.columns.format(sparsify=False)"
    ],
    [
        "LOAD_FAST",
        "val"
    ],
    [
        "LOAD_ATTR",
        "val.columns"
    ],
    [
        "CALL_FUNCTION",
        "zip(val.columns.format(sparsify=False),\n                                                            val.columns)"
    ],
    [
        "CALL_FUNCTION",
        "enumerate(zip(val.columns.format(sparsify=False),\n                                                            val.columns))"
    ],
    [
        "STORE_FAST",
        "i"
    ],
    [
        "STORE_FAST",
        "formatted_name"
    ],
    [
        "STORE_FAST",
        "label"
    ],
    [
        "LOAD_FAST",
        "i"
    ],
    [
        "LOAD_FAST",
        "indices"
    ],
    [
        "CONTAINS_OP",
        "i in indices"
    ],
    [
        "LOAD_FAST",
        "add_child"
    ],
    [
        "LOAD_FAST",
        "formatted_name"
    ],
    [
        "LOAD_FAST",
        "val"
    ],
    [
        "LOAD_FAST",
        "label"
    ],
    [
        "BINARY_SUBSCR",
        "val[label]"
    ],
    [
        "CALL_FUNCTION",
        "add_child(formatted_name, val[label])"
    ],
    [
        "LOAD_FAST",
        "result"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "val"
    ],
    [
        "LOAD_GLOBAL",
        "Series"
    ],
    [
        "CALL_FUNCTION",
        "isinstance(val, Series)"
    ],
    [
        "LOAD_GLOBAL",
        "_sample_indices"
    ],
    [
        "LOAD_FAST",
        "length"
    ],
    [
        "LOAD_FAST",
        "samples"
    ],
    [
        "BINARY_SUBSCR",
        "samples['pandas_rows']"
    ],
    [
        "CALL_FUNCTION",
        "_sample_indices(length, samples['pandas_rows'])"
    ],
    [
        "STORE_FAST",
        "i"
    ],
    [
        "LOAD_FAST",
        "val"
    ],
    [
        "LOAD_ATTR",
        "val.index"
    ],
    [
        "LOAD_FAST",
        "i"
    ],
    [
        "LOAD_FAST",
        "i"
    ],
    [
        "BINARY_ADD",
        "i + 1"
    ],
    [
        "BINARY_SUBSCR",
        "val.index[i:i + 1]"
    ],
    [
        "LOAD_ATTR",
        "val.index[i:i + 1].format"
    ],
    [
        "CALL_FUNCTION_KW",
        "val.index[i:i + 1].format(sparsify=False)"
    ],
    [
        "BINARY_SUBSCR",
        "val.index[i:i + 1].format(sparsify=False)[0]"
    ],
    [
        "STORE_FAST",
        "k"
    ],
    [
        "LOAD_FAST",
        "val"
    ],
    [
        "LOAD_ATTR",
        "val.iloc"
    ],
    [
        "LOAD_FAST",
        "i"
    ],
    [
        "BINARY_SUBSCR",
        "val.iloc[i]"
    ],
    [
        "STORE_FAST",
        "v"
    ],
    [
        "LOAD_FAST",
        "add_child"
    ],
    [
        "LOAD_FAST",
        "k"
    ],
    [
        "LOAD_FAST",
        "v"
    ],
    [
        "CALL_FUNCTION",
        "add_child(k, v)"
    ],
    [
        "LOAD_FAST",
        "result"
    ],
    [
        "LOAD_FAST",
        "level"
    ],
    [
        "COMPARE_OP",
        "level <= 0"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "val"
    ],
    [
        "LOAD_GLOBAL",
        "PY3"
    ],
    [
        "LOAD_GLOBAL",
        "str"
    ],
    [
        "LOAD_GLOBAL",
        "bytes"
    ],
    [
        "LOAD_GLOBAL",
        "range"
    ],
    [
        "LOAD_GLOBAL",
        "str"
    ],
    [
        "LOAD_GLOBAL",
        "unicode"
    ],
    [
        "LOAD_GLOBAL",
        "xrange"
    ],
    [
        "CALL_FUNCTION",
        "isinstance(val,\n                           (str, bytes, range)\n                           if PY3 else\n                           (str, unicode, xrange))"
    ],
    [
        "LOAD_FAST",
        "result"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "val"
    ],
    [
        "LOAD_GLOBAL",
        "Sequence"
    ],
    [
        "LOAD_GLOBAL",
        "ndarray"
    ],
    [
        "CALL_FUNCTION",
        "isinstance(val, (Sequence, ndarray))"
    ],
    [
        "LOAD_FAST",
        "length"
    ],
    [
        "IS_OP",
        "length is not None"
    ],
    [
        "LOAD_GLOBAL",
        "_sample_indices"
    ],
    [
        "LOAD_FAST",
        "length"
    ],
    [
        "LOAD_FAST",
        "samples"
    ],
    [
        "BINARY_SUBSCR",
        "samples['list']"
    ],
    [
        "CALL_FUNCTION",
        "_sample_indices(length, samples['list'])"
    ],
    [
        "STORE_FAST",
        "i"
    ],
    [
        "LOAD_FAST",
        "val"
    ],
    [
        "LOAD_FAST",
        "i"
    ],
    [
        "BINARY_SUBSCR",
        "val[i]"
    ],
    [
        "STORE_FAST",
        "v"
    ],
    [
        "LOAD_FAST",
        "add_child"
    ],
    [
        "LOAD_GLOBAL",
        "str"
    ],
    [
        "LOAD_FAST",
        "i"
    ],
    [
        "CALL_FUNCTION",
        "str(i)"
    ],
    [
        "LOAD_FAST",
        "v"
    ],
    [
        "CALL_FUNCTION",
        "add_child(str(i), v)"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "val"
    ],
    [
        "LOAD_GLOBAL",
        "Mapping"
    ],
    [
        "CALL_FUNCTION",
        "isinstance(val, Mapping)"
    ],
    [
        "LOAD_GLOBAL",
        "islice"
    ],
    [
        "LOAD_GLOBAL",
        "_safe_iter"
    ],
    [
        "LOAD_FAST",
        "val"
    ],
    [
        "LOAD_GLOBAL",
        "iteritems"
    ],
    [
        "CALL_FUNCTION",
        "_safe_iter(val, iteritems)"
    ],
    [
        "LOAD_FAST",
        "samples"
    ],
    [
        "BINARY_SUBSCR",
        "samples['dict']"
    ],
    [
        "CALL_FUNCTION",
        "islice(_safe_iter(val, iteritems), samples['dict'])"
    ],
    [
        "STORE_FAST",
        "k"
    ],
    [
        "STORE_FAST",
        "v"
    ],
    [
        "LOAD_FAST",
        "add_child"
    ],
    [
        "LOAD_GLOBAL",
        "cheap_repr"
    ],
    [
        "LOAD_FAST",
        "k"
    ],
    [
        "CALL_FUNCTION",
        "cheap_repr(k)"
    ],
    [
        "LOAD_FAST",
        "v"
    ],
    [
        "CALL_FUNCTION",
        "add_child(cheap_repr(k), v)"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "val"
    ],
    [
        "LOAD_GLOBAL",
        "Set"
    ],
    [
        "CALL_FUNCTION",
        "isinstance(val, Set)"
    ],
    [
        "LOAD_GLOBAL",
        "_safe_iter"
    ],
    [
        "LOAD_FAST",
        "val"
    ],
    [
        "CALL_FUNCTION",
        "_safe_iter(val)"
    ],
    [
        "STORE_FAST",
        "vals"
    ],
    [
        "LOAD_FAST",
        "samples"
    ],
    [
        "BINARY_SUBSCR",
        "samples['set']"
    ],
    [
        "STORE_FAST",
        "num_items"
    ],
    [
        "LOAD_FAST",
        "length"
    ],
    [
        "IS_OP",
        "length is None"
    ],
    [
        "LOAD_FAST",
        "length"
    ],
    [
        "LOAD_FAST",
        "num_items"
    ],
    [
        "BINARY_ADD",
        "num_items + 2"
    ],
    [
        "COMPARE_OP",
        "length > num_items + 2"
    ],
    [
        "LOAD_GLOBAL",
        "islice"
    ],
    [
        "LOAD_FAST",
        "vals"
    ],
    [
        "LOAD_FAST",
        "num_items"
    ],
    [
        "CALL_FUNCTION",
        "islice(vals, num_items)"
    ],
    [
        "STORE_FAST",
        "vals"
    ],
    [
        "LOAD_GLOBAL",
        "enumerate"
    ],
    [
        "LOAD_FAST",
        "vals"
    ],
    [
        "CALL_FUNCTION",
        "enumerate(vals)"
    ],
    [
        "STORE_FAST",
        "i"
    ],
    [
        "STORE_FAST",
        "v"
    ],
    [
        "LOAD_FAST",
        "add_child"
    ],
    [
        "LOAD_FAST",
        "i"
    ],
    [
        "BINARY_MODULO",
        "'<%s>' % i"
    ],
    [
        "LOAD_FAST",
        "v"
    ],
    [
        "CALL_FUNCTION",
        "add_child('<%s>' % i, v)"
    ],
    [
        "LOAD_GLOBAL",
        "getattr"
    ],
    [
        "LOAD_FAST",
        "val"
    ],
    [
        "CALL_FUNCTION",
        "getattr(val, '__dict__', None)"
    ],
    [
        "STORE_FAST",
        "d"
    ],
    [
        "LOAD_FAST",
        "d"
    ],
    [
        "LOAD_GLOBAL",
        "sorted"
    ],
    [
        "LOAD_GLOBAL",
        "islice"
    ],
    [
        "LOAD_GLOBAL",
        "_safe_iter"
    ],
    [
        "LOAD_FAST",
        "d"
    ],
    [
        "CALL_FUNCTION",
        "_safe_iter(d)"
    ],
    [
        "LOAD_FAST",
        "samples"
    ],
    [
        "BINARY_SUBSCR",
        "samples['attributes']"
    ],
    [
        "CALL_FUNCTION",
        "islice(_safe_iter(d),\n                                   samples['attributes'])"
    ],
    [
        "LOAD_GLOBAL",
        "str"
    ],
    [
        "CALL_FUNCTION_KW",
        "sorted(islice(_safe_iter(d),\n                                   samples['attributes']),\n                            key=str)"
    ],
    [
        "STORE_FAST",
        "k"
    ],
    [
        "LOAD_FAST",
        "d"
    ],
    [
        "LOAD_FAST",
        "k"
    ],
    [
        "BINARY_SUBSCR",
        "d[k]"
    ],
    [
        "STORE_FAST",
        "v"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "v"
    ],
    [
        "LOAD_GLOBAL",
        "TracedFile"
    ],
    [
        "CALL_FUNCTION",
        "isinstance(v, TracedFile)"
    ],
    [
        "LOAD_FAST",
        "add_child"
    ],
    [
        "LOAD_GLOBAL",
        "str"
    ],
    [
        "LOAD_FAST",
        "k"
    ],
    [
        "CALL_FUNCTION",
        "str(k)"
    ],
    [
        "LOAD_FAST",
        "v"
    ],
    [
        "CALL_FUNCTION",
        "add_child(str(k), v)"
    ],
    [
        "LOAD_GLOBAL",
        "sorted"
    ],
    [
        "LOAD_GLOBAL",
        "getattr"
    ],
    [
        "LOAD_GLOBAL",
        "type"
    ],
    [
        "LOAD_FAST",
        "val"
    ],
    [
        "CALL_FUNCTION",
        "type(val)"
    ],
    [
        "CALL_FUNCTION",
        "getattr(type(val), '__slots__', None)"
    ],
    [
        "CALL_FUNCTION",
        "sorted(getattr(type(val), '__slots__', None) or ())"
    ],
    [
        "STORE_FAST",
        "s"
    ],
    [
        "LOAD_GLOBAL",
        "getattr"
    ],
    [
        "LOAD_FAST",
        "val"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "CALL_FUNCTION",
        "getattr(val, s)"
    ],
    [
        "STORE_FAST",
        "attr"
    ],
    [
        "LOAD_GLOBAL",
        "AttributeError"
    ],
    [
        "LOAD_FAST",
        "add_child"
    ],
    [
        "LOAD_GLOBAL",
        "str"
    ],
    [
        "LOAD_FAST",
        "s"
    ],
    [
        "CALL_FUNCTION",
        "str(s)"
    ],
    [
        "LOAD_FAST",
        "attr"
    ],
    [
        "CALL_FUNCTION",
        "add_child(str(s), attr)"
    ],
    [
        "LOAD_FAST",
        "result"
    ],
    [
        "LOAD_FAST",
        "x"
    ],
    [
        "LOAD_FAST",
        "f"
    ],
    [
        "LOAD_FAST",
        "val"
    ],
    [
        "CALL_FUNCTION",
        "f(val)"
    ],
    [
        "STORE_FAST",
        "x"
    ],
    [
        "LOAD_FAST",
        "x"
    ],
    [
        "LOAD_FAST",
        "length"
    ],
    [
        "LOAD_FAST",
        "max_length"
    ],
    [
        "BINARY_ADD",
        "max_length + 2"
    ],
    [
        "COMPARE_OP",
        "length <= max_length + 2"
    ],
    [
        "LOAD_GLOBAL",
        "range"
    ],
    [
        "LOAD_FAST",
        "length"
    ],
    [
        "CALL_FUNCTION",
        "range(length)"
    ],
    [
        "LOAD_GLOBAL",
        "chain"
    ],
    [
        "LOAD_GLOBAL",
        "range"
    ],
    [
        "LOAD_FAST",
        "max_length"
    ],
    [
        "BINARY_FLOOR_DIVIDE",
        "max_length // 2"
    ],
    [
        "CALL_FUNCTION",
        "range(max_length // 2)"
    ],
    [
        "LOAD_GLOBAL",
        "range"
    ],
    [
        "LOAD_FAST",
        "length"
    ],
    [
        "LOAD_FAST",
        "max_length"
    ],
    [
        "BINARY_FLOOR_DIVIDE",
        "max_length // 2"
    ],
    [
        "BINARY_SUBTRACT",
        "length - max_length // 2"
    ],
    [
        "LOAD_FAST",
        "length"
    ],
    [
        "CALL_FUNCTION",
        "range(length - max_length // 2,\n                           length)"
    ],
    [
        "CALL_FUNCTION",
        "chain(range(max_length // 2),\n                     range(length - max_length // 2,\n                           length))"
    ],
    [
        "LOAD_GLOBAL",
        "len"
    ],
    [
        "LOAD_FAST",
        "x"
    ],
    [
        "CALL_FUNCTION",
        "len(x)"
    ],
    [
        "STORE_FAST",
        "n"
    ],
    [
        "LOAD_FAST",
        "n"
    ],
    [
        "COMPARE_OP",
        "n == 0"
    ],
    [
        "LOAD_GLOBAL",
        "repr"
    ],
    [
        "LOAD_FAST",
        "x"
    ],
    [
        "CALL_FUNCTION",
        "repr(x)"
    ],
    [
        "LOAD_FAST",
        "helper"
    ],
    [
        "LOAD_ATTR",
        "helper.level"
    ],
    [
        "BINARY_SUBTRACT",
        "helper.level - 1"
    ],
    [
        "STORE_FAST",
        "newlevel"
    ],
    [
        "STORE_FAST",
        "pieces"
    ],
    [
        "LOAD_GLOBAL",
        "_repr_series_one_line"
    ],
    [
        "LOAD_ATTR",
        "_repr_series_one_line.maxparts"
    ],
    [
        "STORE_FAST",
        "maxparts"
    ],
    [
        "LOAD_GLOBAL",
        "_sample_indices"
    ],
    [
        "LOAD_FAST",
        "n"
    ],
    [
        "LOAD_FAST",
        "maxparts"
    ],
    [
        "CALL_FUNCTION",
        "_sample_indices(n, maxparts)"
    ],
    [
        "STORE_FAST",
        "i"
    ],
    [
        "LOAD_FAST",
        "x"
    ],
    [
        "LOAD_ATTR",
        "x.index"
    ],
    [
        "LOAD_FAST",
        "i"
    ],
    [
        "LOAD_FAST",
        "i"
    ],
    [
        "BINARY_ADD",
        "i + 1"
    ],
    [
        "BINARY_SUBSCR",
        "x.index[i:i + 1]"
    ],
    [
        "LOAD_ATTR",
        "x.index[i:i + 1].format"
    ],
    [
        "CALL_FUNCTION_KW",
        "x.index[i:i + 1].format(sparsify=False)"
    ],
    [
        "BINARY_SUBSCR",
        "x.index[i:i + 1].format(sparsify=False)[0]"
    ],
    [
        "STORE_FAST",
        "k"
    ],
    [
        "LOAD_FAST",
        "x"
    ],
    [
        "LOAD_ATTR",
        "x.iloc"
    ],
    [
        "LOAD_FAST",
        "i"
    ],
    [
        "BINARY_SUBSCR",
        "x.iloc[i]"
    ],
    [
        "STORE_FAST",
        "v"
    ],
    [
        "LOAD_FAST",
        "pieces"
    ],
    [
        "LOAD_METHOD",
        "pieces.append"
    ],
    [
        "LOAD_FAST",
        "k"
    ],
    [
        "LOAD_GLOBAL",
        "cheap_repr"
    ],
    [
        "LOAD_FAST",
        "v"
    ],
    [
        "LOAD_FAST",
        "newlevel"
    ],
    [
        "CALL_FUNCTION",
        "cheap_repr(v, newlevel)"
    ],
    [
        "BINARY_MODULO",
        "'%s = %s' % (k, cheap_repr(v, newlevel))"
    ],
    [
        "CALL_METHOD",
        "pieces.append('%s = %s' % (k, cheap_repr(v, newlevel)))"
    ],
    [
        "LOAD_FAST",
        "n"
    ],
    [
        "LOAD_FAST",
        "maxparts"
    ],
    [
        "BINARY_ADD",
        "maxparts + 2"
    ],
    [
        "COMPARE_OP",
        "n > maxparts + 2"
    ],
    [
        "LOAD_FAST",
        "pieces"
    ],
    [
        "LOAD_METHOD",
        "pieces.insert"
    ],
    [
        "LOAD_FAST",
        "maxparts"
    ],
    [
        "BINARY_FLOOR_DIVIDE",
        "maxparts // 2"
    ],
    [
        "CALL_METHOD",
        "pieces.insert(maxparts // 2, '...')"
    ],
    [
        "LOAD_METHOD",
        "'; '.join"
    ],
    [
        "LOAD_FAST",
        "pieces"
    ],
    [
        "CALL_METHOD",
        "'; '.join(pieces)"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.expr"
    ],
    [
        "CALL_FUNCTION",
        "isinstance(node, ast.expr)"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.Num"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.Str"
    ],
    [
        "LOAD_GLOBAL",
        "getattr"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "CALL_FUNCTION",
        "getattr(ast, 'NameConstant', ())"
    ],
    [
        "CALL_FUNCTION",
        "isinstance(node, (ast.Num, ast.Str, getattr(ast, 'NameConstant', ())))"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_GLOBAL",
        "getattr"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "CALL_FUNCTION",
        "getattr(node, 'ctx', None)"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.Store"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.Del"
    ],
    [
        "CALL_FUNCTION",
        "isinstance(getattr(node, 'ctx', None),\n                            (ast.Store, ast.Del))"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.UnaryOp"
    ],
    [
        "CALL_FUNCTION",
        "isinstance(node, ast.UnaryOp)"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node.op"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.UAdd"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.USub"
    ],
    [
        "CALL_FUNCTION",
        "isinstance(node.op, (ast.UAdd, ast.USub))"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node.operand"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.Num"
    ],
    [
        "CALL_FUNCTION",
        "isinstance(node.operand, ast.Num)"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.List"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.Tuple"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.Dict"
    ],
    [
        "CALL_FUNCTION",
        "isinstance(node, (ast.List, ast.Tuple, ast.Dict))"
    ],
    [
        "LOAD_GLOBAL",
        "any"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_METHOD",
        "ast.iter_child_nodes"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "CALL_METHOD",
        "ast.iter_child_nodes(node)"
    ],
    [
        "CALL_FUNCTION",
        "(is_interesting_expression(n) for n in ast.iter_child_nodes(node))"
    ],
    [
        "CALL_FUNCTION",
        "any(is_interesting_expression(n) for n in ast.iter_child_nodes(node))"
    ],
    [
        "UNARY_NOT",
        "not any(is_interesting_expression(n) for n in ast.iter_child_nodes(node))"
    ],
    [
        "UNARY_NOT",
        "not (isinstance(node, (ast.Num, ast.Str, getattr(ast, 'NameConstant', ()))) or\n                 isinstance(getattr(node, 'ctx', None),\n                            (ast.Store, ast.Del)) or\n                 (isinstance(node, ast.UnaryOp) and\n                  isinstance(node.op, (ast.UAdd, ast.USub)) and\n                  isinstance(node.operand, ast.Num)) or\n                 (isinstance(node, (ast.List, ast.Tuple, ast.Dict)) and\n                  not any(is_interesting_expression(n) for n in ast.iter_child_nodes(node))))"
    ],
    [
        "LOAD_FAST",
        "(is_interesting_expression(n) for n in ast.iter_child_nodes(node))"
    ],
    [
        "STORE_FAST",
        "n"
    ],
    [
        "LOAD_GLOBAL",
        "is_interesting_expression"
    ],
    [
        "LOAD_FAST",
        "n"
    ],
    [
        "CALL_FUNCTION",
        "is_interesting_expression(n)"
    ],
    [
        "LOAD_GLOBAL",
        "cast"
    ],
    [
        "LOAD_GLOBAL",
        "dict"
    ],
    [
        "LOAD_GLOBAL",
        "__builtins__"
    ],
    [
        "CALL_FUNCTION",
        "cast(dict, __builtins__)"
    ],
    [
        "STORE_FAST",
        "builtins"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "LOAD_ATTR",
        "ast.Name"
    ],
    [
        "CALL_FUNCTION",
        "isinstance(node, ast.Name)"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node.id"
    ],
    [
        "LOAD_FAST",
        "builtins"
    ],
    [
        "CONTAINS_OP",
        "node.id in builtins"
    ],
    [
        "LOAD_FAST",
        "builtins"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_ATTR",
        "node.id"
    ],
    [
        "BINARY_SUBSCR",
        "builtins[node.id]"
    ],
    [
        "LOAD_FAST",
        "value"
    ],
    [
        "IS_OP",
        "builtins[node.id] is value"
    ],
    [
        "LOAD_GLOBAL",
        "isinstance"
    ],
    [
        "LOAD_FAST",
        "node"
    ],
    [
        "LOAD_GLOBAL",
        "getattr"
    ],
    [
        "LOAD_GLOBAL",
        "ast"
    ],
    [
        "CALL_FUNCTION",
        "getattr(ast, 'NameConstant', ())"
    ],
    [
        "CALL_FUNCTION",
        "isinstance(node, getattr(ast, 'NameConstant', ()))"
    ]
]