f"\n    (?:\n        # an empty statement\n        (?:  # <EMPTY>\n            ;\n         )\n        |\n\n        # compound type decl (maybe inline)\n        (?:\n            (?:\n                (?:  # <COMPOUND_LEADING>\n                    [^;{{}}]+?\n                 )\n                 \\s*\n             )?\n            (?:  # <COMPOUND_KIND>\n                {COMPOUND_TYPE_KIND}\n             )\n            (?:\n                \\s+\n                (?:  # <COMPOUND_NAME>\n                    {STRICT_IDENTIFIER}\n                 )\n             )?\n            \\s* {{\n         )\n        |\n        # bogus inline decl artifact\n        # This simplifies resolving the relative syntactic ambiguity of\n        # inline structs.\n        (?:\n            (?:  # <FORWARD_KIND>\n                {COMPOUND_TYPE_KIND}\n             )\n            \\s*\n            (?:  # <FORWARD_NAME>\n                {ANON_IDENTIFIER}\n             )\n            (?:  # <MAYBE_INLINE_ACTUAL>\n                [^=,;({{[*\\]]*\n                [=,;({{]\n             )\n         )\n        |\n\n        # typedef\n        (?:\n            \\b typedef \\b \\s*\n            (?:  # <TYPEDEF_DECL>\n                {_ind}\n             )\n            (?:\n                # We expect no inline type definitions in the parameters.\n                \\s* [(] \\s*\n                (?:  # <TYPEDEF_FUNC_PARAMS>\n                    [^{{;]*\n                 )\n                \\s* [)]\n             )?\n            \\s* ;\n         )\n        |\n\n        # func decl/definition & var decls\n        # XXX dedicated pattern for funcs (more restricted)?\n        (?:\n            (?:\n                (?:  # <VAR_STORAGE>\n                    {STORAGE_CLASS}\n                 )\n                \\s*\n             )?\n            (?:\n                (?:  # <FUNC_INLINE>\n                    \\b inline \\b\n                 )\n                \\s*\n             )?\n            (?:  # <VAR_DECL>\n                {_ind}\n             )\n            (?:\n                # func decl / definition\n                (?:\n                    (?:\n                        # We expect no inline type definitions in the parameters.\n                        \\s* [(] \\s*\n                        (?:  # <FUNC_PARAMS>\n                            [^{{;]*\n                         )\n                        \\s* [)] \\s*\n                        (?:  # <FUNC_DELIM>\n                            [{{;]\n                         )\n                     )\n                    |\n                    (?:\n                        # This is some old-school syntax!\n                        \\s* [(] \\s*\n                        # We throw away the bare names:\n                        {STRICT_IDENTIFIER}\n                        (?: \\s* , \\s* {STRICT_IDENTIFIER} )*\n                        \\s* [)] \\s*\n\n                        # We keep the trailing param declarations:\n                        (?:  # <FUNC_LEGACY_PARAMS>\n                            # There's at least one!\n                            (?: {TYPE_QUALIFIER} \\s* )?\n                            {_ind}\n                            \\s*\n                            {_ind}\n                            \\s* ;\n                            (?:\n                                \\s*\n                                (?: {TYPE_QUALIFIER} \\s* )?\n                                {_ind}\n                                \\s*\n                                {_ind}\n                                \\s* ;\n                             )*\n                         )\n                        \\s* {{\n                     )\n                 )\n                |\n                # var / typedef\n                (?:\n                    (?:\n                        # initializer\n                        # We expect only basic initializers.\n                        \\s* = \\s*\n                        (?:  # <VAR_INIT>\n                            "